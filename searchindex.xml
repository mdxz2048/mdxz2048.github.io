<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>上班的路上</title><url>https://mdxz2048.github.io/post/%E4%B8%8A%E7%8F%AD%E7%9A%84%E8%B7%AF%E4%B8%8A/</url><categories><category>想法</category></categories><tags><tag>光明</tag></tags><content type="html"> 从住处到地铁站需要走一段大概八百米的一条直直的人行道，一块一块砖铺起来的，人行道的左边，是用来隔着马路的一排光秃秃的枫树，右边是住宅楼，先经过一段别墅区的，再经过一排小区的外墙，跨过一个红绿灯，就到我要去的地铁站了。从搬到这边开始，这条路几乎要走一遍，公司的上班时间比较早，一般走过这一段路是每天早上的7:17-7:27，人不是很多，最近出门，天还是蒙蒙刚亮。 这几天早上，每天会遇到一位盲人大哥跟我同一个方向，他手里拿着一根轻盈的、银色的棍子，穿一身黑色的工装服，尽可能避免冒犯到别人，我一直没抬头看大哥的面部。因为我们俩走路的速度几乎是一样快，所以朝旁边多看了几眼，他每横着敲三下用来确认下一步的落脚位置，棍子好像是带了弹性，第三下抬起的时候会高高离开地面，随后迈向刚探查出的安全区域，很熟练。刚开始经过别墅区这一段的时候，因为右侧多了一些小花园，我看到他前两下敲打在了路面上，第三下敲在了花园的小台阶上，然后就往左扭了下身子，回到了和我同行的位置。到下台阶的时候，他一下敲空，又往深的敲了两下才够到地面，接着就开始准备下台阶，感觉已经看清楚了脚下的路，下的很稳健，走得很轻盈，匆匆忙忙的样子。随后，下了台阶，为了赶着上班，我就小跑着赶路了。
让人感叹的是大哥对手里棍子的信任，敲下、弹起、抬腿，再敲下、再抬腿&hellip;&hellip;然后就可以向前、向左，不怀疑、不犹豫，似乎他眼前的路，比我看到的更加清楚，从走路的样子看，他比我要更清楚地看到了脚下。如果是我的话，得需要多久才能学会这样。
我经常会设想假如自己有一天躺着不能动，或者能动却看不见的时候，该如何生活？我思考过了，如果只是不能动的那种，我几乎可以不怎么受影响，我还可以找台电脑、接上网络继续做着编程的工作。对于看不见的生活，可以依靠弹吉他加上唱歌，走到街上去卖唱来赚一些生活费，然后给自己打造一个安全的空间，通过听书、听故事、听音乐来接受新的讯息，那我应该不会很悲伤吧，可是我现在还不会弹哪怕一点吉他，所以我得要去学会弹吉他，起码得弹出许巍的《旅行》，因为我不想卖唱的时候，再唱那种特别惨的歌。不过，如果是既不能动、又看不见的情况，现在还没有想出什么结果来，可以多给我一点时间，总会有办法的。</content></entry><entry><title>2023年终总结</title><url>https://mdxz2048.github.io/post/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url><categories><category>想法</category></categories><tags><tag>年终总结</tag></tags><content type="html"> 又到了一年记流水账的时候了，今年是最短平快的一年，有很多小的生活中的惊喜值得在年尾的时候记录下来。比如拥有了人生中第一台MacBook电脑、写出了人生中第一个网页(目前还在运行)、办下了人生的第一个签证(还是3年免签)、体验了在冬天的后海湖面上和女朋友一起滑冰、减掉了持续数年的脂肪肝&hellip;&hellip;
我真的想认真记录我第一次使用MacBook的体验和感受，除了这是我从高中时候的梦想电脑，还因为它真的是有提升了对电脑的使用体验。
不得不承认，我就是个果粉，第一次拥有iPad是2017年，在大学学校门口，等着苏宁易购的派送员将iPad2017送到了我手里，那是一个晚上；第一次拥有iPhone是2019年，那是上班的第一年，我坐了将近1小时公交车去国美电器的线下店取前一天订到的iPhone11，那是周六的早上，到店里的时候还没有营业，我是跟着店员从仓库里取出来的；第一次拥有MacBook，是今年的7月份，一大早我是在家里等的快递，甚至我洗干净了手才开箱的。说实话，2021款的MacBook pro是有点沉的，我双手从箱子里小心的捧出来，是真的开心，放到我早已经清理好的桌子上，充了20分钟电，熬过了这一年最漫长的20分钟，虽然已经多少次在applestore里摸过这台机器，我还是小心翼翼，用最可靠的左手拇指掀起了屏幕，当咚的一声响起，也宣告着，我的MacBook正式服役。
虽然我是程序员，日常工作都在和电脑打交道，但周内回到家我一般也是很少使用电脑。自从有了这台mac，我开始周内回去打开看会视频，也慢慢习惯了笔记本离开电源，随身带到沙发上、床上来看一些视频，甚至写一些代码，因为它超长的使用时间(几乎是10个多小时)，也大大的降低了iPad的使用时长，就像NBA的一支球队，来了一个超级巨星，势必是会挤压掉那些菜鸟们的上场时间。
虽然是在上班时间写的上边这一段，但还是抑制不住的兴奋。还有一件事情要记录，就是这一年对chatGPT的使用，从年初开始，我就想方设法的订阅到了价值20美元/月的chatGPT PLUS,这对我这一年的影响很大，有积极的一面，也有让人警惕的地方。
先说好的，用上了chatGPT，我用它写了人生第一个网页。
对于一个从单片机开始入门的人来说，对于服务器、网络、网页这些东西天生是有距离的，这是一个嵌入式从业人员和传统意义上的程序员之间的距离，因此，在很长一段时间，我并不认为自己是大家眼中的程序员，因为确实不是。不过，毫无疑问我对成为一个传统程序员这些是感兴趣的，或者是我很好奇我所不了解的这些东西。但是迫于专业上的需求，我几乎是毫不犹豫的，一次次将时间给到了专业上。直到我开始用上了chatGPT，这是一个神奇的工具，在几乎任何方面，它都能像一个熟练的老师傅一样对你提出的问题给一个答案，当然，老师傅也会出错，但是老师傅的经验和眼界，往往对我们解决问题是有帮助的。在chatGPT的帮助下，我用GO语言写了后端应用，去解析kindle的笔记文件，并上传到notion的database中；用vue写了前端，部署到了服务器上。这样，就可以通过网页的形式，将kindle中的笔记内容，存储到notion数据里。这里想多扯一句，因为每天上班都会在kindle上看会儿书，一年下来，一共看了有13本，两年多下来，一共一共从地铁上看了33本书。虽然有时候统计这些数字让人觉得很轻浮，但做到的人是自己的时候，是真的骄傲。不知道是不是跟老看东西的原因，慢慢的， 发现越来越活在自己的节奏里，看到了身边相反的例子，总觉得自己做对了些什么。
相关的，需要提一下chatGPT这种东西带来的弊端，有时候会让人过度依赖，比如看一篇博客的时间缩短到了简单的一问一答；通过搜索引擎的搜索对比的时间缩短到了简单的一问一答；慢慢入门学习、练习的过程缩短到了复杂的一问一答；似乎很多事情离答案越来越近，但需要警惕的时候，可能会让认知越来越窄。就像，我们看了一部电影的5分钟解说，或是考试时候直接得到了答案。最后，虽然都得到了结果，也少了很多意外和惊喜。我还会为chatGPT续费，还会为GitHub copilot续费，但我会越来越谨慎的把它当作一个工具，就像在汽车工业时代，人也需要拥有长跑的能力一样。
关于旅行，是在2023年最后几天里，我们三个人一起去的北京。本来只是想陪着女朋友在大考之后出去转转，对于北京，我没有很期待，对于北方的寒冷，当然也不陌生。超哥在北京，当然刚到就约出来了，我们一行4人去了后海，说是这里可以滑冰，我对这里的印象，全部来自朴树的那首《猎户星座》的视频中，冰天雪地里穿着毛裤的朴树，夕阳斜照着听歌的人群，偶尔天空中几只鸟飞过，让人觉得这个叫做什刹海的地方就该如此浪漫。不过，我们去的时候，没有朴树，只有寒冷，从旁边小吃街吃了一个油炸螃蟹，连口水都没有喝，就冲进了冰面上。冰面上的玩具车都是要靠捡的，一千多人在冰面上来来回回，我们也只能从旁边入口和出口处，等待前人的施舍，当然也不光是等待，我们也需要主动寻找目标，比如跟在一对玩累的情侣后边，接过他们的自行车。当我们四个人，靠着自行车串起来，在冰面上被拖着走的时候，有点那种超拉雪橇的味道，坐在后边的人，就像个地主一样，催促着前边给家里赶车的长工。当然，每个人都有坐地主的时候，在这冰面上，零下好几度的北京，一点也不觉得寒冷。我们在冰面上滑冰，在冰面上聊天，在冰面上度过了2023年最后一个夜晚。
另外一个关于旅行的，无疑是护照上那张去日本的三年签证，对于出国，这无疑是对于我等小白更容易的地方。我一直在想做一些没做过的事情，去一些没去过的地方，能够去一次日本，可以算是比较简单的第一步了。现在，有了签证，也就能随时实现了，就等着一个合适的契机了。
关于一些生活的感受
就像那句话说的，大家的生活各有一片望不到头的汪洋。这两年经济的不景气、生活的躁乱，再加上无处不在的短平快，无时无刻不在吹打着飘在海面上的一艘艘小船，见到了太多的人看不到生活的希望，或是经历了什么失败走不出来，或者是不知道该如何走出来。迷茫，迷茫的人太多，好像人被卡在了某一个地方，往前往后都不行。今年听到了很多这样的故事，有人在迷茫里结婚，有人在迷茫里读书上学，有人在迷茫里失业几个月，再去上班，有人在迷茫里继续迷茫。我不知道该如何解决这些问题，我也不庆幸我没有在其中，只是希望，这一切都将会过去。我相信，一切都会过去，再漫长的冬天，也总能够等到春天的到来。
对于明年，我可能要买人生的第一辆车了，我在前几天的一段话中，找到了买车的意义：
车多，使整个社会构成一个动态的整体，随着车辆运动的不仅有人和物品，还有思想、观念和精神；
电话多，使整个社会构成四通八达的信息系统，语言的传递伴随着情感、信息的传递；
电脑多，使整个社会管理的一体化达到很高的程度，电脑信息是一种公平的管理；
卡多，使整个社会的管理符号化，使人们对实物（人和物）的管理中解放出来，变成符号管理。
希望我也能够让思想、观念、精神和快乐，一起运动起来，从生活上，我对新的一年充满了期待。
穿新衣吧 剪新发型呀
轻松一下 Windows98
打扮漂亮 十八岁是天堂
我们的生活甜得像糖</content></entry><entry><title>逐渐单一的价值观</title><url>https://mdxz2048.github.io/post/%E9%80%90%E6%B8%90%E5%8D%95%E4%B8%80%E7%9A%84%E4%BB%B7%E5%80%BC%E8%A7%82/</url><categories><category>想法</category></categories><tags><tag>总结</tag></tags><content type="html"> 我不再用“我们”，我是我，他是他。没有一代人，那只是个观念，只有张三李四王二麻子。我谁也不能代表，我只能代表我自己,究竟能不能代表我自己，我也常常感到怀疑。
这张封面是昨天拍的，就好像这几天的心情一样，去年的最后一天还在手边，而新的一年还不知道从哪儿开始。各种社交媒体前赴后继的推送来了今年的“榜”，好像这长长的经历就能通过几页海报概括一样。
昨天起床比较晚，大概十点钟才起身。我一个人在租的房间里待着，这种短暂的独处好像可以让整个人都放松下来，可以不用看着点的吃饭和睡觉，肆意的做自己愿意做的事情，虽然在这两年我以自己按时吃饭和早睡标榜自己，但是短暂的打破还是有着一种挥霍的快感。自己是个闲不住的人，好几次都是一个人的时候，就开始折腾计算机相关的东西，也都快要分不清楚是兴趣还是工作了。不过，按照往年的习惯，我还是习惯在阳历年的最后几天里，规整一下自己，也期待一下未来。最近看过了太多的总结标题，出于避免视觉疲劳和厌恶，这一次我尽可能的不用到年份，同样这一次，我尽可能的少虚伪，多说实话。
这次，将作为一个在二十八岁年轻人身边的旁观者，看一看这个人在二十七岁的时候都干了些什么，也瞅一眼，他对来年的一些寄托，当然，作为这么熟悉的人，我们都知道他缺乏长性，这些规划能够做出来到什么程度，也完全不可控，但希望总是美好的。
二十七岁 不确定从哪一天开始，我开始希望自己成为一个更关注生活和自己的人，对于那些杂乱和无能为力的事情，尽可能不让出现在眼前，人为的制造一个平静的氛围。这一年来，我也在不断地给自己提出一些问题，比如”我为什么是一个这样悲观的乐观性格？“，”从小到大，对我重要的老师们？“，又或者是“以虚荣的名义努力”是否是一个好的借口。问题想清楚了，每次都要想着写点东西记一下，可是从来都想不起来写。
我把这一年自己的一些新的感悟整理成四个问题，昨天在自己喜欢的一款思维导图软件(MindNode)上列了一下，就当作自己的回答。
喜欢什么？ 这里将列出我所认可的一些品质和习惯(不一定是自己有的，也有自己欠缺的)。
追求提高认知
自律和坚持
自律能够最大程度的激发人的潜力，不浪费自己的才华和天赋，我很希望能够成为一个自律的人。同时，又能够在对生活上做到张弛有度，避免成为一个无趣的机器人；
这一年我开始认可坚持，坚持能让你等到花开时，是时间对人的考验，是宇宙赐予生命最大的智慧。不能够约束自己的人，没有智慧，也没有定力，没有定力则没有平静，没有平静，何来幸福？
以虚荣的名义努力
这是一句听来的话，但是很对我们口味，我一度写在家里的小白板上来告诫自己和别人，后来被女朋友擦了，画上了一个花瓶。
喜欢哭
这里的喜欢倒不是那种隔三岔五的哭一次，是在某一天才发现，我们被很多东西裹挟着，从小到大无数的声音告诉你不能哭，直到把你培养成一个木讷的石头或者是冷血的机器人。我越来越觉得时不时的能够被感动到，能够表达自己的负面情绪，也是一种自由。做一个爱笑爱哭的有情感的人。
健康的生活
这一点必须感谢女朋友，让我也跟着成为了一个作息规律的人。从大学入学到现在，已经大概七年时间，也就只有这一两年，我才学会了晚上十点到十点半睡觉，保证了每天长达八个小时的睡眠。一定要将这种习惯发扬光大。
缺乏长性
缺乏长性让我问能够在一些瞬间迸发出灵感，有一些新鲜的、有趣的想法产生，所以在现在这个阶段，还不错。
讨厌什么？ 政治正确/没有立场
必须要说，我从很早很早的时候，就意识到自己是一个比较极端的性格，喜欢立场鲜明的观点，讨厌模棱两可的表达。到今年，在听一期播客的时候，听到了相主播说讨厌政治正确，这一句犹如醍醐灌顶，给我这一下子拔了高度，坚定了立场，就是讨厌这个。
碎片化的信息农场
话多
我肯定自己是一个碎嘴子，很长一段时间我觉得无药可救了。后来，我迷信上了读书，希望能通过读书来让自己的话少一点，思考多一点，很显然还没有成功，不过我也没有放弃。
缺乏长性
在做一个短期的规划的时候，缺乏长性会导致往往高开低走，导致很多事情烂尾，比如今年写的开源翻墙软件烂尾、写的驱动开发手册烂尾，脑壳痛。。。
想做没有做的？ 缺乏运动
没有能够去一个满意的地方
我希望做好准备，去一个和自己认知、喜好匹配的，美好的地方做短暂的旅行。
因为不喜欢二次元，但是也尝试着看东野圭吾、村上春树这些日本作家的作品，再加上对日本在工业方面严谨、极致的传说的向往，一直很想去一次日本，感受一下生活的另一个样子。
没有能够在开源项目上有所贡献
没有入门理财
本来是有机会入门的，年初的生活买了一本书，书名叫《看不见的美国》，简介里写的是“很多人都不知道，自己的国家到底是怎么运转的。看不见的美国，其实一直都在。”我就先入为主的以为这是一本讲国家运转原理的书，也就因此错过了进入理财的行列。
学习英语再次失败
学(得)到了什么？ 比起想做没有做的，今年收获的要更多一些，基本上是按照时间顺序排下来的。
驾照
两年前在深圳报的驾校，科目二考了三次通过，科目三考了两次没过。后来转到重庆，前后花了大概有小一万的成本，但是依然没有考过，这次在重庆科目三第一次考试就通过，顺利拿到驾照，也算是去掉了一块心病。
学会了游泳，开始尝试健身
看到了女朋友在朝着目标前进
上周末两天女朋友参加了今年的研究生考试。我和女朋友都是学习比较差的，从去年开始准备考研，今年工作上的变动和生活中的阻力，看到了这一年女朋友从一个不擅长学习的样子一点一点的摸索，无数次的情绪爆发。虽然每天骂骂咧咧，但转身就继续学习，到最后顺利的完成了今年的四门考试，真心感到高兴。更让人开心的是，我们一直担心的英语似乎考的不错，很幸运能够见证这些。
工作上的自我认可
这一年有几次一个人出差的经历，在几次活动中一个人在前边解决问题，虽然累是累了点，但问题解决的那一刻，设备正常跑起来的时候，也是对自己能力的一种认可。经常说小组是一个草台班子，可能这就是草台班子的好处吧，能够多一些这种机会向自己证明自己。
生活缝隙中的阅读
认真数了一下，这一年一共读了21本书，其中kindle上有12本，纸质的书9本。有时候甚至读到感动处，在六号线我的通勤专用角落里也会落泪。还有几次，是在女朋友上课附近的奶茶店、快餐店看书，回想起来也很有意思，可能也会在别人眼里，被当作一个奇怪的景象，不过那些都不重要了。
重庆生活的快乐和满足
正如网传的那样，重庆就是那样的充满了烟火气息。去年搬到现在这边住下来，旁边的川菜、小面、米线、烧烤、臭豆腐、煎饼……有太多的小吃可以在下班之后、周末无聊的夜晚给人以慰藉。不用挨个细数和对比，每一家都有独特的味道来伺候你的胃，如果不用经历夏天的闷热，重庆简直就是幸福生活的天堂。
开始认识到理解、相信人和包容在相处中的重要性。
二十八岁的期待 本来在这一块也整理了一张图，突然觉得没有必要放上来，那就干脆不写了，让时间来慢慢见证这些变化。</content></entry><entry><title>计算机那点事儿之减法器</title><url>https://mdxz2048.github.io/post/study_programmer_subtractor/</url><categories><category>程序员的日常</category></categories><tags><tag>减法器</tag><tag>编码</tag></tags><content type="html"> 在写今天关于减法器文章之前，我需要多解释一下，计算机那点事儿xxx这一系列内容实际是我在读《编码-隐匿在计算机软硬件背后的语言》这本书时做的验证，目的是在加深自我理解的同时，能够成体系的梳理一下对计算机软硬件的认识，因此，一些方法和概念更偏向于直接告诉大家结果，而不是根据认知去推理这些方法的由来，就像上一篇计算机那点事儿之加法计算器中，针对用逻辑门来标识1bit加法器的进位和加和位这种方法，我也是根据书中的介绍进行展开。所以，在很多衔接部分就比较生硬，当然我也没有打算要在这个阶段去补上这些环节，可能会在很久很久以后，或者是我被隔离了实在有时间，会将自己知道的这些内容，完整的表述出来，而目前能做的，就是先让这些内容呈现出来而已。
在计算机那点事儿之加法计算器中，我们介绍了如何通过基本的逻辑电路搭建一个8Bit的加法器。本篇我们来介绍如何来通过改造上一篇中的加法器，实现一个不完整的减法器。之所以是不完整的，是我们没有在这里讨论结果是负数的情况(即减数大于被减数)。
问题 实现一个减法器(被减数大于减数)
思考 在加法计数器中，我们解决的是进位问题，在减法中，我们比较关注的是借位问题。
这一次，我们需要先明确我们目前掌握的工具，与门、或门、非门、与非门、或非门、异或门以及8bit加法器。
因此，我们不必像加法器中那样分析结果，我们用另一种方式来观察一下两个十进制数241和135的减法： $$ \begin{array}{r} 241-135=106 \end{array} $$ 在这里，我们在个位减法中，需要向十位借1，至今我仍然觉得，这是小学算术中很抽象的一个动作，十位要是不借呢？为了防止十位不借(减少这一步操作，去凑一个用电路更方便实现的做法)，我们需要对借位这个动作做一些改造，我们将这个算式改写成这样： $$ 241+(999-135)+1-1000=106 $$ 为了避免借位发生，我们在计算时，给等式左边先加了999+1，再减1。用数学老师的话来说，我们对等式做了一次恒等变形。
我们解释一下这个999-135，这个动作叫做对减数取十进制的补数。135对9取补数，135的补数是864。通过这动作，我们就可以避免借位操作，而且在二进制中，这个动作做起来异常容易。
补数**（complement）是对于给定的进位制，相加后能使自然数 a 的位数增加 1 的最小的数。**
取补完成后，我们将被减数与减数的补数相加，结果+1，再减去1000,即可得到最终的结果。
分析 根据如上思考过程，我们可以将十进制的减法避免借位的这种方法，推广到二进制中。
这里，需要补充一下，二进制求补码的操作：
在二进制中(对1的补数)，只需将原来的二进制数的1变为0，0变为1即可。因此，对1求补数有时也称为相反数(negation),或反码(inverse)。
举个例子，求135的补数：
135 10000111 inreverse 01111000 方案 这里再强调一下，我们针对的是减数小于被减数的减法。因为负数在二进制的标识是另一个概念，二进制中只有0和1，关于符号位的表示，我们在这一篇不做讨论。接下来，我们总结一下我们的方案：
减数求对1的补数：直接使用反向器进行取反； 被减数+减数：借助上一节的加法器； +1：对上一节加法器进行改造，将第0位的进位输出改连接到加/减法选择位(原来是直接接0)。即，选择减法时，我们该位为1，即实现+1操作； 减去一个1 0000 0000,因为我们这减数和被减数都是8位：我们用一个CO输出位来表示减法的状态： 加法时，和以前一样，这一步表示一个加法和的最高位； 减法时， 当该位为1时，表示当前减法得到了一个负数(下溢，underflow)； 当该位位0时，则当前减数是小于被减数； 实验过程 按照上述方案，我们对加法器进行了如下改造：
增加1个加法、减法切换按钮,这里用SUB来代替； 0表示加法 1表示减法 最低位的进位位输入改为接到SUB按钮，即当为减法时，该为位1，用来执行+1操作； 最高位(原第9位)的输出，该为输出与SUB按钮求异或(XOR)，来输出，代表的含义如上。 接下来，我们来用我们的减法器来计算：241-135
241 11110001 135 10000111 图中的结果显示为：溢出位为0，结果为0110 1010，即十进制表示为106；
至此，我们就可以完成了这个简易的减法器。
结论 我们通过对加法器进行改造，增加了1个异或门、8个取反器、1个加/减法切换开关，实现了基本的减法器。</content></entry><entry><title>计算机那点事儿之加法计算器</title><url>https://mdxz2048.github.io/post/study_programmer_adder/</url><categories><category>程序员的日常</category></categories><tags><tag>编码</tag></tags><content type="html"> 实验介绍 经过上一节计算机那点事儿之0和1的内容介绍，我们掌握了4个逻辑门电路与门(AND)、或门(OR)、与非门(NAND)和或非门(NOR)的真值表(输入输出关系)和特征描述图。
这一节，我们利用上一节的知识，来完成一个8比特位的加法器，通过上述逻辑门来组合一个支持8bit的加法计算器。
实验目的 模拟出8bit的加法计算器 实验准备 在本次实验前，我们需要先贴出上一节计算机那点事儿之0和1中的两个结论，这会在本节中重复用到。
结论1 真值表 结论2 形状特征标识 本次实验共分为3个部分：
观察1个比特位的加法，异或门 半加器 全加器 8bit的加法器 实验过程 实验1 1个比特位的加法 首先，我们观察一下2个1bit的数字相加的所有结果,这里所有结果都为二进制；
2个1bit的数字A和B相加 A=0 A=1 B=0 00 01 B=1 01 10 我们可以看到，这里在A和B都为1时，出现了进位，结果为10(是不ten哦)，其中进位为1，加和位为0。也就是说，当两个1bit的数字相加时，出现的结果最多为2bit，这个很重要，因此，我们在其余3个结果前都加上进位为0，尽管它是0。
在这里，为了方便我们观察，我们将进位和加和位分开，效果如下：
进位 A=0 A=1 B=0 0 0 B=1 0 1 加和位 A=0 A=1 B=0 0 1 B=1 1 0 我们首先观察进位位的结果，对比文章开始贴出来的真值表，不难看出其结果与与门的结果完全一致，因此，在我们的加法运算中，进位位置就可以用一个与门计算结果。这不得不说是一个令人振奋人心的消息。
继续观察加和位之前，我们再熟悉一下我们的真值表吧；
不知道大家有没有发现，我发现了或门、与非门和加和位的关系：即是或门和与非门的结果的交集(一样的部分)的结果和加和位得到结果是一致的。
这里我们在观察 与门(AND)的真值表不难发现，所谓的交集可以用与门来实现，因此，我们用1个或门、1个与非门和1个与门来得到加和位。在Proteus中实现的效果如下图：
根据Proteus中的效果图，我们可以得到这样一张真值表，这也就是我们介绍的最后一个逻辑电路，异或门。顾名思义，只有当输入A和B不一样的时候结果为1，否则结果为0。
XOR 输入A0 输入A1 输入A 0 0 1 输入A 1 1 0 实验2 半加器 根据实验1的结论，我们就可以得到一个支持两个1bit位相加的电路。在proteus中实现的效果如下：
左侧为输入A和输入B，右侧的输出结果分别是进位位CARRY BIT和加和位SUM BIT；
当输入为1 和 0时，CARRY BIT为0，SUM BIT为1；
当输入为1 和 1时，CARRY BIT为1，SUM BIT为0；
实验3 全加器 在实验2中，我们得到的只是半加器，输入只有2个bit。为了将3个1bit的数字进行运算(多出1个进位位输入)，我们可以设计如下电路，这也就是我们本次实验要完成的全加器。
基于半加器，我们可以这样理解这个电路：
代表最终加和位R_SUM_BIT的状态：由输入A和B进行异或获取它们的加和位，再和输入的进位位进行异或，得到最终的结果加和位R_SUM_BIT；
代表最终进位位R_CARRY_BIT的状态：由输入A和B取与获得它们本身的进位位，再与AB的加和位与CI进位位的结果的进位位相或，得到最后的进位位R_CARRY_BIT;
上边这两句话比较绕，读起来可能没有看电路图容易理解。
如果大家理解了之后，我们可以看出来，我们的全加器输入端包括1个进位标志位、输入A和输入B，输出包括1个进位位和1个加和位。
现在，我们就可以完成我们8bit的加法器了。
实验4 8bit的加法器 从实验3中，我们已经掌握了将两个二进制数和1个进位位进行计算，所谓的8个二进制，也就是将8个全加器串起来，将前1次的进位位与作为本次的进位标志位输入，最后的效果在Proteus中是这样子的：
上边的两排A0-A7为输入A的8个bit位，第二排的B0-B7为输入B的8bit位； 在第一个(A0和B0)全加器的进位位，因为它永远不会有进位位，因此我们将其直接连接到地，永远置为0； 最后的结果二进制形式为R0-R7，进位位在我们图中表现为D1； 我们来测试一下我们的加法器，计算一个250+100 = 350；
首先，我们需要得到250和100的二进制形式，作为A、B输入：
250: 1111 1010 100: 0110 0100 将其输入到A、B，得到的结果为：进位位为1，R0-R7是0101 1110
我们将结果转换为十进制观察一下，值为350，证明我们的加法器工作正常。
实验结论 至此，我们掌握了如何通过基本的逻辑门搭建一个8位加法器，可以很容易通过这种方式扩展到16位、32位……
后边，我们将继续根据这些研究基础进行拓展，逐步的完善计算机背后的基础运作逻辑。</content></entry><entry><title>计算机那点事儿之0和1</title><url>https://mdxz2048.github.io/post/study_programmer_binary/</url><categories><category>程序员的日常</category></categories><tags><tag>编码</tag></tags><content type="html"> 实验名称 Proteus逻辑门演示实验
实验目的 我们都或多或少听过，整个电脑无论是图像、视频还是声音计算，最后都被当做0和1来处理，我们本文就来借助仿真软件Proteus，模拟出数字电路中的基础逻辑电路：与门(AND)、或门(OR)、与非门(NAND)和或非门(NOR)。
实验背景 终于经过2周的时间，《编码—隐匿在计算机软硬件背后的语言》这本书进入到了正式篇，本周的主要内容就是以数字电路为基础搭建加法器和减法器，这应该算是各种CPU数字电路的基础组成部分了，哪怕是苹果新发布得到A16，也脱离不了这种基本的硬件原理，版本的迭代更多是工艺上的进步，15nm到4nm，更多不同的是因为工艺的提升，带来单位面积上可以放置的晶体管数量的不同。但对于我们了解和学习计算机原理，A15/16显然不适合我们入门，反而是这种通过简单的开关、电源、继电器和小灯泡组成的小的电路，更有助于我们了解如何通过电路帮我们计算加法和减法，学习基本的计算机运行原理。
本文将通过电路仿真软件proteus，来模拟演示如何用小灯泡演示与门、或门、与非门和或非门电路。
基础知识 点亮一个小灯泡 实验介绍 相信在很多编程语言入门的时候，第一次编程实践课的内容都是用所学习的语言输出一个”Hello World!“，在我们硬件工程师的学习道路上，我们最开始面对的任务通常是点亮一个led灯。因此，点灯在硬件工程师成长道路上的重要性，基本上属于”Hello World!“级别的存在。
当然，我不是硬件工程师，所以接下来的各种电路图会有或多或少会不够严谨。我们更关注的是演示数字电路中的逻辑原理，因此，更多的是保证实验现象和逻辑上符合原理，至于上拉电阻或者其他之类的硬件问题，不在讨论之列。
实验目的 点亮一个小灯泡，熟悉小灯泡熄灭、点亮的现象。
实验准备 点亮1个灯泡我们这里一共用到了电池(battery)、开关(switch)、小灯泡(lamp)和若干导线。
实验过程 在实验中，我们可以看到，当开关按下的时候，小灯泡亮起；
当开关断开时，小灯泡熄灭。
认识继电器 实验介绍 继电器（Relay），也称电驿，是一种电子控制器件，它具有控制系统（又称输入回路）和被控制系统（又称输出回路），通常应用于自动控制电路中，它实际上是用较小的电流去控制较大电流的一种“自动开关”。故在电路中起着自动调节、安全保护、转换电路等作用。
简单来说，继电器可以理解为一个可以通过电路控制的开关。
实验目的 认识继电器； 认识反相器 实验准备 这个实验，我们需要在点亮一个小灯泡实验材料中，增加一个继电器，来通过继电器控制小灯泡。
实验过程 首先，我们通过如下实验现象，可以观察到通过开关来控制继电器的通断，从而来控制小灯泡的亮灭。
接下来，我们对上述继电器的连线进行一点点改造，将BAT2的电源正极连接到继电器的常闭触点，这样，在我们继电器没有动作时，小灯泡会处于点亮状态，当继电器因左边开关闭合动作后，反而灯泡熄灭。这就是一个反向器。
如上图，我们可以观察到，左侧开关与小灯泡的状态刚好相反。就相当于一个反向器，开关的输入与输出相反。
开关 小灯泡状态 按下 熄灭 断开 点亮 逻辑门电路 经过上边的介绍，我们基本上都熟悉了今天是实验现象，无非就是观察灯的亮灭。
接下来，我们来介绍我们本文要介绍数字电路中4个基本的逻辑电路，无论是苹果的FaceID面容识别还是高端的自动驾驶，在CPU的实现中，基本全部都被转换成了0和1组成的二进制数和这些基本的逻辑操作。今天我们就来了解它们吧。
与门 实验介绍 与门（英語：AND gate）是数字逻辑中实现逻辑与的逻辑门。仅当输入均为高电压（1）时，输出才为高電壓（1）；若输入中至多有一个高電壓时，则输出为低電壓。换句话说，与门的功能是得到两个二进制数的最小值，而或门的功能是得到两个二进制数的最大值。
实验现象 我们这里在Proteus搭建了一个简易的与门来模拟与门的实现，现象如下：
真值表 我们用真值表来反映逻辑门电路中输入与输出的关系，开关闭合描述为1、断开描述为0。
与门真值表如下：
AND 开关B的输入0 开关B的输入1 开关A的输入0 0 0 开关A的输入1 0 1 符号表 通过维基百科的描述，下列包括逻辑门的3种符号：形状特征型符号（ANSI/IEEE Std 91-1984）、IEC矩形国标（中国大陆）符号（IEC 60617-12）和不再使用的DIN符号（DIN 40700）。
或门 实验介绍 或门在维基百科描述如下：
或门（英語：OR gate）是数字逻辑中实现逻辑或的逻辑门，功能见右侧真值表。只要两个输入中至少有一个为高电平（1），则输出为高电平（1）；若两个输入均为低电平（0），输出才为低电平（0）。换句话说，或门的功能是得到两个二进制数的最大值，而与门的功能是得到两个二进制数的最小值。
实验现象 我们这里在Proteus搭建了一个简易的或门来模拟与门的实现，现象如下：
真值表 OR 开关B的输入0 开关B的输入1 开关A的输入0 0 1 开关A的输入1 1 1 符号表 在维基百科中或门的符号表描述如下：
下列包括逻辑门的3种符号：形状特征型符号（ANSI/IEEE Std 91-1984）、IEC矩形国标符号（IEC 60617-12）和不再使用的DIN符号（DIN 40700）。其他的逻辑门符号见逻辑门符号表。
与非门 实验介绍 与非门在维基百科描述如下：
与非门（英語：NAND gate）是数字逻辑中实现逻辑与非的逻辑门。若输入均为高电平（1），则输出为低电平（0）；若输入中至少有一个为低电平（0），则输出为高电平（1）。与非门是一种通用的逻辑门，因为任何布尔函数都能用与非门实现。
实验现象 与非门根据字面意思来看就是在与门的基础上取反，用到了我们前边的反向器。同样地，我们也搭建了一个简单的电路：
真值表 NAND 开关B的输入0 开关B的输入1 开关A的输入0 1 1 开关A的输入1 1 0 符号表 在维基百科中或门的符号表描述如下：
或非门 实验介绍 或非门是我们本文介绍的最后一个逻辑门电路，它在维基百科中介绍如下：
或非门（英語：NOR gate）是数字逻辑中实现逻辑或非的逻辑门。若输入均为低电平（0），则输出为高电平（1）；若输入中至少有一个为高电平（1），则输出为低电平（0）。或非是逻辑或加逻辑非得到的结果。或非是一种具有函数完备性的运算，因此其他任何逻辑函数都能用或非门实现。相比之下，逻辑或运算器是一种单调的运算器，其只能将低电平变为高电平，但不能将高电平变为低电平。
实验现象 真值表 NOR 开关B的输入0 开关B的输入1 开关A的输入0 1 0 开关A的输入1 0 0 符号表 或非门的符号表，在维基百科中描述如下：
实验总结 最后，我们需要总结一下本次实验，这里我们主要需要记住4个与非门真值表和对应的形状特征表。这将在我们后续的加法器、减法器实验中进行大量应用。
真值表 形状特征标 好了，这一次我们就先整理到这里，现在我们都认识了基本的逻辑门电路，后边我们将会通过这些逻辑门电路来实现简单的加减法计算器。</content></entry><entry><title>和唯一知道脆司令为什么脆的人散步</title><url>https://mdxz2048.github.io/post/%E5%92%8C%E5%94%AF%E4%B8%80%E7%9F%A5%E9%81%93%E8%84%86%E5%8F%B8%E4%BB%A4%E4%B8%BA%E4%BB%80%E4%B9%88%E8%84%86%E7%9A%84%E4%BA%BA%E6%95%A3%E6%AD%A5/</url><categories><category>程序员的日常</category></categories><tags><tag>一维码</tag><tag>EAN13</tag><tag>编码</tag></tags><content type="html"> 今天干点啥子？ 这周在看一本计算机基础的书，书中介绍二进制数字系统的时候举了一个例子是关于”通用产品代码(Universal Product Code，UPC)“，也就是我们超市、便利店那些商品上常见的一维码。于是，就有了今天这个“和唯一知道脆司令为什么脆的人散步”的故事。
我们今天的任务是，将早上吃完的脆司令(英文名叫Crispy commander，不叫cui si ling)包装袋上的条形码通过人工的方式进行解码，还原其所表达的实际数值。
提前准备一下资料 与常见的其他行业一样，我们的标准都在继承了拿来主义的指导原则之后，又保持了中国社会主义的特色。所以，尽管在看书的时候作者介绍了UPC的编码标准，我们还得看一下我们的国标，关于定义零售商品编码与条码需要参考的标准主要是**《GB 12904-2008》**，可以从这里下载。国标很简单明了的规定了编码的规则、表示、设计、放置和质量要求，用来支持完成我们今天的任务绰绰有余啦。
咱也分步行动？ 解码比把大象装进冰箱里还简单，一共分两步，取码—>解码就是了。
呸！我们正经一点，必须分3步：
确定商品的编码规则，熟悉该规则(这里是EAN13)； 人工读取包装袋上的条形码表示的二进制串内容J(这里借助excel表来完成)； 根据规则，解码； 解释一下咱们的步骤哈 EAN13的规则如下，其中每个蓝色框代表1个有效字符。根据该规则，我们可以可以解析出一共有11个有效字符，再加上1个校验符号，我们就可以得到12个数值。但是为什么叫EAN13呢？不识数吗？别急别急，这里有一个隐藏字符即后面要用到的前置符，是需要通过校验符和数据符来推倒导。前置符确定了二进制码到数值的转换关系。
人工读取包装带上的条形码，这一步不展示，不会读的多读几遍，读到会为止；
接下来，我们需要推导前置码，我哪会推导呀，大家可以参考一维条形码识别的整个过程原理通俗易懂讲解一文掌握推导前置码；
根据前置码，确定数据段与A、B和C子集中的对应关系，在《国标》中描述“左侧数据符 EAN/UPC 条码字符集的选用规则”，根据下表和前置码即可确定我们当前使用的二进制串和数值的对应关系；
有了对应关系，我们再根据*”表3 EAN/UPC 条码字符集的二进制表“*，人工解码出二进制串代表的数值；
如果成功的话，会得到与二进制码下方一致的数字串，也就完成了今天的任务。
开始分析啦 上脆司令，我从垃圾袋里捡出吃完的脆司令，放在我死贵的电动升降桌上拍了张图，如下；
发到电脑，截图，截取其中一行；
新建excel作为度量尺，每一列的宽度等于EAN13码的0/1的宽度，然后对照图片读出数值；
复制出来原始数值：
10100010110011011010011101100110110111000101101010111001011100101011100110110011101001110010101 EAN13编码规则如下：
我们将读出来的数据填入规则，通过其中的中间分隔符，可以看出来，数据没有错位(不代表数据没读错哦)；
根据分步行动指南中描述，这里需要根据前置码数值来确定具体的子集对应关系，关于前置码的确认方法，可以参考一维条形码识别的整个过程原理通俗易懂讲解一文，得到我们这里的前置码为6，我们现在就可以确定EAN13 左侧数据符商品条码字符集为如下。另《国标》规定，其余右侧数据符及校验符均用 C 子集表示；
接下来，我们就可以根据”表3 EAN/UPC 条码字符集的二进制表“对我们读到的二进制字符串进行解码，得到实际对应的数值共12位；
920 189 004 290 到这里我们就解码成功，这个编码包含了厂商识别代码、商品项目代码和校验码，可以定位每一类商品。和我预想的不一样的是，*相同的商品分配相同的商品代码, 基本特征相同的商品视为相同的商品。*于是，我迅速拿来了另一袋脆司令，没吃，拍了照。</content></entry><entry><title>在Ubuntu上交叉编译gdb和gdbserver</title><url>https://mdxz2048.github.io/post/study_programmer_cross_compile_for_gdb_on_ubuntu20/</url><categories><category>程序员的日常</category></categories><tags><tag>gdb交叉编译</tag></tags><content type="html"> 实验环境 开发主机：Ubuntu虚拟机x86_64 目标设备：imx8开发板Linux 准备工作 为了解决在gdb编译过程中出现的configure: error: GMP is missing or unusable错误，我们在编译gdb之前交叉编译一下gmp。
当然，如果交叉编译工具链下有gmp库和gmp.h的话，可以忽略掉这里的准备工作。
下载源码gmp-6.2.1.tar.xz；
执行指令tar xvf gmp-6.2.1.tar.xz，解压然后进入文件夹cd gmp-6.2.1；
根据开发环境的配置方法，导出交叉编译工具链到当前环境变量，我们这里演示设备操作如下：
source /opt/fslc-framebuffer/2.4.4/environment-setup-armv7at2hf-neon-fslc-linux-gnueabi 执行arm-fslc-linux-gnueabi-gcc -v查看开发主机类型和目标设备类型。比如我们这里的host和build是--build=x86_64-linux和 --host=x86_64-fslcsdk-linux；
COLLECT_GCC=arm-fslc-linux-gnueabi-gcc COLLECT_LTO_WRAPPER=/opt/fslc-framebuffer/2.4.4/sysroots/x86_64-fslcsdk-linux/usr/libexec/arm-fslc-linux-gnueabi/gcc/arm-fslc-linux-gnueabi/7.3.0/lto-wrapper Target: arm-fslc-linux-gnueabi Configured with: ../../../../../../work-shared/gcc-7.3.0-r0/gcc-7.3.0/configure --build=x86_64-linux --host=x86_64-fslcsdk-linux --target=arm-fslc-linux-gnueabi ...... 执行如下指令，根据当前设备和目标设备进行配置；
./configure --host=arm-fslc-linux-gnueabi --build=x86_64-linux --prefix=/home/caeri/lzp/GIT/arm_gmp host指目标设备的类型； build指构建设备，也就是我们开发主机的类型； prefix指编译的安装目录； 配置完成后，效果如下；
config.status: linking mpn/arm/gmp-mparam.h to gmp-mparam.h config.status: executing libtool commands configure: summary of build options: Version: GNU MP 6.2.1 Host type: arm-fslc-linux-gnueabi ABI: 32 Install prefix: /home/caeri/lzp/GIT/arm_gmp Compiler: arm-fslc-linux-gnueabi-gcc -march=armv7-a -mthumb -mfpu=neon -mfloat-abi=hard --sysroot=/opt/fslc-framebuffer/2.4.4/sysroots/armv7at2hf-neon-fslc-linux-gnueabi Static libraries: yes Shared libraries: yes 执行make进行编译,编译完成后，结果如下：
root@ubuntu:/home/caeri/lzp/GIT/gmp/gmp-6.2.1# make s.o rand/rands.o rand/randsd.o rand/randsdui.o rand/randbui.o rand/randmui.o libtool: link: arm-fslc-linux-gnueabi-ranlib .libs/libgmp.a libtool: link: rm -fr .libs/libgmp.lax libtool: link: ( cd ".libs" &amp;&amp; rm -f "libgmp.la" &amp;&amp; ln -s "../libgmp.la" "libgmp.la" ) make[2]: Leaving directory '/home/caeri/lzp/GIT/gmp/gmp-6.2.1' make[1]: Leaving directory '/home/caeri/lzp/GIT/gmp/gmp-6.2.1' 执行make install安装到我们指的的安装目录；
root@ubuntu:/home/caeri/lzp/GIT/gmp/gmp-6.2.1# make install 最后，安装完成后，我们可以在指定的安装目录查看安装结果,这里包含了gmp.h和相关库；
root@ubuntu:/home/caeri/lzp/GIT/arm_gmp# ls include lib share 到这里，gmp就编译完了，我们在编译gdb的时候依赖这里的文件。
交叉编译 在这里下载源码到Ubuntu，我们选择当前比较新的版本gdb-12.1.tar.gz；
执行tar xvf gdb-12.1.tar.gz解压到当前文件夹；
根据开发环境的配置方法，导出交叉编译工具链到当前环境变量，我们这里演示设备操作如下：
source /opt/fslc-framebuffer/2.4.4/environment-setup-armv7at2hf-neon-fslc-linux-gnueabi 执行arm-fslc-linux-gnueabi-gcc -v查看开发主机类型和目标设备类型，以在配置gdb编译过程的时候使用这些参数,比如我们这里的host和build是--build=x86_64-linux和 --host=x86_64-fslcsdk-linux；
加载配置，这里我们引用了准备工作中编译的gmp库的路径，大家编译的时候要替换成自己的环境；
./configure --prefix=/home/caeri/lzp/GIT/arm-gdb --host=arm-fslc-linux-gnueabi --build=x86_64-linux CFLAGS="-I/home/caeri/lzp/GIT/arm_gmp/include -L/home/caeri/lzp/GIT/arm_gmp/lib" CXXFLAGS="-I/home/caeri/lzp/GIT/arm_gmp/include -L/home/caeri/lzp/GIT/arm_gmp/lib" 配置加载完成后，执行make开始编译，这个编译过程可能会耗费5-10分钟~~(设备太慢)~~,很遗憾太激动了没有截图；
root@ubuntu:/home/caeri/lzp/DC/gdb/gdb-12.1# make 这里如果出现了configure: error: GMP is missing or unusable这个错误，请按照准备工作中，老老实实的编译一遍，再仔细检查上一步configure路径是否配置正确；
编译完成后，如果没有报错，进入gdbserver文件夹：
root@ubuntu:/home/caeri/lzp/DC/gdb/gdb-12.1# cd gdbserver 这次，我把gdbserver的安装目录放在了/home/caeri/lzp/GIT/arm-gdbserver，配置如下：
./configure --prefix=/home/caeri/lzp/GIT/arm-gdbserver --host=arm-fslc-linux-gnueabi --build=x86_64-linux 然后在目录/home/caeri/lzp/DC/gdb/gdb-12.1/gdbserver下，依次执行make、make install,编译安装；
root@ubuntu:/home/caeri/lzp/DC/gdb/gdb-12.1/gdbserver# make GEN version-generated.cc CXX version.o CXXLD gdbserver CXXLD gdbreplay root@ubuntu:/home/caeri/lzp/DC/gdb/gdb-12.1/gdbserver# make install make[1]: Entering directory '/home/caeri/lzp/DC/gdb/gdb-12.1/gdbserver' n=`echo gdbserver | sed 's,x,x,'`; \ if [ x$n = x ]; then n=gdbserver; else true; fi; \ if [ x"" != x ]; then \ /bin/bash ./../mkinstalldirs /home/caeri/lzp/GIT/arm-gdbserver/lib; \ /usr/bin/install -c libinproctrace.so /home/caeri/lzp/GIT/arm-gdbserver/lib/libinproctrace.so; \ fi; \ /bin/bash ./../mkinstalldirs /home/caeri/lzp/GIT/arm-gdbserver/bin; \ /usr/bin/install -c gdbserver /home/caeri/lzp/GIT/arm-gdbserver/bin/$n mkdir -p -- /home/caeri/lzp/GIT/arm-gdbserver/bin make[1]: Leaving directory '/home/caeri/lzp/DC/gdb/gdb-12.1/gdbserver' 最后，如果操作成功，我们可以在/home/caeri/lzp/DC/gdb/gdb-12.1/gdbserver下看到我们编译出的gdbserver应用，可以在开发板上运行。
./gdbserver Usage: gdbserver [OPTIONS] COMM PROG [ARGS ...] gdbserver [OPTIONS] --attach COMM PID gdbserver [OPTIONS] --multi COMM COMM may either be a tty device (for serial debugging), 至此，交叉编译工作完成。</content></entry><entry><title>自上而下理解内核网络(四)---sock与传输层UDP</title><url>https://mdxz2048.github.io/post/study_linux_tcp_in_linux_04/</url><categories><category>Linux内核</category></categories><tags><tag>自上而下理解内核网络</tag></tags><content type="html"> 在上一节我们介绍了内核网络在内核应用层以struct socket结构体的形式进行创建和传递。这一节，我们继续自上而下进行分析。
在进入传输层(UDP/TCP协议栈)之前，内核有一个INET协议族层，定义了struct sock结构体，将传输层的TCP/IP协议栈(struct proto)和应用层struct socket关联起来。
因为TCP协议的复杂性，我们很难在这里简单的在传输层进行分析，分析TCP协议也不是我们这里的重点，我们更关注整个Linux内核网络对数据的逐层处理，因此，我们这一节将在传输层选取UDP相关协议实现进行分析。
本节我们主要有两个任务：
分析传输层的发送流程； 分析传输层的接收流程 sock代替socket 在《深入Linux内核架构》中，作者这样描述了sock层的意义：“尽管尚未讨论sock结构，它不可避免地使人想到术语socket(套接字)，这正是我们想要的，我们现在正处于应用层的边界上，数据迟早要使用套接字传输到用户空间，就像本章开头的示例程序那样。内核中有两种数据结构表示套接字，sock是到网络访问层的接口，而socket是到用户空间的接口”。因为我们这个系列文章是自上而下描述数据的流向，以一个数据socket的建立和数据的发送为起点进行分析，从应用层到底层的对数据进行追踪，而《深入Linux内核架构》网络部分是自下而上的。因此，我们和作者的视角刚好相反，虽然都在应用层的边界，我们是往下看的，先看到的是socket，再是sock。
在从应用层进入传输层时，内核中在net/ipv4/af_inet.c中struct sock结构体来表示上一层的socket，该层向下以sock格式与传输层的TCP/UDP协议连，向上以socket的格式与用户层进行数据传输。这里有一张图可以表示INET在内核中的位置和作用：
从上图可以看到，Linux内核网络的处理主要在协议层和网络设备驱动层，因此关于sock的收发接口我们这里就不做深入研究，这一节的主要内容我们还是直接进入UDP中研究它的发送数据和接收数据。
sock发送接口 int inet_sendmsg(struct socket *sock, struct msghdr *msg, size_t size) { struct sock *sk = sock->sk; sock_rps_record_flow(sk); /* We may need to bind the socket. */ if (!inet_sk(sk)->inet_num &amp;&amp; !sk->sk_prot->no_autobind &amp;&amp; inet_autobind(sk)) return -EAGAIN; return sk->sk_prot->sendmsg(sk, msg, size); } sock接收数据 int inet_recvmsg(struct socket *sock, struct msghdr *msg, size_t size, int flags) { struct sock *sk = sock->sk; int addr_len = 0; int err; sock_rps_record_flow(sk); err = sk->sk_prot->recvmsg(sk, msg, size, flags &amp; MSG_DONTWAIT, flags &amp; ~MSG_DONTWAIT, &amp;addr_len); if (err >= 0) msg->msg_namelen = addr_len; return err; } 传输层之UDP发送 传输层相较于应用层简单的数据检验，功能要复杂很多，我们这里选取相比之下更简单的UDP发送来进行分析。首先，这里接上一节的sendto发送流程图继续向下分析，我们可以得到如下调用图。
通过上图，我们可以看到在从INET协议族层之后，进入了传输层UDP协议层，该层发送入口是udp_sendmsg，这是一个比较长的函数我们接下来分析它，它的源代码位于net/ipv4/udp.c
检查corked 最开始，代码进行一些变量的赋值和flag的基本检查之后，检查了当前up->pending，当这个socket是被阻塞的时候，程序直接goto跳转至末尾的do_append_data处，这个我们稍后分析；
int udp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len) { /* * Check the flags. */ if (msg->msg_flags &amp; MSG_OOB) /* Mirror BSD error message compatibility */ return -EOPNOTSUPP; ipc.opt = NULL; ipc.tx_flags = 0; ipc.ttl = 0; ipc.tos = -1; getfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag; fl4 = &amp;inet->cork.fl.u.ip4; if (up->pending) { /* * There are pending frames. * The socket lock must be held while it's corked. */ lock_sock(sk); if (likely(up->pending)) { if (unlikely(up->pending != AF_INET)) { release_sock(sk); return -EINVAL; } goto do_append_data; } release_sock(sk); } 这里将socket设置成阻塞corked有2个途径：
通过setsockopt系统调用设置socket的UDP_CORK配置项； 在程序中调用send、sendto和sendmsg时，通过设置flags的MSG_MORE选项进行指定； 获取socket目的地址和端口 socket的目的地址可能有2个来源：
socket由于在某个时刻被connect，它本身存储有目的地址和端口； 地址被通过辅助结构体传递，例如我们看到的sendto调用的时候，会进行指定； 接下来，我们看内核中的处理；
/* * Get and verify the address. */ if (msg->msg_name) { DECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name); if (msg->msg_namelen &lt; sizeof(*usin)) return -EINVAL; if (usin->sin_family != AF_INET) { if (usin->sin_family != AF_UNSPEC) return -EAFNOSUPPORT; } daddr = usin->sin_addr.s_addr; dport = usin->sin_port; if (dport == 0) return -EINVAL; } else { if (sk->sk_state != TCP_ESTABLISHED) return -EDESTADDRREQ; daddr = inet->inet_daddr; dport = inet->inet_dport; /* Open fast path for connected socket. Route will not be used, if at least one option is set. */ connected = 1; } 在之前，我们调用sendto接口的时候，内核中填充了一个结构体struct msghdr，这里展示的就是如何解析这个结构体，来获取其中的目的地址和端口；
如果在到达这个函数的时候，内核没有安排一个struct msghdr，也就无法从上一步中解析出地址和端口，我们就进入了else的判断范围，这里UDP协议中有一个TCP_ESTABLISHED，用来描述一个socket的好坏，如果是被连接的socket，这里也可以获取目的地址和端口，并且将connected标志位置为1；
bookkeeping和时间戳 接下来，源地址、设备号、时间戳选项将被设置(SOCK_TIMESTAMPING_TX_HARDWARE, SOCK_TIMESTAMPING_TX_SOFTWARE, SOCK_WIFI_STATUS)。
ipc.sockc.tsflags = sk->sk_tsflags; ipc.addr = inet->inet_saddr; ipc.oif = sk->sk_bound_dev_if; Ancillary messages辅助数据 sendmsg和recvmsg允许用户除了发送和接收packets之外，还可以设置辅助数据；用户可以制作一个struct msghdr结构体，将ancillary data嵌入进去。辅助数据的格式见这里。
一个比较受欢迎的例子是IP_PKTINFO，在这种情况下，sendmsg发送数据的时候允许用户设置struct in_pktinfo，该进程可以通过填写结构in_pktinfo结构中的字段来指定要在数据包上使用的源地址。这对于一个有多个IP的服务端，是一个有用的设计。这样，服务端就可以使用客户端连接的IP进行回复。
类似的，当用户调用了sendmsg发送数据的时候，还可以使用IP_TTL和IP_TOS来设置每一包数据的TTL和TOS，请注意，可以使用 setsockopt 在所有传出数据包的套接字级别设置IP_TTL和IP_TOS，而不是根据需要按数据包进行设置。Linux内核通过一个数组将TOS转换为优先级；优先级影响了数据从排队队列被发送的时间和方式。
我们可以看到这里UDP协议处理辅助数据：
if (msg->msg_controllen) { err = ip_cmsg_send(sk, msg, &amp;ipc, sk->sk_family == AF_INET6); if (unlikely(err)) { kfree(ipc.opt); return err; } if (ipc.opt) free = 1; connected = 0; } 内核中通过ip_cmsg_send来解析ancillary message，源代码在这里。
这里只要提供了辅助数据，就要把connected标记为未连接0.
自定义IP选项 接下来，sendmsg将检查用户是否通过辅助数据(Ancillary messages)指定了IP选项。如果选项被设置，则被使用。否则，使用socket中已经存在的选项；
if (!ipc.opt) { struct ip_options_rcu *inet_opt; rcu_read_lock(); inet_opt = rcu_dereference(inet->inet_opt); if (inet_opt) { memcpy(&amp;opt_copy, inet_opt, sizeof(*inet_opt) + inet_opt->opt.optlen); ipc.opt = &amp;opt_copy.opt; } rcu_read_unlock(); } 检查源路由记录，有2个源路由记录的类型：LSR和SSR如果设置了此选项，则第一个跃点地址将被记录并存储为 faddr，并且套接字将标记为“未连接”；
if (ipc.opt &amp;&amp; ipc.opt->opt.srr) { if (!daddr) return -EINVAL; faddr = ipc.opt->opt.faddr; connected = 0; } 处理 SRR 选项后，将从用户通过辅助消息设置的值或套接字当前正在使用的值中检索 TOS IP 标志。后跟检查:
SO_DONTROUTE标准，setsockopt来设置，或者 MSG_DONTROUTE被设置，当使用sendto和sendmsg时或者 is_strictroute被设置，表示需要严格的源记录路由； 然后，tos的标志位0x1 (RTO_ONLINK)被设置，connected被标志为未连接；
tos = get_rttos(&amp;ipc, inet); if (sock_flag(sk, SOCK_LOCALROUTE) || (msg->msg_flags &amp; MSG_DONTROUTE) || (ipc.opt &amp;&amp; ipc.opt->opt.is_strictroute)) { tos |= RTO_ONLINK; connected = 0; } 多播还是单拨？ 接下来，代码试图处理多播(组播)。这是一个棘手的问题，因为用户可以通过发送辅助IP_PKTINFO消息来指定从何处发送数据包的备用源地址或设备索引，如前所述。
如果目的地址是组播地址。
写入packet的设备索引将被设置为组播设备索引； packet上的源地址将被设置为组播源地址。 如果用户没有通过IP_PKTINFO来覆盖索引，则是如下处理：
if (ipv4_is_multicast(daddr)) { if (!ipc.oif) ipc.oif = inet->mc_index; if (!saddr) saddr = inet->mc_addr; connected = 0; } else if (!ipc.oif) ipc.oif = inet->uc_index; 如果不是组播，则直接设置用户索引inet->uc_index。除非用户使用IP_PKTINFO来指定。
路由 如果socket的connected状态是连接的1，则使用一个快的路径来获取路由结构体。
if (connected) rt = (struct rtable *)sk_dst_check(sk, 0); 如果套接字未连接，或者sk_dst_check检查确定路由已过时，则划入一个慢的路径生成一个新的路由结构。通过调用flowi4_init_output来为这个UDP流构建一个结构体。
if (!rt) { struct net *net = sock_net(sk); __u8 flow_flags = inet_sk_flowi_flags(sk); fl4 = &amp;fl4_stack; flowi4_init_output(fl4, ipc.oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE, sk->sk_protocol, flow_flags, faddr, saddr, dport, inet->inet_sport); 构建此流结构后，套接字及其流结构将传递到安全子系统，以便 SELinux 或 SMACK 等系统可以在流结构上设置安全 ID 值。接下来，ip_route_output_flow将调用 IP 路由代码，为此流生成路由结构：
security_sk_classify_flow(sk, flowi4_to_flowi(fl4)); rt = ip_route_output_flow(net, fl4, sk); if (IS_ERR(rt)) { err = PTR_ERR(rt); rt = NULL; if (err == -ENETUNREACH) IP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES); goto out; } 在下来这个位置，保存统计计数器和其他计数器。其含义将在下面UDP监视部分讨论。
接下来，如果路由被设置为广播，但是socket的SOCK_BROADCAST选项没有被设置，则代码终止。如果socket被认为是“connected”的，则将路由结构缓存下来。
err = -EACCES; if ((rt->rt_flags &amp; RTCF_BROADCAST) &amp;&amp; !sock_flag(sk, SOCK_BROADCAST)) goto out; if (connected) sk_dst_set(sk, dst_clone(&amp;rt->dst)); 防止ARP缓存引起的MSG_CONFIRM过时 如果用户调用send、sendto或者sendmsg的时候，指定了MSG_CONFIRM标志，协议层将进行处理：
if (msg->msg_flags&amp;MSG_CONFIRM) goto do_confirm; back_from_confirm: 这个标志指示系统验证ARP是否有效，并防止对其进行垃圾回收。dst_confirm函数只是在目标缓存条目上设置一个标志，当查询相邻缓存并找到条目时，将在很久以后检查该标志。我们稍后会再次看到这一点。此功能通常用于 UDP 网络应用进程，以减少不必要的 ARP 流量。do_confirm标签位于此函数的末尾附近，但它很简单：
do_confirm: dst_confirm(&amp;rt->dst); if (!(msg->msg_flags&amp;MSG_PROBE) || len) goto back_from_confirm; err = 0; goto out; 如果不是probe，验证完cache的条目后，返回back_from_confirm；
一旦do_confirm返回到back_from_confirm，开始处理UDP corked的问题。
uncorked UDP sockets快速路径：准备传输数据 如果UDP未请求corked，数据可以被打包到struct sk_buff，然后通过udp_send_skb发送到IP协议层。这是通过调用ip_make_skb来完成的。
通过ip_route_output_flow生成的路由结构也会被传入，它将附着在skb中，之后在IP协议层使用。
/* Lockless fast path for the non-corking case. */ if (!corkreq) { skb = ip_make_skb(sk, fl4, getfrag, msg, ulen, sizeof(struct udphdr), &amp;ipc, &amp;rt, msg->msg_flags); err = PTR_ERR(skb); if (!IS_ERR_OR_NULL(skb)) err = udp_send_skb(skb, fl4); goto out; } ip_make_skb函数将尝试构建一个skb，同时考虑到广泛的因素，例如：
MTU UDP corking (if enabled) UDP Fragmentation Offloading (UFO) 分包传输，如果UFO不受支持并且要传输的数据的大小大于MTU。 传输数据 如果没有发生错误，udp_send_skb来处理skb，将数据传入到协议栈的下一层，也就是IP协议栈。
如果发生了 错误，错误将被记录，这里我们没有深入研究。
err = PTR_ERR(skb); if (!IS_ERR_OR_NULL(skb)) err = udp_send_skb(skb, fl4); corkingUDP sockets慢速路径 如果UDP socket被corked，同时先前数据没有被阻塞住，慢速路径开启：
LOCK这个socket； 检查应用错误bug：一个已经corked的socket被重复corked； cork the socket pend data lock_sock(sk); if (unlikely(up->pending)) { /* The socket is already corked while preparing it. */ /* ... which is an evident application bug. --ANK */ release_sock(sk); net_dbg_ratelimited("cork app bug 2\n"); err = -EINVAL; goto out; } /* * Now cork the socket to pend data. */ fl4 = &amp;inet->cork.fl.u.ip4; fl4->daddr = daddr; fl4->saddr = saddr; fl4->fl4_dport = dport; fl4->fl4_sport = inet->inet_sport; up->pending = AF_INET; do_append_data: up->len += ulen; err = ip_append_data(sk, fl4, getfrag, msg, ulen, sizeof(struct udphdr), &amp;ipc, &amp;rt, corkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags); if (err) udp_flush_pending_frames(sk); else if (!corkreq) err = udp_push_pending_frames(sk); else if (unlikely(skb_queue_empty(&amp;sk->sk_write_queue))) up->pending = 0; release_sock(sk); 传输层之UDP接收 在UDP层接收之前数据大致的流向如下：
udp_rcv udp_rcv的实现是在udp.c；
这里只有简单一行去调用__udp4_lib_rcv；
__udp4_lib_rcv __udp4_lib_rcv函数检查packet是否有效，然后获取UDP头、UDP数据报文长度、源地址和目的地址。接下来，会进行完整性检查和数据的校验。
在IP协议层，数据报文被优化，加上了dst_entry数据然后传递到了UDP协议层。
如果一个socket的dst_entry被找到，则__udp4_lib_rcv 将排队UDP数据包到socket；
sk = skb_steal_sock(skb); if (sk) { struct dst_entry *dst = skb_dst(skb); int ret; if (unlikely(sk->sk_rx_dst != dst)) udp_sk_rx_dst_set(sk, dst); ret = udp_queue_rcv_skb(sk, skb); sock_put(sk); /* a return value > 0 means to resubmit the input, but * it wants the return to be -protocol, or 0 */ if (ret > 0) return -ret; return 0; } 如果没有从early_demux操作连接套接字，则现在将通过调用__udp4_lib_lookup_skb来查找接收套接字。
if (rt->rt_flags &amp; (RTCF_BROADCAST|RTCF_MULTICAST)) return __udp4_lib_mcast_deliver(net, skb, uh, saddr, daddr, udptable, proto); sk = __udp4_lib_lookup_skb(skb, uh->source, uh->dest, udptable); if (sk) { int ret; if (inet_get_convert_csum(sk) &amp;&amp; uh->check &amp;&amp; !IS_UDPLITE(sk)) skb_checksum_try_convert(skb, IPPROTO_UDP, uh->check, inet_compute_pseudo); ret = udp_queue_rcv_skb(sk, skb); /* a return value > 0 means to resubmit the input, but * it wants the return to be -protocol, or 0 */ if (ret > 0) return -ret; return 0; } 在上述两种情况下，数据包都将被排队到socket；
ret = udp_queue_rcv_skb(sk, skb); sock_put(sk); 如果socket没有匹配上，或者校验和错误，则丢弃当前packet；
/* No socket. Drop packet silently, if checksum is wrong */ if (udp_lib_checksum_complete(skb)) goto csum_error; __UDP_INC_STATS(net, UDP_MIB_NOPORTS, proto == IPPROTO_UDPLITE); icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0); udp_queue_rcv_skb 此函数初始化部分如下所示：
确定该数据包关联的套接字是否为封装套接字，如果是，将数据传递到该层的处理函数； 确定该数据包是否是UDP-Lite数据，然后做完整的检查； 验证数据校验和，如果验证失败，则丢弃； 最后，我们到达接收队列逻辑，该逻辑首先检查套接字的接收队列是否已满。/net/ipv4/udp.c
if (sk_rcvqueues_full(sk, sk->sk_rcvbuf)) { __UDP_INC_STATS(sock_net(sk), UDP_MIB_RCVBUFERRORS, is_udplite); goto drop; } sk_rcvqueues_full sk_rcvqueues_full函数的功能是检查socket积压的数据长度，socket的sk_rmem_alloc来确定总长度是否超过sk_rcvbuf(就是上边代码片段的sk->sk_rcvbuf)。
/* * Take into account size of receive queue and backlog queue * Do not take into account this skb truesize, * to allow even a single big packet to come. */ static inline bool sk_rcvqueues_full(const struct sock *sk, unsigned int limit) { unsigned int qsize = sk->sk_backlog.len + atomic_read(&amp;sk->sk_rmem_alloc); return qsize > limit; } udp_queue_rcv_skb 现在已经验证了数据没有接收满，在这里继续处理数据报文。
bh_lock_sock(sk); if (!sock_owned_by_user(sk)) rc = __udp_queue_rcv_skb(sk, skb); else if (sk_add_backlog(sk, skb, sk->sk_rcvbuf)) { bh_unlock_sock(sk); goto drop; } bh_unlock_sock(sk); return rc; 这里第一步先确定socket是否有来自用户空间的系统调：
如果没有，则通过调用__udp_queue_rcv_skb加入到接收队列； 如果有，调用sk_add_backlog先暂存数据； 函数__udp_queue_rcv_skb调用__sock_queue_rcv_skb增加数据包到接收队列，如果无法将数据报添加到套接字的接收队列中，则碰撞统计信息计数器。
int __udp_queue_rcv_skb(struct sock *sk, struct sk_buff *skb) { int rc; if (inet_sk(sk)->inet_daddr) { sock_rps_save_rxhash(sk, skb); sk_mark_napi_id(sk, skb); sk_incoming_cpu_update(sk); } rc = __sock_queue_rcv_skb(sk, skb); if (rc &lt; 0) { int is_udplite = IS_UDPLITE(sk); /* Note that an ENOMEM error is charged twice */ if (rc == -ENOMEM) UDP_INC_STATS(sock_net(sk), UDP_MIB_RCVBUFERRORS, is_udplite); UDP_INC_STATS(sock_net(sk), UDP_MIB_INERRORS, is_udplite); kfree_skb(skb); trace_udp_fail_queue_rcv_skb(rc, sk); return -1; } return 0; } 网络数据通过 sock_queue_rcv 进入 socket 的接收队列。这个函数在将数据报最终送到接收队列之前，会做几件事情：
检查 socket 已分配的内存，如果超过了 receive buffer 的大小，丢弃这个包并更新计数； 等待通过套接字交付数据的进程，在sk_sleep等待队列上睡眠； 调用__skb_queue_tail 将包含分组数据的的套接字缓冲区插入到sk_receive_queue链表末端，其表头保存在特定于套接字的sock结构中； 调用sk_data_ready指向的函数(如果用标准函数sock_init_data来初始化sock实例，通常是sock_def_readable)，通知套接字有新数据到达。这会唤醒在sk_sleep队列上睡眠、等待数据到达的所有进程。 最后，所有在这个 socket 上等待数据的进程都收到一个通知，通过 sk_data_ready 通知处理函数
【参考文献】：
Monitoring and Tuning the Linux Networking Stack: Sending Data Monitoring and Tuning the Linux Networking Stack: Receiving Data LINUX内核网络中数据报在协议层的处理 Professional linux kernel architecture. (2010). 深入Linux内核架构. 人民邮电出版社.</content></entry><entry><title>在Linux上安装ResilioSync</title><url>https://mdxz2048.github.io/post/installresiliosynconlinux/</url><categories><category>工具教程</category></categories><tags><tag>ResilioSync</tag><tag>文件同步</tag></tags><content type="html"> 本文主要介绍如何在Linux上安装ResilioSync。
我日常主要使用3台Windows电脑。3台都安装ResilioSync软件，用来同步特定的文件夹。目前的主要问题是，需要其中至少有1台电脑保持开机并联网，才可以在另外一台电脑上同步之前的文件。因此，决定将树莓派装上ResilioSync软件，加入到我这个P2P网络中来，作为那个一直开机的设备。
准备工作 树莓派3B+ SD卡8GB+ SD卡烧录器 其他 使用说明 树莓派系统安装 这里我使用的Linux发行版本是Ubuntu Server 20.04.4 LTS。 使用balenaEtcher或者其他烧录软件将下载的系统镜像解压到SD卡中，这里网上教程很多，大家不清楚的可以搜一下； 部署ResilioSync 下载安装 在这里下载的版本是armhf架构 ResilioSync；
执行如下指令进行安装，安装是自动完成，这里等待即可；
sudo dpkg -i resilio-sync_2.7.2.1375-1_arm64.deb 配置激活 这里使用网页(树莓派IP:8888/gui)进行配置，首次进入时会提示需要设置一个网页登陆的账号、密码，这里根据需要设置即可；
我这里配置完成后，进入网页长这样；
配置完成后，我们把对应的License文件存放到设备上，加入我这里放在目录 /home/ubuntu/rs/ResilioSyncPro.btskey;
回到网页，在右上角点击 Preference，进入 License页面，点击 Apply License,将存放license的文件添加进来；
License激活完成后，界面长这样；
接下来就可以像在客户端上一样，在网页开始同步文件了；</content></entry><entry><title>设备间文件自动同步软件---Reaillio</title><url>https://mdxz2048.github.io/post/soft_win_reaillio/</url><categories><category>软件分享</category></categories><tags><tag>文件同步</tag></tags><content type="html"> 软件名称 Resilio Sync 网址：https://www.resilio.com/individuals/
功能介绍 Resilio Sync是一款电脑间自动同步文件夹的软件。
支持局域网同步，同时支持跨网络同步 不需要第三方服务器，几乎不受存储空间和流量限制 支持多人同时同步(越多人对文件夹进行同步，则同步速度越快) 数据私有/安全性，因为数据不在云端，而是存储在本地 首页展示 使用说明 安装 前往官网下载对应平台版本(支持win、Linux、mac)，Windows版本点击这里；
下载完成后，点击安装即可，只需要在这里填写计算机名称，以便在2台计算机之间同步时快速识别；
[image.png(https://inews.gtimg.com/newsapp_ls/0/14526417392/0.jiketuchuang.png)
点击入门后即可进入软件，点击左上角➕选择对应文件夹开始共享，随即会在主界面出现共享按钮；
主机点击共享后，会弹出如下界面，复制链接在另一台安装了Resilio Sync软件的电脑上打开即可自动同步；
到这儿，就完成了两台设备之间的文件夹自动同步。
pro版本的激活下载链接。</content></entry><entry><title>pdf格式文档在线转换</title><url>https://mdxz2048.github.io/post/soft_web_ilovepdf/</url><categories><category>软件分享</category></categories><tags><tag>PDF转换</tag></tags><content type="html"> 软件名称 ilovepdf是一个免费的PDF在线转换网站。
同时可提供付费的OCR(光学字符识别 )服务。
网址：https://www.ilovepdf.com
中文：https://www.ilovepdf.com/zh-cn
功能介绍 合并PDF
拆分PDF
压缩PDF
PDF格式转换为 Word、PPT、Excel格式，其中OCR功能为付费功能
Word、PPT、Excel转换至PDF
PDF加密、解锁、修复、签名等功能
首页展示 使用说明 在线工具的使用往往都比较简单直接，这里以一篇PDF格式的论文转换为Word文档为例，演示网站的使用。
注意：在PDF格式转换为其他格式时，如果PDF格式的文档是类似于**拍照/扫描出的PDF格式，一般需要用到OCR识别技术，即通过算法识别文本内容，类似于锤子的大爆炸，或者IOS15新推出的相机文字识别**技术。
在首页点击[PDF to Word]
在弹出的页面点击[Select PDF file]，选择一个PDF文件，例如我这里选择了之前下载的一篇论文《基于BDS的RTK模式定位精度分析_杨泰朋》。
这里我不需要OCR，选择[NO OCR]，然后点击[Convert to WORD]按钮即可。 转换完成后，会弹出下载按钮，点击[Download WORD]即可。</content></entry><entry><title>谷歌搜索镜像网站</title><url>https://mdxz2048.github.io/post/soft_web_googlemirrorsites/</url><categories><category>软件分享</category></categories><tags><tag>谷歌搜索</tag></tags><content type="html"> 软件介绍 分享一个由浙江大学维护的Google搜索的公益镜像网站，供大家在网络不佳的情况下使用，有条件的同学就不要使用镜像网站了，自己直接访问即可。
Google搜索的优势和一些常用搜索技巧在我之前的一篇《学会使用高级搜索命令，提高搜索引擎使用效率》教程中有过介绍，我自己一般会使用Google和Bing两个搜索引擎，一般只有在网络不佳的情况下使用Bing。
使用方法 浏览器输入地址:https://g.luciaz.me/
这时候会有一个验证页面，验证你是否来自浙江大学，这里三个问题的答案分别是：
心灵之约、水朝夕、csxy@123
填入任何一个问题的答案，点击提交，会自动跳转至搜索页面。直接使用即可：</content></entry><entry><title>如何安装正版的WIN10</title><url>https://mdxz2048.github.io/post/installgenuinewin10/</url><categories><category>工具教程</category></categories><tags><tag>Windows10</tag></tags><content type="html"> 声明 本文档首发在我的个人公众号。
文档说明 以联想威6pro为例，使用微软官方工具，安装正版Windows10操作系统。
工具说明 U盘(8GB及以上、会被格式化) Windows电脑(可以上网) 使用说明 本次安装主要分为三个步骤
这一步由工具自动完成，通过下载微软的官方工具，将U盘制作成启动盘并下载win10进U盘； 插上U盘到待安装系统的笔记本(或主机)，进入BIOS将其设置为使用U盘启动； 等待自动安装(需要至少20分钟)； 注册激活，注意安装时不分是家庭版、专业版还是企业版，由最后安装完成后的激活码决定。 教程 将U盘插入可以上网的Windows电脑，打开资源管理器(win+E)查看盘符，检查是否插入，如下图，我这里是盘符是****I。 打开浏览器，进入win10的下载界面(https://www.microsoft.com/zh-cn/software-download/windows10)，点击立即下载工具，下载完成后，打开工具。点击接受/同意协议，出现如下界面时，选择为另一台电脑创建安装介质(U盘、DVD或ISO文件)，点击下一步。 在选择版本这里保持默认即可，点击下一步。需要安装其他版本的windows10，取消下图中红框的勾选即可选择。 选择介质，意思就是想用什么来装系统，我们这里当然选择U盘，然后下一步。 选择U盘，这里可以看到你电脑上插入的所有U盘，务必选择你要用来装系统的那个U盘。这个****U盘会被格式化，文件要提前备份好。确认好就可以点击下一步啦。 接下来就软件就会自动运行，会自动制作启动盘、下载windows10到系统。这个过程比较慢，基本上需要多等个1、2个小时，主要看网速和微软服务器给不给力了。 待安装系统的电脑完全关机，将U盘插入。 这里需要将电脑设置成从U盘启动，因为你启动了要让这个U盘给你装系统，所以需要一点设置。我们是通过设置电脑的BIOS，让系统启动后从U盘加载。这里我们以联想威6pro为例，给大家演示如果查看自己的电脑设置U盘启动 查看自己的电脑型号，这个通过电脑上的标签、查看之前买的订单基本都可以找得到。然后我查到公司这台笔记本是联想的威6pro，除了长得丑点外观也还可以； **找到电脑型号后，用搜索引擎(Google搜索、百度一下这种就叫搜索引擎)搜“**电脑型号+如何设置U盘启动”，然后在搜索结果中的方法中尝试一下，一般就可以找到答案，如果找不到，就先查怎么进入BIOS，然后进入后看下一步教程。一般情况同一品牌(实际是同一主板)进入BISO方法都是一样的，所有的BIOS也大同小异(因为会写这个软件的工程师比较少、太底层了)。 一般设置方法分3步： 进入BIOS，比如我这台电脑就是开机按住Fn+F2；
关闭安全启动；
选择U盘启动(注意这里需要插上U盘)，然后保存并退出。
退出BIOS后电脑会自己进入U盘启动。这里我们只需要按确定/下一步就好啦，能到这里，基本上系统安装已经成功了一半了，接下来就可以喝杯水休息一下。 等待安装完成后，购买密钥激活即可。
至此，正版的Windows10系统安装完成。</content></entry><entry><title>IOS设备使用系统自带Airplay投屏到电脑</title><url>https://mdxz2048.github.io/post/soft_win_deeprd/</url><categories><category>软件分享</category></categories><tags><tag>投屏</tag></tags><content type="html"> 软件 蓝莓投屏
介绍 iOS和MacOS里, 使用Airplay协议, 无需安装软件, 直接镜像投屏. 安卓和Windows安装蓝莓研发的投屏发送端, 可用投屏码 一键投屏到对应接收端. 支持同时镜像电脑屏幕到多个接收端, 接收端也可以同时显示多路屏幕, 即支持一投多和多投一, 适合会议办公, PPT演示
本次主要介绍IOS设备投屏到电脑，安卓设备和win10系统使用系统自带无线显示可完成投屏。
软件下载 官网下载：http://deeprd.com
或公众号后台回复：“手机投屏”获取软件安装包
使用教程 打开获取到的软件安装包，解压安装包，效果如图所示。 双击“Blueberry-Airplay.exe”，软件会自动运行。此时可以在状态栏看到软件，效果如图所示。 保证IOS设备和PC机处于同一局域网下(连接同一WiFi)
打开IOS设备屏幕镜像，可以看到PC机，iPhone投屏后效果如图。
ipad投屏后效果如图。</content></entry><entry><title>GitHub+hexo搭建个人博客</title><url>https://mdxz2048.github.io/post/build-blog-with-hexo/</url><categories><category>工具教程</category></categories><tags><tag>hexo</tag><tag>搭建博客</tag></tags><content type="html"> 声明 本内容非原创，主要参考该博客进行验证 http://dwz.date/buw2dwz.date
感谢GitHub提供的开源服务。 感谢Hexo提供的方案。官网： https://hexo.io/hexo.io
介绍 今天介绍使用GitHub+hexo博客框架搭建个人博客的方案。优点是****完全免费、自由，缺点是只能使用静态页面展示，使用评论、上传图片其他功能时需要配合其他插件服务使用。
参考本教程，大约需要半个小时来完成安装和使用。其他高级操作需读者自行搜索教程学习。
安装Node.s和Git终端 安装Node.js，如图下载LTS版本安装包进行下载，然后像正常安装软件一样进行安装即可。下载地址https://nodejs.org/en/ **安装成功后，如图，在windows终端下输入如下指令查看是否安装成功，如下出现版本号即安装成功。**搜索cmd(命令提示符)可进入windows终端。  node -v 安装git，点击gitWindows客户端进行下载，下载完成后像安装正常软件一样进行安装即可。 如果没有GitHub账号，请查看此教程进行注册。注册GitHub账号 创建Github Pages(博客存放仓库) 打开浏览器，进入GitHub官网，登录自己的账号。 点击头像，查看自己的****username，我的用户名为mdxz2048 点击右上角加号，在下拉选项中选择****New repository创建博客仓库。 在弹出的设置页面Repository name处填写****yourusername.github.io，然后其他配置保持默认，点击Create repository。例如我的用户名为mdxz2048，就填mdxz2048.github.io。 接下来GitHub会将该仓库设为Github Pages，以后访问该域名就可以访问到该仓库的内容，我们要搭建的博客随后会被放在这里。 配置GitHub 在桌面右键鼠标，点击****git bash here进入git终端。 在终端输入如下指令，连接GitHub与本地。  git config --global user.name "mdxz2848"  git config --global user.email "zhipeng2048@gmail.com" 生成SSH key密钥。执行如下指令，然后，在C:*Users**ASUS.ssh目录会有两个文件id_**rsa和**id_rsa.pub*,打开**id_rsa.pub**，复制里面的所有内容到 SSH keys这里 的Key，Title随便填，然后Add SSH key就可以了。  ssh-keygen -t rsa -C "zhipeng2048@gmail.com" 安装hexo 首页进入任意磁盘创建文件夹，这里文件夹命名为blog,在该文件夹下鼠标右键选择Git Bash Here，执行命令：  npm install -g hexo-cli 接着执行如下指令  hexo init  npm install 新建完成后，指定文件夹的目录如下：  _config.yml 部署 在_config.yml文件，找到deploy，进行以下配置：  deploy:  type: git  repo: https://github.com/mdxz2048/mdxz2048.github.io.git  branch: master 安装部署工具，执行如下指令。  npm install hexo-deployer-git --save 使用next主题美化 在blog文件夹下鼠标右键选择Git Bash Here，然后clone next主题：  git clone https://github.com/theme-next/hexo-theme-next themes/next 更新主题NexT：  cd themes/next  git pull 切换成NexT主题，在blog根文件夹下，修改_config.yml文件中的theme：  Extensions  Plugins: https://hexo.io/plugins/  Themes: https://hexo.io/themes/  theme: next 切换后，执行如下指令清理缓存。  hexo clean 执行如下指令，查看本地部署效果。  hexo s 浏览器打开http://localhost:4000/可以看到本地部署效果。 可以文末下载我的博客配置和主题配置文件，根据自己的需求进行修改。 新建一篇文章 执行如下指令新建一个.md的文件，然后在对应路径下打开编辑。
 hexo new 文章名 执行如下指令进行部署  hexo g //生成网页文件  hexo s //localhost:4000本地预览效果  hexo d //部署 在https://mdxz2048.github.io/查看部署效果。 文中提到的软件和配置文件均可在此下载：
 链接: https://pan.baidu.com/s/1Nw-ApHdYZkqXj65h7T7qew  提取码: ssgt</content></entry><entry><title>使用树莓派部署个人网盘</title><url>https://mdxz2048.github.io/post/how-to-install-nextcloud-on-raspberry-3b+/</url><categories><category>工具教程</category></categories><tags><tag>树莓派3B+</tag><tag>nextcloud</tag></tags><content type="html"> 效果展示 准备工作 硬件：树莓派3B+、SD卡、SD卡读卡器、网线
软件：所有需要的软件点击此处下载
提取码: hv1b
(链接失效后可在我的公众号mddxz1995后台回复个人网盘获取最新链接)。
其他环境：公网IP
(若只作为局域网访问则不需要公网IP。公网IP是为了让我们的网盘可以通过外网进行访问，此处以一台阿里云作为代理服务端来演示)
搭建方案 使用开源应用nextcloud在树莓派3B+搭建网盘(也支持其他树莓派型号)实现文件的存储。优点是是支持Android、IOS设备客户端和web端访问，日常使用比较方便。 使用开源应用frp实现内网穿透的反向代理，具体是在一台有公网IP的设备上运行frp服务端，在客户端(这里指树莓派)上运行客户端，外网访问时通过服务端作为代理访问树莓派。优点是支持 tcp, udp 协议，适配了 http 和 https 应用协议，也就是可以更好的通过远程访问我们的网盘内容。 安装镜像 Next cloud提供了树莓派专用的系统镜像，我们可以从官网下载安装，同时也可以在我提供的文件中找到镜像直接安装使用。
将下载完成的镜像解压，解压后效果如图所示。(解压软件在软件及教程\解压缩软件中提供) 将SD读卡器插入电脑，打开Win32DiskImager镜像安装软件，(在软件及教程\镜像写入工具中提供) ，点击此按钮选择上一步解压出来的文件。 在设备栏选择SD卡，我这里选择H盘，选择完效果如图所示。 点击下方写入，然后等待写入完成。 等待进度条完成后，会提示写入成功。此处需要注意若电脑提示要格式化磁盘一定不要格式化。 此时SD卡被分成两个盘。为了稍后使用SSH远程登录树莓派控制台，在资源管理器中进入SD卡boot盘，右键新建/文本文档，新建一个文件名为SSH的空文档，同时删除掉文件后缀名，效果如图所示。 将SD卡插入树莓派等待启动，上电前我们将树莓派通过网线接在路由器的lan口。 等待约十分钟左右，这个时间刚好可以在刺激战场中玩一把团队竞技。 打开路由器的后台，查看树莓派的IP。 打开shell工具，点击文件/新建，协议选择SSH，主机填写树莓派IP地址，端口选择22，然后点击连接(工具在软件及教程\Xshell 、Xftp 6中提供)。 输入默认账号密码，登入控制台，登陆成功后界面如下，也可以根据提示升级新版的nextcloud。 账号：pi
密码：raspberry
打开浏览器，输入树莓派IP，此时可以看到next cloud已经开始运行，这里务必保存好NextCloudPi和NextCloud的账号密码，然后点击下方的Activate。 在弹窗中输入NextCloudPi(也就是第一个)的账号密码，然后点击登录。 如果安装了U盘，第一次运行会提示格式化U盘，也可以选择跳过。 External access栏选择No，然后跳到最后一步就可以开始使用了。 在浏览器地址栏输入树莓派IP，就进入了登陆界面，使用第二个密码登录。 如果看到如下界面就说明已经初始化成功了，此时网盘已经可以在局域网内正常使用，可在apple store和安卓应用市场搜索nextcloud下载对应终端的APP。 Frp反向代理 Frp是一款开源的反向代理软件，我们通过在阿里服务器上运行frp服务端，在树莓派上运行客户端与服务端进行连接。这样我们可以通过服务端作为代理，转发我们对树莓派的请求，以达到外网访问树莓派的目的。这里我主要参考了《FRP中文文档》和《使用frp进行内网穿透》这两篇文档。
服务端配置 在阿里后台实例/安全组 规则添加入方向端口，比如我这里添加7500/7500、7001/7001、7600/7600三个端口分别用来作为frp的服务端管理界面的访问端口、树莓派SSH连接映射端口和树莓派网盘访问端口，配置界面如图所示。 打开xshell客户端，进入阿里服务器的控制台。 执行arch如下指令，查看服务器机器架构，我的服务器是X86_64。 root@iZ2ze68uznd431fxfr63d2Z:~# arch
x86_64
下载对应的frp软件，因为GitHub国内访问速度过慢，我这里已经将服务端的软件上传至软件及教程\frp\服务端(X86_64)，随后通过ftp客户端传至设备即可，和我设备架构相同的同学可以直接使用我提供的软件，其他架构可在frp官方下载界面下载对应的软件（ftp客户端软件在软件及教程\Xshell 、Xftp 6提供）。 打开ftp软件，连接至服务器控制台，将frp服务端软件拖到服务器Dowoload目录下。 通过Xshell连接服务器后台，进入frp服务端软件的存放目录，执行如下命令，解压。 cd Download/ sudo tar -zxvf frp_0.32.0_linux_amd64.tar.gz 执行如下命令，给文件夹改个名，方便使用。 cp -r frp_0.32.0_linux_amd64 frp 执行如下命令，编辑frp的配置文件。 cd frp sudo vim frps.ini 我的服务端配置内容如下： [common] bind_port = 7000#与树莓派绑定的端口 dashboard_port = 7500#frp服务端软件运行信息展示端口 token = 12345678#树莓派与服务端的登陆口令 dashboard_user = admin#frp服务端软件运行信息展示的访问账号 dashboard_pwd = admin#frp服务端软件运行信息展示的访问密码 vhost_http_port = 10080#此处没有使用，我也没弄明白 vhost_https_port = 10443#此处没有使用，我也没弄明白
退出并保存，执行如下指令，运行frp服务端。 ./frps -c frps.ini 此时通过服务器IP:7500就可以看到frp服务端的展示信息，效果如图所示。 再执行如下指令将其运行在后台。 nohup ./frps -c frps.ini &amp; 至此，服务端已经配置完成。 客户端配置 树莓派是armv7架构，将对应的frp软件通过ftp软件拷贝到树莓派的指定目录下。 进入对应目录，和服务端操作类似，解压、重命名。 cd ~/ tar -zxvf frp_0.32.0_linux_arm.tar.gz cp -r frp_0.32.0_linux_arm frp 执行如下指令，编辑客户端配置。 sudo apt-get install vim [common] server_addr = x.x.x.x #这里填服务器IP server_port = 7000 #这里填写服务器配置中的bind_port token = 12345678 #登录口令 [smb] type = tcp local_ip = 127.0.0.1 local_port = 443 remote_port = 7600 [SSH] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000
执行如下指令，运行客户端。 ./frpc -c frpc.ini 输出如下内容，则客户端和服务端绑定成功。 2020/03/21 09:05:14 [I] [service.go:257] [f499bd2db389d748] login to server success, get run id [f499bd2db389d748], server udp port [0] 2020/03/21 09:05:14 [I] [proxy_manager.go:144] [f499bd2db389d748] proxy added: [smb SSH] 2020/03/21 09:05:14 [I] [control.go:179] [f499bd2db389d748] [smb] start proxy success 2020/03/21 09:05:14 [I] [control.go:179] [f499bd2db389d748] [SSH] start proxy success
此时在浏览器地址栏输入服务器IP:7600即可访问树莓派。 出现以上弹窗则说明已经成功访问了树莓派，只是由于next cloud的配置，限制了服务器的IP访问，此时，我们进入next cloud的配置文件，将服务器IP添加进去，然后退出保存。效果如图所示。 sudo vim /var/www/nextcloud/config/config.php 重新运行frp客户端在后台，成功后此时可通过外网进行访问。 nohup ./frpc -c frpc.ini &amp; 特别感谢
感谢next cloud、frp团队开源分享
https://github.com/fatedier/frp https://nextcloud.com/
参考文档
使用frp进行内网穿透</content></entry><entry><title>一个理工科本科毕业生的就业经历分享</title><url>https://mdxz2048.github.io/post/how-to-find-a-job/</url><categories><category>工具教程</category></categories><tags><tag>应届生</tag><tag>找工作</tag></tags><content type="html"> 如果你有兴趣打开了这篇文档，我大概可以相信你现在也是处于大四刚开始找工作的阶段，写这篇文档是因为最近身边有一些学弟学妹来问我关于找工作的事情，就正好利用周末一点时间结合自己参加校招和社招的经历，分享一点点经验给大家。有一点要说明的是，作为我个人的一些经验分享，并不一定适用于当下找工作的形势与政策，也一定不是适用于每个人，但是对于正在或者即将面临毕业的你，我相信或多或少的会有一些有参考价值。
我是自动化专业19届本科生，现在在深圳从事嵌入式计算机行业，毕业前掌握一些单片机和嵌入式linux方面的知识，有一定的C语言基础，另外还有一些实际的学生项目经验，所以我以下的分享可能更适用于有一点技术但是没有选择考研的同学作为参考。
以下我按照我找工作的安排顺序，分为校招、和社招两部分来给大家分享：
校招： 首先是关于招聘会的选择，一开始我就比较重视也算积极的参加了校招，我是在秋季学期的9月和10中旬一共参加了两次。因为考虑毕业后打算去北京，所以当时我选择了在西安一些高校参加校招(之所以没有选择北京完全是因为我对西安更加熟悉一些)
宣讲会信息的整理，参加校招需要提前了解各个学校的宣讲会信息，提前安排好行程，每个学校的校招信息在各个学校的就业信息服务网站中的宣讲会模块都会有，为了保证信息的准确性和实时性建议大家去各高校的官网去看，我会将网址附在文末。为了自己少跑一些路，我将每天的招聘信息按照各个校区(一定注意是校区，有一些学校两个校区之间可能隔两三小时车程)进行分类整理，然后再将同一时间段内(一般就是一个上午或者下午)自己想要参加的招聘信息放在一起，当时是做了表格方便自己随时查看。
其次是校招过程自己总结出的一些经验：
(1)因为很多一场招聘会的时间都在1-2个小时，所以基本上同一间教室一个时间段内一般只有2-3个宣讲会，所以可能你在这所学校感兴趣的两个宣讲会会同时在同一个时间进行宣讲，所以为了应对这种问题建议不是在本校找工作的同学尽量结伴。
(2)关于简历的制作技巧就不在这里说了，在职位这一块我建议写成就业方向，然后选择一两个从事的方向去写，因为每个企业对岗位的叫法不一样，到时候可以在简历明显的位置用笔写上岗位就可以，这里也避免了让人事小姐姐懵O。
(3)校招的流程一般不确定，笔试、面试一般都或前或后的都有可能(如果你有机会参加的话)，这个时间也很不确定，有的是当场进行，有的是电话通知，一般这个就听安排然后按照自己的选择进行安排就行。面试也主要是问一些简历和专业方面的问题，大部分都比较基础。
社招： 对于社招，我首先想抛出我的一个观点：对于第一份工作，企业给你的成长空间比待遇会更重要一些，应当在想要从事的行业去尽可能找一些更大的平台去提升自己。(当然这个目标是在待遇能满足你正常生活的前提下，毕竟这是一件长期的事情，总得每天开开心心的去工作)
社招的准备：
(1)简历一般建议多打印几份，普通黑白打印即可，基本上每家去之前都要求带简历。
(2)行程安排我这次主要使用手机的日历功能，手机会会提前提醒，也是方便安排行程。
(3)基本上大的企业面试都是一些基础的问题，我自己是做软件，做的面试题也基本是一些C语言(主要是指针、内存、常用接口、链表&hellip;)相关和三电起的基础；问题也主要是针对简历上所写的来问，基本上只要是自己做的东西一般也不会被问住。
公司的选择：
我有在北京一家公司待过一段时间，公司主要研发港口自动化方面的系统，规模在一百人左右，其实规模已经不是特别小了，虽然进去也是研发岗位，但是由于一些管理制度上的不完善，导致工作体验比较差，可见范围内也不能很好的提升自己，因此我选择了在答辩完后去深圳找工作，大概是在校运会的那一周我在深圳参加面试，相对来说深圳研发环境比北京好一些，所以我也是很快在深圳找到了工作，但是北方的同学来深圳一定得考虑好南北气候的差异是不是能接受。
另外，如果是做技术方面的同学，尽可能去争取研发岗位，哪怕刚进去是在研发岗干的是助理的活。岗位不一样想转岗难度一般会比较大，除非你是特别优秀或者选择跳槽。
平台的选择：
我一共用了三家招聘平台的APP：BOOS直聘、前程无忧(51Job)、智联直聘，现在看来后两家企业的回复会多一些，boos直聘更多的是企业主动联系你让你发简历。
写在最后： 现在正处于九月中旬，也就是秋招刚刚开始的阶段，大家完全有时间去多参加一些面试，无论是否成功给自己积累一下经验总不是件坏事。作为本科毕业生想要从事技术领域相关工作，更多的还是要真正学到一些知识、技能，这也是你找工作的资本。如果你到现在还是一张白纸什么也不会，那么以上的内容可能并不适用。
最后，真诚的希望各位能够珍惜大学最后的这段时光，尽可能到处走走，多和朋友、老师在一起聚一聚。
个人水平有限，小小的分享只希望能够帮到一二就相当满足了，仅作为参考，不建议生搬硬套。
以下是我之前整理的一些高校的就业信息网站，基本上在百度搜索“高校+就业”就会跳出来。
北方民族大学： http://jyc.nun.edu.cn/module/careers?menu_id=6598
西安理工大学： http://job.xaut.edu.cn/website/index.aspx
长安大学： http://jyzx.chd.edu.cn/
西电： http://job.xidian.edu.cn/Special/Index/100021/0
西安邮电： http://jiuye.xupt.edu.cn/
……</content></entry><entry><title>学会使用高级搜索命令，提高搜索引擎使用效率</title><url>https://mdxz2048.github.io/post/google-search-skills/</url><categories><category>工具教程</category></categories><tags><tag>搜索技巧</tag></tags><content type="html"> 如今国内搜索引擎市场经过多年来的发展也已经完成了洗牌。根据 据析趣知 提供的数据，百度搜索无疑是国内引擎竞争中的最大赢家，虽然它有很多让我们诟病的缺点，但我们大部分人还不得不边骂边从铺天盖地的广告中找出自己需要的信息。
图 1- 2019年2月中文搜索引擎使用
数据来自：2019年2月，全球&amp;中国搜索引擎市场份额排行榜-据析趣知
当然，也有人千方百计的去追求体验更好的goole搜索，也有人转战使用新生军今日有条，但是在国内百度搜索无疑是我们的主要工具，为了提高搜索引擎的使用效率，尽量避开那些不想看到的广告，快速、准确的找到需有用的信息， 我找了四个常用的百度高级搜索技巧介绍给大家。
技巧一：完全匹配符 "" 描述：使用英文双引号"&ldquo;将搜索关键词括起来，可以让搜索结果完全匹配。
举例；使用百度搜索 格力举报 和 &ldquo;格力举报&rdquo;
结论：可以明显的看到使用了 "&rdquo; 后 格力 不会和 举报 分开，这就是搜索结果完全匹配。
对比一A： 使用 格力举报 搜索结果 对比一B： 使用 &ldquo;格力举报&rdquo; 搜索结果 技巧二：排除搜索 描述：在搜索关键词后加 -排除关键词，可以在搜索结果中排除掉需要排除的关键词。
举例：使用百度搜索 格力 和 格力 -奥克斯
结论：使用了 格力 -奥克斯 搜索后很明显的结果中排除了这两天很热的格力和奥克斯的举报纠纷。
对比二A： 使用 格力 搜索结果 对比二B： 使用 格力 -奥克斯 搜索结果 技巧三：文件格式过滤 描述：在关键词后加 filetype：xxx 可以在搜索结果中只展示指定格式结果。
举例：使用百度搜索 毕业答辩 filetype:ppt 和 毕业答辩 filetype:doc
结论：在关键词后添加 filetype:文件格式 后可以明显的看到搜索结果只包含了指定格式的结果。
对比三A： 使用 毕业答辩 filetype:ppt 搜索结果 对比三B： 使用 毕业答辩 filetype:doc 搜索结果 技巧四：主题关键字包含 描述：在关键词前加 intitle: 只展示搜索结果的主题包含关键词的结果
举例：使用百度搜索 intitle:奥克斯
结论：搜索结果中主题中都包含 奥克斯
使用 intitle:奥克斯 搜索结果 当然搜索引擎高级命令不止于此，搜索引擎的也不止百度一家， 希望以此抛砖引玉，能够帮大家更自主的使用搜索引擎，快速、高效的完成每一次搜索。
欢迎感兴趣的朋友关注我的个人公众号“mddxz1995”，获取更多资源、资讯。</content></entry><entry><title>关于我</title><url>https://mdxz2048.github.io/about.html</url><categories/><tags/><content type="html"> 警惕三种怪癖 第一种怪癖：我们对已经拥有的东西迷恋到不能自拔。
第二种怪癖：是我们总是把注意力集中到自己会失去什么上，而不是会得到什么上。
第三种怪癖：是我们经常假定别人看待交易的角度和我们一样。</content></entry><entry><title>12306</title><url>https://mdxz2048.github.io/post/12306/</url><categories><category>工具教程</category></categories><tags><tag>12306bypass</tag><tag>抢票</tag></tags><content type="html"> 这两天需要买一张火车票，但是打开12306APP时候发现已经卖完了，就想着是不是要抢票软件去买加速包了，但是看到12306提示的是 候补 而不是无票，就去了解了一下这个候补的规则，真香！
首先大概说一下没有候补之前售票流程所有官方放出来的票会直接进入一个 票池 ，12306官网、客户端以及所有抢票软件都是在这个票池中买票，当没有票的时候其实大家都买不到票，但是一发现有人退票，因为软件可以一直监测票池，所以就比人有优势抢到票，当然这是 以前 。
再来看看现在有了候补制度的售票流程因为存在候补，在放出的票 进入票池之前 会先查看是否有候补订单，如果有直接根据候补订单的下单时间顺序（注意这里是直接根据订单的提交时间顺序！）将票分配给对应的订单，这样这张票就已经售出不会进入票池，当没有候补订单时才会进入票池，接下来才是各类APP和后面的乘客继续购买。
当然候补终止时间为“不晚于开车前一天的1900”，所以在这个时间节点之后候补通道关闭，也就是开车前一天的七点之后不可以进行候补，如果这时候还没有买到票就需要去票池等别人退票了，这个时间到开车前停止售票这个时间段才是12306给抢票软件留下的生存空间。
现在我们可以分析一下，候补通道有效时，抢票软件其实是在这个候补订单之后买票，相对于这个候补机制完全没有了优势。那么我们买票完全可以直接在12306官网进行购买或候补，成功率明显高于抢票软件，而且不用去到处给别人分享加速包。而在候补通道关闭后剩下那一段时间内，你可以尽情去用你喜爱的抢票软件了。</content></entry><entry><title>Windows远程桌面</title><url>https://mdxz2048.github.io/post/windows%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/</url><categories><category>工具教程</category></categories><tags><tag>远程桌面</tag></tags><content type="html"> 软件名 rdpwrap
安装平台 Windows
功能介绍 本软件为开源软件，开源地址： 激活Windows自带的远程桌面，适用于家庭版等 实现多用户远程桌面 软件下载 比百度更快的网盘：因微信公众号平台限制，请在公众号后台回复关键字“rdpWrap”获取下载链接
安装 解压压缩包后，右键以管理员身份运行install.bat执行安装脚本，然后关闭弹窗。安装成功效果如下： 右键以管理员身份运行RDPConf.exe，可以看到我这里的Windows系统版本显示不支持，没关系，这只是配置的问题，我们继续往下看。 先关掉RDPConf.exe的弹窗，在Windows桌面进行如下操作，关闭远程桌面服务。 按Win+R按键，打开服务界面。 选中Remote Desktop Services，点击停止此服务； 其他 进入RDP Wrapper安装目录，默认为C:\Program Files\RDP Wrapper，删除rdpwrap.ini配置文件，将我分享的配置文件放进来，分享的配置文件大小为179KB。 为了保险起见，我们直接进行一下升级。将我分享链接中的autoupdate.zip文件解压出来，将升级脚本放到RDP Wrapper安装目录，默认为C:\Program Files\RDP Wrapper。右键以管理员身份运行。效果如图： 升级过程比较快，执行完之后，记得回到服务中，启动远程桌面服务，效果如图： 此时，再打开RDPConf.exe检查配置，可以看到之前红色部分的警告信息都没有了，我们的电脑就可以在局域网下访问远程桌面了，效果不要舒服。 使用 在桌面，搜索远程桌面； 输入被远程访问电脑的IP，登录账号、密码即可远程访问。 账号、密码为被访问电脑的用户： 可以在设置/账户/家庭和其他用户/将其他人添加到这台电脑进行 添加。 或者将被访问的电脑锁屏，然后用本地登录的账号密码进行登录 点击连接即可登陆。 碰到其他问题，可在公众号留言或去GitHub项目下查找解决方法。</content></entry></search>
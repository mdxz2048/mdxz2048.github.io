<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>自上而下理解内核网络(五)---网络层（IP协议）数据的接收与发送</title><url>https://mdxz2048.github.io/post/study_linux_tcp_in_linux_05/</url><categories><category>Linux内核</category></categories><tags><tag>自上而下理解内核网络</tag></tags><content type="html"> 终于又有时间划水了，我们接着分析网络层。在上一节中，我们介绍了sock与传输层UDP，展示了在传输层(UDP协议栈）中的数据收发流。
本节，继续自上而下进行跟踪，紧挨着传输层的是网络层（我们这里主要关注IPv4协议）。网络层主要负责如下工作：
本机发送和接收数据； 其他经过网卡设备的数据转发； 我们这里主要关注网络层对本机ipv4数据的发送和接收处理，跟踪内核代码，了解数据是如何从传输层(UDP协议)经过**网络层(IP协议)**发送到网卡设备；同时，也会跟踪数据从网卡接收到之后，经过网络层(IP协议)进入udp的接收入口；最后，会在篇幅允许的情况下，了解网络层如何转发经过网卡非本机的数据。
​ 网络层的数据和路线 ipv4协议首部 IPv4报头成员的内容决定了IPv4协议栈处理数据包的方式，如果存在问题，则数据包将被丢弃。
在*《TCP-IP详解卷I-协议》IP:网际协议*一章节中，我们挪用了这一章节中的IP数据包的结构，如下图：
IP报头的定义位于文件ip.h,位于这样一个结构体中：
struct iphdr { #if defined(__LITTLE_ENDIAN_BITFIELD) __u8 ihl:4, version:4; #elif defined (__BIG_ENDIAN_BITFIELD) __u8 version:4, ihl:4; #else #error "Please fix &lt;asm/byteorder.h>" #endif __u8 tos; __be16 tot_len; __be16 id; __be16 frag_off; __u8 ttl; __u8 protocol; __sum16 check; __be32 saddr; __be32 daddr; /*The options start here. */ }; 各部分含义如下：
**ihl:**表示Internet报头长度。IPv4报头长度以4字节为单位，长度不固定。因为IPv4报头可包含可选的边长选项。IPv4报头最短为20字节(不包含任何选项时，对应的ihl的值为5)，最长为60字节(对应的ihl值为15).IPv4报头的长度必须是4字节的整数倍。 **version：**必须是4。 **tos：**tos表示服务类型。 **tot_len：**包括报头在内的数据包总长度，单位为字节。tot_len字段长16位，可表示最大长度为64KB。RFC 761规定，数据包最短不得少于576字节。 **id：**IPv4报头标识。对于分段来说，id字段很重要。对SKB进行分段时，所有分段的id值都必须相同；对于分段后的数据包，则要根据各个分段的id对其进行重组。 **frag_off：**分段偏移量，长16位。后13位指出了分段的偏移量。在第一个分段中，偏移量为0。偏移量以8字节为单位。前3位的值不同时，分别表示如下含义： 001表示后边还有其他分段(More fragments,MF).除最后一个分段外，其他分段都必须设置这个标志； 010表示不分段(Don&rsquo;t Fragment,DF). 100表示拥塞(Congestion,CE). **ttl：**存活时间。这是一个 跳数计数器。每个转发节点都会将ttl减1，当ttl变为0时，将丢弃数据包，并发回一条ICMPv4超时消息，以避免数据包因某种原因被无休止的转发。 **protocol：**数据包的第4层协议，如IPPROTO_TCP表示TCP流量，而IPPROTO_UDP表示UDP流量。 **check：**校验和，长16位。校验和是仅根据IPv4报头计算得到的。 **saddr：**源IPv4地址，长32位。 **daddr：**目标IPv4地址，长32位。 IPV4的初始化 IPv4数据包的以太类型为0x0800(以太类型存储在14字节的以太网报头的开头两个字节中)。每种协议都必须指定一个协议处理程序并初始化，以便让网络栈能够处理归属于该协议的数据包。本机介绍的IPv4协议处理程序的注册，让读者了解导致IPv4方法对收到的IPv4数据包进行处理的起因。(也就是在这儿注册了IPv4接收回调函数)
程序部分：
static struct packet_type ip_packet_type __read_mostly = { .type = cpu_to_be16(ETH_P_IP), .func = ip_rcv, .list_func = ip_list_rcv, }; static int __init inet_init(void) { ...... dev_add_pack(&amp;ip_packet_type); ...... } dev_add_pack()将ip_rcv()指定为IPv4数据包的协议处理程序。inet_init()执行各种IPv4初始化工作，在引导阶段被调用。
本机发送数据 从上一节我们知道，在UDP协议发送数据最后，由"udp_send_skb来处理skb，将数据传入到协议栈的下一层，也就是IP协议栈",因此，我们这里从udp_send_skb()开始入手。
这里大致画了一张UDP数据在IP协议层的流向，来展示数据的发送过程：
本机接收数据ip_rcv ip_rcv 该函数的定义位于文件ip_input.c。ip_rcv()主要完成数据包的完整性检查，实际的工作通过ip_rcv_finish()来完成。
判断是其他主机的数据包，则丢弃； 检查IPv4的包头大小和版本； 调用钩子函数NF_INET_PRE_ROUTING，我们这里假设没有调用，直接调用下一个函数ip_rcv_finish，真正处理数据。 /* * Main IP Receive routine. */ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev) { const struct iphdr *iph; struct net *net; u32 len; /* When the interface is in promisc. mode, drop all the crap * that it receives, do not try to analyse it. */ /* 判断是其他主机的数据包，则丢弃；*/ if (skb->pkt_type == PACKET_OTHERHOST) goto drop; net = dev_net(dev); __IP_UPD_PO_STATS(net, IPSTATS_MIB_IN, skb->len); skb = skb_share_check(skb, GFP_ATOMIC); if (!skb) { __IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS); goto out; } if (!pskb_may_pull(skb, sizeof(struct iphdr))) goto inhdr_error; iph = ip_hdr(skb); /* * RFC1122: 3.2.1.2 MUST silently discard any IP frame that fails the checksum. * * Is the datagram acceptable? * * 1. Length at least the size of an ip header * 2. Version of 4 * 3. Checksums correctly. [Speed optimisation for later, skip loopback checksums] * 4. Doesn't have a bogus length */ /* 检查IPv4的包头大小和版本 */ if (iph->ihl &lt; 5 || iph->version != 4) goto inhdr_error; BUILD_BUG_ON(IPSTATS_MIB_ECT1PKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_ECT_1); BUILD_BUG_ON(IPSTATS_MIB_ECT0PKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_ECT_0); BUILD_BUG_ON(IPSTATS_MIB_CEPKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_CE); __IP_ADD_STATS(net, IPSTATS_MIB_NOECTPKTS + (iph->tos &amp; INET_ECN_MASK), max_t(unsigned short, 1, skb_shinfo(skb)->gso_segs)); if (!pskb_may_pull(skb, iph->ihl*4)) goto inhdr_error; iph = ip_hdr(skb); if (unlikely(ip_fast_csum((u8 *)iph, iph->ihl))) goto csum_error; len = ntohs(iph->tot_len); if (skb->len &lt; len) { __IP_INC_STATS(net, IPSTATS_MIB_INTRUNCATEDPKTS); goto drop; } else if (len &lt; (iph->ihl*4)) goto inhdr_error; /* Our transport medium may have padded the buffer out. Now we know it * is IP we can trim to the true length of the frame. * Note this now means skb->len holds ntohs(iph->tot_len). */ if (pskb_trim_rcsum(skb, len)) { __IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS); goto drop; } skb->transport_header = skb->network_header + iph->ihl*4; /* Remove any debris in the socket control block */ memset(IPCB(skb), 0, sizeof(struct inet_skb_parm)); IPCB(skb)->iif = skb->skb_iif; /* Must drop socket now because of tproxy. */ skb_orphan(skb); /* 调用钩子函数NF_INET_PRE_ROUTING，我们这里假设没有调用，直接调用下一个函数ip_rcv_finish，真正处理数据*/ return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, net, NULL, skb, dev, NULL, ip_rcv_finish); csum_error: __IP_INC_STATS(net, IPSTATS_MIB_CSUMERRORS); inhdr_error: __IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS); drop: kfree_skb(skb); out: return NET_RX_DROP; } ip_rcv_finish skb_dst()用于检查是否有与skb相关联dst对象，dst是一个dst_entry实例，表示路由选择子系统的查找结果。 如果没有与SKB关联的dst，则由ip_route_input_noref()在路由选择子系统中执行查找，如果查找失败，数据包被丢弃；在ip_route_input_noref()中，查找工作是根据路由选择表和数据包头进行的。在路由选择子系统中查找时，也会设置dst的input和output回调函数。例如，如果需要对数据包进行准发，在路由选择子系统查找时把input回调设置成ip_forward()；如果目的是当前机器，则input是为ip_local_deliver()；如果是组播，则input回调设置为ip_mr_input()。也就是dst决定了数据包的后续走向。 检查IPv4报头是否包含选项； 通过dst_input，调用skb_dst(skb)->input(skb)将数据传输到上一层。 static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb) { const struct iphdr *iph = ip_hdr(skb); struct rtable *rt; struct net_device *dev = skb->dev; /* if ingress device is enslaved to an L3 master device pass the * skb to its handler for processing */ skb = l3mdev_ip_rcv(skb); if (!skb) return NET_RX_SUCCESS; /*skb_dst()用于检查是否有与skb相关联dst对象*/ if (net->ipv4.sysctl_ip_early_demux &amp;&amp; !skb_dst(skb) &amp;&amp; !skb->sk &amp;&amp; !ip_is_fragment(iph)) { const struct net_protocol *ipprot; int protocol = iph->protocol; ipprot = rcu_dereference(inet_protos[protocol]); if (ipprot &amp;&amp; ipprot->early_demux) { ipprot->early_demux(skb); /* must reload iph, skb->head might have changed */ iph = ip_hdr(skb); } } /* * Initialise the virtual path cache for the packet. It describes * how the packet travels inside Linux networking. */ /*如果没有与SKB关联的dst，则由ip_route_input_noref()在卤藕选择子系统中执行查找，如果查找失败，数据包被丢弃。*/ if (!skb_valid_dst(skb)) { int err = ip_route_input_noref(skb, iph->daddr, iph->saddr, iph->tos, dev); if (unlikely(err)) { if (err == -EXDEV) __NET_INC_STATS(net, LINUX_MIB_IPRPFILTER); goto drop; } } #ifdef CONFIG_IP_ROUTE_CLASSID if (unlikely(skb_dst(skb)->tclassid)) { struct ip_rt_acct *st = this_cpu_ptr(ip_rt_acct); u32 idx = skb_dst(skb)->tclassid; st[idx&amp;0xFF].o_packets++; st[idx&amp;0xFF].o_bytes += skb->len; st[(idx>>16)&amp;0xFF].i_packets++; st[(idx>>16)&amp;0xFF].i_bytes += skb->len; } #endif /*检查IPv4报头是否包含选项，不包含时这里ihl是4*/ if (iph->ihl > 5 &amp;&amp; ip_rcv_options(skb)) goto drop; rt = skb_rtable(skb); if (rt->rt_type == RTN_MULTICAST) { __IP_UPD_PO_STATS(net, IPSTATS_MIB_INMCAST, skb->len); } else if (rt->rt_type == RTN_BROADCAST) { __IP_UPD_PO_STATS(net, IPSTATS_MIB_INBCAST, skb->len); } else if (skb->pkt_type == PACKET_BROADCAST || skb->pkt_type == PACKET_MULTICAST) { struct in_device *in_dev = __in_dev_get_rcu(dev); /* RFC 1122 3.3.6: * * When a host sends a datagram to a link-layer broadcast * address, the IP destination address MUST be a legal IP * broadcast or IP multicast address. * * A host SHOULD silently discard a datagram that is received * via a link-layer broadcast (see Section 2.4) but does not * specify an IP multicast or broadcast destination address. * * This doesn't explicitly say L2 *broadcast*, but broadcast is * in a way a form of multicast and the most common use case for * this is 802.11 protecting against cross-station spoofing (the * so-called "hole-196" attack) so do it for both. */ if (in_dev &amp;&amp; IN_DEV_ORCONF(in_dev, DROP_UNICAST_IN_L2_MULTICAST)) goto drop; } /*通过dst_input，调用skb_dst(skb)->input(skb)*/ return dst_input(skb); drop: kfree_skb(skb); return NET_RX_DROP; }</content></entry><entry><title>Study_Valgrind_Memcheck</title><url>https://mdxz2048.github.io/study_valgrind_memcheck/</url><categories><category>软件分享/工具教程/想法/Linux内核</category></categories><tags><tag>标签1</tag><tag>标签2</tag></tags><content type="html"/></entry><entry><title>内存调试工具Valgrind之Memcheck</title><url>https://mdxz2048.github.io/post/study_valgrind_memcheck/</url><categories><category>工具教程</category></categories><tags><tag>内存泄漏</tag><tag>Valgrind</tag></tags><content type="html"> 介绍 Valgrind是一款用于内存调试、内存泄漏检测以及性能分析的软件开发工具。
交叉编译 开发主机 Ubuntu20.04（x86_64） 目标主机 ARM64（aarch64） 在这里下载valgrind-3.19.0.tar.bz2，执行指令tar xvf valgrind-3.17.0.tar.bz2解压源码，效果如下；
╭─ caeri@ubuntu  ~/lzp/GIT  INSERT   2 ↵ ╰─ tar xvf valgrind-3.17.0.tar.bz2 valgrind-3.17.0/ valgrind-3.17.0/docs/ valgrind-3.17.0/docs/cg_merge.1 导出交叉编译工具链到当前环境；
source /opt/dias/fsl-imx-xwayland/5.4-zeus/environment-setup-aarch64-poky-linux 导出后，可以看到当前的编译器已经指向了交叉编译器
╭─ caeri@ubuntu  ~/lzp/GIT/valgrind-3.17.0  INSERT   ✔ ╰─ echo $CC aarch64-poky-linux-gcc -mcpu=cortex-a35+crc+crypto -fstack-protector-strong -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -Werror=format-security --sysroot=/opt/dias/fsl-imx-xwayland/5.4-zeus/sysroots/aarch64-poky-linux 在开发主机新建一个安装文件夹，该文件夹路径应与以后在开发板上安装valgrind的路径保持一致，我们这里新建如下：
make -p /caeridata/bin/lzp/valgrind 这里说明，未来在目标板(开发板)上，要将valgrind安装在目录/caeridata/bin/lzp/valgrind下。
执行如下指令./configure --target=aarch64-poky-linux --host=aarch64-poky-linux --prefix=/caeridata/bin/lzp/valgrind，设置编译参数,执行后效果如下:
╭─ caeri@ubuntu  ~/lzp/GIT/valgrind-3.17.0  INSERT   ✔ ╰─ ./configure --target=aarch64-poky-linux --host=aarch64-poky-linux --prefix=/caeridata/bin/lzp/valgrind configure: loading site script /opt/dias/fsl-imx-xwayland/5.4-zeus/site-config-aarch64-poky-linux checking for a BSD-compatible install... /usr/bin/install -c checking whether build environment is sane... yes checking for aarch64-poky-linux-strip... aarch64-poky-linux-strip checking for a thread-safe mkdir -p... /usr/bin/mkdir -p ...... config.status: executing depfiles commands Maximum build arch: arm64 Primary build arch: arm64 Secondary build arch: Build OS: linux Link Time Optimisation: no Primary build target: ARM64_LINUX Secondary build target: Platform variant: vanilla Primary -DVGPV string: -DVGPV_arm64_linux_vanilla=1 Default supp files: xfree-3.supp xfree-4.supp glibc-2.X-drd.supp glibc-2.34567-NPTL-helgrind.supp glibc-2.X.supp 这里的几个参数
target 目标主机 prefix 安装目录，注意要保证有写入权限； 执行make进行编译，执行效果如下：
╭─ caeri@ubuntu  ~/lzp/GIT/valgrind-3.17.0  INSERT   ✔ ╰─ make echo "# This is a generated file, composed of the following suppression rules:" > default.supp echo "# " xfree-3.supp xfree-4.supp glibc-2.X-drd.supp glibc-2.34567-NPTL-helgrind.supp glibc-2.X.supp >> default.supp ...... make[2]: Leaving directory '/home/caeri/lzp/GIT/valgrind-3.17.0/mpi' Making all in solaris make[2]: Entering directory '/home/caeri/lzp/GIT/valgrind-3.17.0/solaris' make[2]: Nothing to be done for 'all'. make[2]: Leaving directory '/home/caeri/lzp/GIT/valgrind-3.17.0/solaris' Making all in docs make[2]: Entering directory '/home/caeri/lzp/GIT/valgrind-3.17.0/docs' make[2]: Nothing to be done for 'all'. make[2]: Leaving directory '/home/caeri/lzp/GIT/valgrind-3.17.0/docs' make[1]: Leaving directory '/home/caeri/lzp/GIT/valgrind-3.17.0' 编译完成后，需要进行make install，我这里因为使用了非root用户编译且安装目录在/caerdata…因此我这里安装的时候需要切换到root用户，且需要重新导出交叉编译工具链。这里就不进行演示了。
安装完成后，效果如下：
root@ubuntu:/caeridata/bin/lzp/valgrind# ls bin include lib libexec share 接下来将整个文件夹打包，然后复制到开发板解压
#在开发主机上，打包 tar cvf valgrind.tar valgrind #在开发板上，解压到/caeridata/bin/lzp/ tar -xvf valgrind.tar -C /caeridata/bin/lzp/ 最后，在开发板上的效果如下：
root@imx8qxpc0mek:/caeridata/bin/lzp/valgrind# ls bin include lib libexec share 到这里安装就完成了，为了方便使用，可以在开发板上/caeridata/bin/lzp/valgrind/bin这个路径导出到环境变量中，方便在其他目录使用。
Valgrind-Memcheck说明 memcheck是valgrind的默认工具，所以不必须使用--tool=memcheck来指定。
memcheck将内存错误分为六种：
访问禁止访问的内存； 使用没有被定义的变量。例如变量数据没有被初始化，或者其他变量衍生的未初始化数据; 不正确的释放堆内存。例如两次free一个堆块，或者没有成对的使用malloc/free、new/delete; memcpy相关函数的src和dst有重叠; 将可疑值(负值)传递给申请内存(malloc等)函数的大小参数; 内存泄漏; Memcheck检测结果说明
Memcheck会返回一系列的错误消息,下边我们针对各种消息进行说明。
非法读写Illegal read / Illegal write errors 示例
Invalid read of size 4 at 0x40F6BBCC: (within /usr/lib/libpng.so.2.1.0.9) by 0x40F6B804: (within /usr/lib/libpng.so.2.1.0.9) by 0x40B07FF4: read_png_image(QImageIO *) (kernel/qpngio.cpp:326) by 0x40AC751B: QImageIO::read() (kernel/qimage.cpp:3621) Address 0xBFFFF0E0 is not stack'd, malloc'd or free'd 这个发生在当你的程序读/写memcheck猜测你不应该读写的内存。
Memcheck会试图确定出错的具体位置。例如它指向一块已经被free的内存，那么Memcheck会指出free的位置。同样的，指针刚好在一个array数组的末尾，这是数组越界访问的常见错误，Memcheck将会告知这一信息，以及出错的位置。如果使用参数--read-var-info，Memcheck会告知更详细的信息，当然，这会导致软件运行更慢。
在上边这个示例中，Memcheck不能识别出这个地址。实际上，这个地址是在栈上，因为一些原因，这并不是一个有效的栈地址&mdash;它位于堆栈指针下方，这是不允许的。在这种特殊情况下，它可能是由GCC生成无效代码引起，这是一些古版GCC中的已知错误。
要注意的是，Memcheck只会告知你的程序即将访问一个非法地址，它并不会阻止程序的访问行为。因此，如果你的程序正常情况会导致segmentation fault这件事情依然会发生。但是你可以通过Memcheck马上返回一个消息。
使用未初始化数据 Use of uninitialised values 示例
Conditional jump or move depends on uninitialised value(s) at 0x402DFA94: _IO_vfprintf (_itoa.h:49) by 0x402E8476: _IO_printf (printf.c:36) by 0x8048472: main (tests/manuel1.c:8) 当程序使用了一个未初始化的变量时，会返回该错误。在这里，未定义的变量，被C库的printf函数调用。这个错误在我们运行如下代码的时候可以复现。
int main() { int x; printf ("x = %d\n", x); } Memcheck只监视变量，不提示任何警告，直到它在程序中被使用，Memcheck才开始报告。上述示例中，Memcheck观察传递给_IO_printf没有报告，然后传递给_IO_vfprintf，当_IO_vfprintf必须检查x的值以便于将其转换成ASCII码，此时才会报告错误。
未初始化的值往往来自2个地方：
本地变量未被初始化，例如上边的示例； 指针在malloc等函数给指针赋值之前，往指针写值； 在程序中观察未初始化信息，使用参数--track-origins=yes。
系统调用中未初始化或不可寻址的数据Use of uninitialised or unaddressable values insystem calls Memcheck检测所有系统调用的参数：
检测所有的直接参数是否被初始化； 如果系统调用需要从应用程序提供的buffer中读取数据，Memcheck会检测buffer入口的地址是否正确，并检查buffer内容是否被初始化； 如果系统调用需要写数据到应用程序提供的buffer，则Memcheck会检测buffer的入口地址； 系统调用后，Memcheck 会更新其跟踪的信息，以精确反映由系统调用引起内存状态的任何更改。
这里有一个系统调用参数无效的示例：
#include &lt;stdlib.h>#include &lt;unistd.h>int main( void ) { char* arr = malloc(10); int* arr2 = malloc(sizeof(int)); write( 1 /* stdout */, arr, 10 ); exit(arr2[0]); } 可以得到：
Syscall param write(buf) points to uninitialised byte(s) at 0x25A48723: __write_nocancel (in /lib/tls/libc-2.3.3.so) by 0x259AFAD3: __libc_start_main (in /lib/tls/libc-2.3.3.so) by 0x8048348: (within /auto/homes/njn25/grind/head4/a.out) Address 0x25AB8028 is 0 bytes inside a block of size 10 alloc'd at 0x259852B0: malloc (vg_replace_malloc.c:130) by 0x80483F1: main (a.c:5) Syscall param exit(error_code) contains uninitialised byte(s) at 0x25A21B44: __GI__exit (in /lib/tls/libc-2.3.3.so) by 0x8048426: main (a.c:8) 非法释放Illegal frees 示例
Invalid free() at 0x4004FFDF: free (vg_clientmalloc.c:577) by 0x80484C7: main (tests/doublefree.c:10) Address 0x3807F7B4 is 0 bytes inside a block of size 177 free'd at 0x4004FFDF: free (vg_clientmalloc.c:577) by 0x80484C7: main (tests/doublefree.c:10) Memcheck跟踪malloc/new申请的内存，因此它知道是否正确的free/delete释放内存。这这个测试程序中，同一个malloc的block，被free了两次。
申请内存被错误的释放 ​ 在下边的示例中，用new[]申请的内存被错误的使用free释放。
Mismatched free() / delete / delete [] at 0x40043249: free (vg_clientfuncs.c:171) by 0x4102BB4E: QGArray::~QGArray(void) (tools/qgarray.cpp:149) by 0x4C261C41: PptDoc::~PptDoc(void) (include/qmemarray.h:60) by 0x4C261F0E: PptXml::~PptXml(void) (pptxml.cc:44) Address 0x4BB292A8 is 0 bytes inside a block of size 64 alloc'd at 0x4004318C: operator new[](unsigned int) (vg_clientfuncs.c:152) by 0x4C21BC15: KLaola::readSBStream(int) const (klaola.cc:314) by 0x4C21C155: KLaola::stream(KLaola::OLENode const *) (klaola.cc:416) by 0x4C21788F: OLEFilter::convert(QCString const &amp;) (olefilter.cc:272) 在C++中，内存的申请方式与释放方式兼容非常重要。处理原则： 如果使用malloc, calloc, realloc, valloc 或者 memalign申请的内存，必须使用free释放； 如果使用new申请的内存，必须使用delete释放； 如果使用new[]申请的内存，必须使用delete[]释放； 源地址和目标地址存在重叠 Overlapping source and destination blocks。
在C库中的memcpy,strcpy, strncpy, strcat, strncat等这一类函数。操作的源地址和目的地址被要求不能出现重叠。POSIX中有定义“如果copy的两个地址存在重叠，则这种行为未定义”。Memcheck可以监测这个问题。
例如：
==27492== Source and destination overlap in memcpy(0xbffff294, 0xbffff280, 21) ==27492== at 0x40026CDC: memcpy (mc_replace_strmem.c:71) ==27492== by 0x804865A: main (overlap.c:40) 可疑参数 Fishy argument values
所有的内存申请函数都有一个参数用来指明需要申请内存的大小。这个参数要求是非负数且通常不会过大。例如，在一个64位的机器上，很(不喜欢)少去申请一个2^63Byte大小的内存。这样的大的值通常可能会是一个错误的值，只是由于符号位未被解析，则展示出是一个巨大的非负值。这种数就叫做"fishy value"，可疑数值。以下函数将被检查：malloc, calloc,realloc, memalign, new, new []. __builtin_new, __builtin_vec_new，calloc的两个参数都会被检查。
示例：
==32233== Argument 'size' of function malloc has a fishy (possibly negative) value: -3 ==32233== at 0x4C2CFA7: malloc (vg_replace_malloc.c:298) ==32233== by 0x400555: foo (fishy.c:15) ==32233== by 0x400583: main (fishy.c:23) 内存泄漏 Memcheck会追踪所有 malloc/new申请的内存，当进程退出的时候，它知道所有没有被释放的内存块。
如果--leak-check参数被配置，对于每一个未被释放的block，Memcheck会确定该块是否属于可以访问 root-set的指针，rootk-set由所有线程的通用寄存器和可访问内存(包括栈)中指针大小的对齐数据字。
有两种方式可以操作到一个block，第一种是使用“start-pointer”，开始指针，第二种是使用block内部的指针。我们知道的有这几种方式访问一个block：
指针开始可能是一个起始指针，会被程序有意(或者无意)移动。特别是，使用另一个tag来指向这个起始指针； 它可能是一个内存中的一个垃圾数据(被错误的当成指针)，数据整体是没有关联的，完全是一个巧合； 它可能是 C++ std::string内部char数组的指针，在编译器中，申请数组会返回一个指向数组的指针； 某些代码分配一个内存块，会使用前8个字节来存储指针，例如sqlite3MemMalloc就是这么做的； 它可能是指向分配了 new[] 的 C++ 对象（具有析构函数）数组的指针； 它可能是指向使用多重继承的C++对象内部部分的指针； 可以选择配置在泄漏搜索期间检测stdstring, length64, newarray和multipleinheritance对应的情况。如果启发式检测到内部指针，对应于这种情况，块将被视为可通过内部指针访问。换句话说，内部指针将被视为起始指针。
考虑到这一点，请考虑下图中描述的九种可能的情况。
Pointer chain AAA Leak Case BBB Leak Case ------------- ------------- ------------- (1) RRR ------------> BBB DR (2) RRR ---> AAA ---> BBB DR IR (3) RRR BBB DL (4) RRR AAA ---> BBB DL IL (5) RRR ------?-----> BBB (y)DR, (n)DL (6) RRR ---> AAA -?-> BBB DR (y)IR, (n)DL (7) RRR -?-> AAA ---> BBB (y)DR, (n)DL (y)IR, (n)IL (8) RRR -?-> AAA -?-> BBB (y)DR, (n)DL (y,y)IR, (n,y)IL, (_,n)DL (9) RRR AAA -?-> BBB DL (y)IL, (n)DL Pointer chain legend: - RRR: a root set node or DR block - AAA, BBB: heap blocks - --->: a start-pointer - -?->: an interior-pointer Leak Case legend: - DR: 直接可达 - IR: 间接可达 - DL: 直接丢失 - IL: 间接丢失 - (y)XY: 如果内部指针是真正的指针 - (n)XY: 如果内部指针不是真正的指针 - (_)XY: 两种情况都不是 每种内存泄漏的情况都属于上边九种中的一种。Memcheck合并了一些情况进行输出，最后会输出4中结果：
仍可以访问，包括上述的1、2。意味着BBB内存块仍然是可访问的，有可能在未来某个时刻被释放。 绝对丢失，包括上述第3种情况。BBB无法再被访问，确认泄漏。 间接丢失，包括上述第4、9种情况。由于AAA无法被访问，AAA和BBB都无法被正常释放。 可能丢失，包括上述第5-8中情况。 在存在内存泄漏的情况下，Memcheck会反馈一张表：
LEAK SUMMARY: definitely lost: 48 bytes in 3 blocks. indirectly lost: 32 bytes in 2 blocks. possibly lost: 96 bytes in 6 blocks. still reachable: 64 bytes in 4 blocks. suppressed: 0 bytes in 0 blocks. 如果指定了–leak-check = full，则Memcheck将提供每个绝对丢失或可能丢失的块的详细信息，包括分配位置。（实际上，它会将泄漏类型相同且堆栈跟踪充分相似的所有块的结果合并到单个“丢失记录”中。–leak-resolution使您可以控制“充分相似”的含义。）它无法告诉你何时，如何或为什么丢失指向泄漏块的指针；您必须自己解决。通常，你应该尝试确保你的程序在退出时没有任何绝对丢失或可能丢失的块。
8 bytes in 1 blocks are definitely lost in loss record 1 of 14 at 0x........: malloc (vg_replace_malloc.c:...) by 0x........: mk (leak-tree.c:11) by 0x........: main (leak-tree.c:39) 88 (8 direct, 80 indirect) bytes in 1 blocks are definitely lost in loss record 13 of 14 at 0x........: malloc (vg_replace_malloc.c:...) by 0x........: mk (leak-tree.c:11) by 0x........: main (leak-tree.c:25) 内存检测实验 以C语言demo，展示可能会导致上述Memcheck报错的情况。
非法读写 概述 非法读写是
实验代码 #include &lt;stdio.h> int main(int argc, char **argv) { int *ptr = NULL; printf("read ptr: %d\n",*ptr); return 0; } 实验过程 编译程序，然后运行
gcc memcheck.c -o memcheck valgrind ./memcheck 这个程序因为指针没有初始化绑定，因此一定会产生一个“segmentation fault”，我们这里执行完，memcheck结果如下：
╭─ caeri@ubuntu  ~/lzp/program_C/valgrind  INSERT   127 ↵ ╰─ valgrind ./memcheck ==5660== Memcheck, a memory error detector ==5660== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==5660== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info ==5660== Command: ./memcheck ==5660== ==5660== Invalid read of size 4 ==5660== at 0x109168: main (in /home/caeri/lzp/program_C/valgrind/memcheck) ==5660== Address 0x0 is not stack'd, malloc'd or (recently) free'd ==5660== ==5660== ==5660== Process terminating with default action of signal 11 (SIGSEGV) ==5660== Access not within mapped region at address 0x0 ==5660== at 0x109168: main (in /home/caeri/lzp/program_C/valgrind/memcheck) ==5660== If you believe this happened as a result of a stack ==5660== overflow in your program's main thread (unlikely but ==5660== possible), you can try to increase the size of the ==5660== main thread stack using the --main-stacksize= flag. ==5660== The main thread stack size used in this run was 8388608. ==5660== ==5660== HEAP SUMMARY: ==5660== in use at exit: 0 bytes in 0 blocks ==5660== total heap usage: 0 allocs, 0 frees, 0 bytes allocated ==5660== ==5660== All heap blocks were freed -- no leaks are possible ==5660== ==5660== For lists of detected and suppressed errors, rerun with: -s ==5660== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) 这里首先可以看到在输出8-10行中，出现的非法读取提示，提示地址”0x0不属于栈(当然不属于)，malloc申请的内存，或者是已经被释放掉了“，其实这里的指针直接是NULL，明显指针有问题。
==5660== Invalid read of size 4 ==5660== at 0x109168: main (in /home/caeri/lzp/program_C/valgrind/memcheck) ==5660== Address 0x0 is not stack'd, malloc'd or (recently) free'd 结论 指针指向的地址非法会导致“Invalid read of size 4”错误； 使用未初始化数据 概述 实验代码 #include &lt;stdio.h> int main(int argc, char **argv) { int val; printf("read ptr: %d\n",val); return 0; } 实验过程 编译程序，然后运行
gcc memcheck.c -o memcheck valgrind ./memcheck 这里我们的局部变量val没有初始化，Memcheck结果如下：
╭─ caeri@ubuntu  ~/lzp/program_C/valgrind  INSERT   SIGSEGV(11) ↵ ╰─ valgrind --read-var-info=yes ./memcheck ==6920== Memcheck, a memory error detector ==6920== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==6920== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info ==6920== Command: ./memcheck ==6920== ==6920== Conditional jump or move depends on uninitialised value(s) ==6920== at 0x48D9958: __vfprintf_internal (vfprintf-internal.c:1687) ==6920== by 0x48C3D3E: printf (printf.c:33) ==6920== by 0x109171: main (in /home/caeri/lzp/program_C/valgrind/memcheck) ==6920== ==6920== Use of uninitialised value of size 8 ==6920== at 0x48BD69B: _itoa_word (_itoa.c:179) ==6920== by 0x48D9574: __vfprintf_internal (vfprintf-internal.c:1687) ==6920== by 0x48C3D3E: printf (printf.c:33) ==6920== by 0x109171: main (in /home/caeri/lzp/program_C/valgrind/memcheck) ==6920== ==6920== Conditional jump or move depends on uninitialised value(s) ==6920== at 0x48BD6AD: _itoa_word (_itoa.c:179) ==6920== by 0x48D9574: __vfprintf_internal (vfprintf-internal.c:1687) ==6920== by 0x48C3D3E: printf (printf.c:33) ==6920== by 0x109171: main (in /home/caeri/lzp/program_C/valgrind/memcheck) ==6920== ==6920== Conditional jump or move depends on uninitialised value(s) ==6920== at 0x48DA228: __vfprintf_internal (vfprintf-internal.c:1687) ==6920== by 0x48C3D3E: printf (printf.c:33) ==6920== by 0x109171: main (in /home/caeri/lzp/program_C/valgrind/memcheck) ==6920== ==6920== Conditional jump or move depends on uninitialised value(s) ==6920== at 0x48D96EE: __vfprintf_internal (vfprintf-internal.c:1687) ==6920== by 0x48C3D3E: printf (printf.c:33) ==6920== by 0x109171: main (in /home/caeri/lzp/program_C/valgrind/memcheck) ==6920== read ptr: 0 ==6920== ==6920== HEAP SUMMARY: ==6920== in use at exit: 0 bytes in 0 blocks ==6920== total heap usage: 1 allocs, 1 frees, 1,024 bytes allocated ==6920== ==6920== All heap blocks were freed -- no leaks are possible ==6920== ==6920== Use --track-origins=yes to see where uninitialised values come from ==6920== For lists of detected and suppressed errors, rerun with: -s ==6920== ERROR SUMMARY: 5 errors from 5 contexts (suppressed: 0 from 0) 首先，这里打印“Conditional jump or move depends on uninitialised value(s)”，可以看到在调用printf之后，调用了__vfprintf_internal，这里会检测参数的值，因此在这里会报错。
==6920== Conditional jump or move depends on uninitialised value(s) ==6920== at 0x48D9958: __vfprintf_internal (vfprintf-internal.c:1687) ==6920== by 0x48C3D3E: printf (printf.c:33) ==6920== by 0x109171: main (in /home/caeri/lzp/program_C/valgrind/memcheck) 接下来，会提示“Use of uninitialised value of size 8”，这是因为我们未初始化变量val导致的。
==6920== Use of uninitialised value of size 8 ==6920== at 0x48BD69B: _itoa_word (_itoa.c:179) ==6920== by 0x48D9574: __vfprintf_internal (vfprintf-internal.c:1687) ==6920== by 0x48C3D3E: printf (printf.c:33) ==6920== by 0x109171: main (in /home/caeri/lzp/program_C/valgrind/memcheck) 结论 使用未初始化的局部变量会导致“Use of uninitialised value of size 8”； 使用未初始化的全局变量不会导致上述问题。这里因为局部变量在栈，不会被初始化，而全局变量会被自动初始化为0，所以这里的val如果定义在main函数外边，就不会报错。 系统调用中未初始化或不可寻址的数据 概述 使用系统调用时，写入方向的参数使用了未初始化的变量。例如write写入的内容为未初始化。
实验代码 #include &lt;stdio.h>#include &lt;stdlib.h>#include &lt;unistd.h> int main(int argc, char **argv) { int fd = 1; char * buf = malloc(10); write(fd, buf, 10); free(buf); return 0; } 实验过程 编译，执行后结果如下
╭─ caeri@ubuntu  ~/lzp/program_C/valgrind  INSERT   ✔ ╰─ valgrind --read-var-info=yes ./memcheck ==9476== Memcheck, a memory error detector ==9476== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==9476== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info ==9476== Command: ./memcheck ==9476== ==9476== Syscall param write(buf) points to uninitialised byte(s) ==9476== at 0x4970077: write (write.c:26) ==9476== by 0x1091C6: main (in /home/caeri/lzp/program_C/valgrind/memcheck) ==9476== Address 0x4a57040 is 0 bytes inside a block of size 10 alloc'd ==9476== at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so) ==9476== by 0x1091AC: main (in /home/caeri/lzp/program_C/valgrind/memcheck) ==9476== ==9476== ==9476== HEAP SUMMARY: ==9476== in use at exit: 0 bytes in 0 blocks ==9476== total heap usage: 1 allocs, 1 frees, 10 bytes allocated ==9476== ==9476== All heap blocks were freed -- no leaks are possible ==9476== ==9476== Use --track-origins=yes to see where uninitialised values come from ==9476== For lists of detected and suppressed errors, rerun with: -s ==9476== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) 这里我们向stdout写入了一个malloc回来的buf，显然这时候buf里的值是随机的，因此会触发这个错误。
==9476== Syscall param write(buf) points to uninitialised byte(s) ==9476== at 0x4970077: write (write.c:26) ==9476== by 0x1091C6: main (in /home/caeri/lzp/program_C/valgrind/memcheck) ==9476== Address 0x4a57040 is 0 bytes inside a block of size 10 alloc'd ==9476== at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so) ==9476== by 0x1091AC: main (in /home/caeri/lzp/program_C/valgrind/memcheck) 结论 在使用系统调用接口时，传入了未初始化的变量，会导致“Syscall param write(buf) points to uninitialised byte(s)” 非法释放 概述 申请的内存被错误(重复)释放。
实验代码 #include &lt;stdio.h>#include &lt;stdlib.h>#include &lt;unistd.h> int main(int argc, char **argv) { int fd = 1; char * buf = malloc(10); write(fd, buf, 10); free(buf); free(buf); return 0; } 实验过程 编译后，执行结果如下：
╭─ caeri@ubuntu  ~/lzp/program_C/valgrind  INSERT   ✔ ╰─ valgrind --read-var-info=yes ./memcheck ==9848== Memcheck, a memory error detector ==9848== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==9848== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info ==9848== Command: ./memcheck ==9848== ==9848== Invalid free() / delete / delete[] / realloc() ==9848== at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so) ==9848== by 0x1091A8: main (in /home/caeri/lzp/program_C/valgrind/memcheck) ==9848== Address 0x4a57040 is 0 bytes inside a block of size 10 free'd ==9848== at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so) ==9848== by 0x10919C: main (in /home/caeri/lzp/program_C/valgrind/memcheck) ==9848== Block was alloc'd at ==9848== at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so) ==9848== by 0x10918C: main (in /home/caeri/lzp/program_C/valgrind/memcheck) ==9848== ==9848== ==9848== HEAP SUMMARY: ==9848== in use at exit: 0 bytes in 0 blocks ==9848== total heap usage: 1 allocs, 2 frees, 10 bytes allocated ==9848== ==9848== All heap blocks were freed -- no leaks are possible ==9848== ==9848== For lists of detected and suppressed errors, rerun with: -s ==9848== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) 结论 重复free同一个block会导致“Invalid free() / delete / delete[] / realloc()”;
释放无效的block也会导致“Invalid free() / delete / delete[] / realloc()”，例如
char buf[1] = {0}; free(buf); 申请内存被错误释放 概述 这个主要是针对在C++中，不同的申请内存的方式new/new[]需要不同的delete/delete[]的方式进行释放。
源地址与目标地址重叠 概述 用来调试在代码中，出现的memcpy等类似函数的源与目标重叠的情况。
但是，很抱歉的是，在实际测试中，即使我的代码出现了重叠情况，但是valgrind没有按照预想的那样扑捉到。以下是这次失败的实验。
实验代码 #include &lt;stdio.h>#include &lt;stdlib.h>#include &lt;unistd.h>#include &lt;string.h> int main(int argc, char **argv) { char buf[] = "This is a overlapping."; printf("before: %s\n", buf); memcpy(buf+3, buf, 20); printf("after: %s\n", buf); return 0; } 实验过程 编译程序
gcc -o memcheck memcheck.c 程序直接执行结果如下：
明显可以看出来，在buf复制过程中，出现了重叠部分，即前3个字节被重复复制。
before: This is a overlapping. after: ThiThis is a overlappin 我们再继续使用Valgrind，我们期望在这里看到相关“Source and destination overlap in memcpy”这样子的打印。执行结果如下：
╭─ caeri@ubuntu  ~/lzp/program_C/valgrind  INSERT   ✔ ╰─ valgrind ./memcheck ==13227== Memcheck, a memory error detector ==13227== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==13227== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info ==13227== Command: ./memcheck ==13227== before: This is a overlapping. ==13227== Conditional jump or move depends on uninitialised value(s) ==13227== at 0x483EF58: strlen (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so) ==13227== by 0x48DAD14: __vfprintf_internal (vfprintf-internal.c:1688) ==13227== by 0x48C3D3E: printf (printf.c:33) ==13227== by 0x109223: main (in /home/caeri/lzp/program_C/valgrind/memcheck) ==13227== after: ThiThis is a overlappin ==13227== ==13227== HEAP SUMMARY: ==13227== in use at exit: 0 bytes in 0 blocks ==13227== total heap usage: 1 allocs, 1 frees, 1,024 bytes allocated ==13227== ==13227== All heap blocks were freed -- no leaks are possible ==13227== ==13227== Use --track-origins=yes to see where uninitialised values come from ==13227== For lists of detected and suppressed errors, rerun with: -s ==13227== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) 很遗憾的是，不清楚哪儿出了问题，Valgrind将错误认为是“Conditional jump or move depends on uninitialised value(s)”。而这个结果一般是因为变量未初始化。
到这里，这个失败的实验先告一段落。后续碰到触发了重叠的警告的时候，再回来补充。
结论 无 可疑参数 概述 这里的可疑参数，指的是在申请内存的时候，传入的内存大小为负数导致的错误。
实验代码 #include &lt;stdio.h>#include &lt;stdlib.h>#include &lt;unistd.h>#include &lt;string.h> int main(int argc, char **argv) { char *buf = malloc(atoi(argv[1])); free(buf); return 0; } 实验过程 编译程序，然后运行
gcc -o memcheck memcheck.c 这里我们传入参数为-1，以触发valgrind报警。运行结果如下：
╭─ caeri@ubuntu  ~/lzp/program_C/valgrind  INSERT   SIGINT(2) ↵ ╰─ valgrind ./memcheck -1 ==19332== Memcheck, a memory error detector ==19332== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==19332== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info ==19332== Command: ./memcheck -1 ==19332== ==19332== Argument 'size' of function malloc has a fishy (possibly negative) value: -1 ==19332== at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so) ==19332== by 0x1091B8: main (in /home/caeri/lzp/program_C/valgrind/memcheck) ==19332== ==19332== ==19332== HEAP SUMMARY: ==19332== in use at exit: 0 bytes in 0 blocks ==19332== total heap usage: 0 allocs, 0 frees, 0 bytes allocated ==19332== ==19332== All heap blocks were freed -- no leaks are possible ==19332== ==19332== For lists of detected and suppressed errors, rerun with: -s ==19332== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) 可以在结果中看到，这里提示传入的参数为fishy value；
==19332== Argument 'size' of function malloc has a fishy (possibly negative) value: -1 ==19332== at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so) ==19332== by 0x1091B8: main (in /home/caeri/lzp/program_C/valgrind/memcheck) 结论 malloc、calloc等申请内存的接口传入负数参数时，会触发fishy value； 内存泄漏</content></entry><entry><title>ASN1C使用手册</title><url>https://mdxz2048.github.io/post/asn1c%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url><categories><category>工具教程</category></categories><tags><tag>ASN1C编译器</tag><tag>ASN.1</tag></tags><content type="html"> 在介绍本文的主角asn1c之前，我们这里先看一下维基百科对ASN.1标准的描述：
在电信和计算机网络领域，ASN.1（Abstract Syntax Notation One) 是一套标准，是描述数据的表示、编码、传输、解码的灵活的记法。它提供了一套正式、无歧义和精确的规则以描述独立于特定计算机硬件的对象结构。
简单来说，ASN.1定义了一套描述数据的描述方法，这种方法与语言无关，无论是C语言、Java还是Go，都能通过语言本身的语法来进行定义、描述数据。在通信行业中，经常使用ASN.1来定义数据。
我们这里要介绍的asn1c是一个基于ASN.1语法的编译器。能根据给定的ASN.1描述文件来生成对应的C语言代码，包含了BER/OER/PER/XER多种格式的编解码C语言接口，有助于加快嵌入式设备对ASN.1数据的理解和处理。
开源ASN.1编译器介绍 ANS1C的全称是ASN.1 Compiler，主要用来根据ASN.1文件来生成对应的兼容C++的C代码。支持BER/OER/PER/XER多种格式的编解码。
ASN1C是一个编译器，以ASN.1语法和ASN.1文件生成语法树，然后编译出目标语言，我们这里主要用C语言，以后要学习编译器，相信研究一下asn1c也是个不错的选择，这里我们先了解它的使用。
作者：Lev Walkin vlm@lionet.info ASN.1版本：0.9.29 开源地址：asn1c 安装 以下演示在Ubuntu20.04虚拟机上，通过源码安装asn1c编译器，其他平台过程类似。
环境依赖 automake大于1.15 libtool bison等于2.x，实测3.5.1版本也可以使用 flex 从源码编译 执行如下指令，下载源码到本地，然后进入asn1c文件夹；
git clone git@github.com:vlm/asn1c.git cd asn1c 使用默认配置设置工程：
test -f configure || autoreconf -iv ./configure make 配置成功后效果如下：
╭─ caeri@ubuntu  ~/lzp/GIT/asn1c ╰─ test -f configure || autoreconf -iv utoreconf: Entering directory `.' ....... onfigure.ac:5: installing 'config/install-sh' configure.ac:5: installing 'config/missing' parallel-tests: installing 'config/test-driver' asn1-tools/enber/Makefile.am: installing 'config/depcomp' autoreconf: running: gnu-configize autoreconf: Leaving directory `.' ╭─ caeri@ubuntu  ~/lzp/GIT/asn1c ╰─ ./configure checking for a BSD-compatible install... /usr/bin/install -c ...... config.status: creating config.h config.status: executing depfiles commands config.status: executing libtool commands ╭─ caeri@ubuntu  ~/lzp/GIT/asn1c ╰─ make make all-recursive make[1]: Entering directory '/home/caeri/lzp/GIT/asn1c' Making all in libasn1common ...... make[2]: Entering directory '/home/caeri/lzp/GIT/asn1c' make[2]: Leaving directory '/home/caeri/lzp/GIT/asn1c' make[1]: Leaving directory '/home/caeri/lzp/GIT/asn1c' 编译成功后，执行如下指令，进行安装
make install ╭─ caeri@ubuntu  ~/lzp/GIT/asn1c   master  INSERT  ╰─ make install Making install in libasn1common ...... /usr/bin/mkdir -p '/usr/local/share/doc/asn1c' /usr/bin/install -c -m 644 README.md INSTALL.md REQUIREMENTS.md FAQ ChangeLog BUGS '/usr/local/share/doc/asn1c' make[2]: Leaving directory '/home/caeri/lzp/GIT/asn1c' make[1]: Leaving directory '/home/caeri/lzp/GIT/asn1c' 执行man asn1c检查是否安装成功，如果有相关手册打印出来即为安装成功。
asn1c(1) Version 0.9.29 asn1c(1) NAME asn1c -- the ASN.1 Compiler SYNOPSIS asn1c [-E [-F] | -P | -R] [-Sdir] [-X] [-Wdebug-...] [-foption] [-gen-option] [-pdu={all|auto|Type}] [-print-option] input-filenames... DESCRIPTION asn1c compiles ASN.1 specifications into a set of target language (C/C++) encoders and decoders for BER, DER, PER, XER, OER and other encoding rules. 快速开始示例 1.1 一个“Rectangle”转换和调试 最常见的需求是为一个已经存在的ASN.1数据文件，创建一个分析工具。让我们来为一个存在的Rectangle的二进制文件构建一个BER、OER、PER、XER(XML)的转换器。如下：
在ans1c文件夹下，新建一个rectangle.asn 文件，写入如下内容：
RectangleModule DEFINITIONS ::= BEGIN Rectangle ::= SEQUENCE { height INTEGER, width INTEGER } END 执行如下指令，使用asn1c将其编译成.c和.h文件
asn1c -no-gen-example rectangle.asn 执行如下指令，生成一个转换器：
make -f converter-example.mk 完成后，使用二进制文件进行转换：
./converter-example -h 效果如下
╭─ caeri@ubuntu  ~/lzp/GIT/asn1c   master ?  INSERT   SIGINT(2) ↵ ╰─ ./converter-example -h Usage: ./converter-example [options] &lt;datafile> ... Where options are: -iber Input is in BER (Basic Encoding Rules) or DER -ioer Input is in OER (Octet Encoding Rules) -iper Input is in Unaligned PER (Packed Encoding Rules) (DEFAULT) -ixer Input is in XER (XML Encoding Rules) -oder Output as DER (Distinguished Encoding Rules) -ooer Output as Canonical OER (Octet Encoding Rules) -oper Output as Unaligned PER (Packed Encoding Rules) -oxer Output as XER (XML Encoding Rules) (DEFAULT) -otext Output as plain semi-structured text -onull Verify (decode) input, but do not output -per-nopad Assume PER PDUs are not padded (-iper) -p &lt;PDU> Specify PDU type to decode -p list List available PDUs -1 Decode only the first PDU in file -b &lt;size> Set the i/o buffer size (default is 8192) -c Check ASN.1 constraints after decoding -d Enable debugging (-dd is even better) -n &lt;num> Process files &lt;num> times -s &lt;size> Set the stack usage limit (default is 30000) 1.2 一个“Rectangle”编码器 这个示例将帮助你新增一个“Rectangle”的BER、XER编码器。
为了方便查看文件，我们在asn1c下新建asn_files和out两个文件夹，分别用来存放asn源文件和输出文件；
在asn_files下增加一个文件rectangle.asn ，内容如下：
RectangleModule DEFINITIONS ::= BEGIN Rectangle ::= SEQUENCE { height INTEGER, width INTEGER } END 执行如下指令，使用asn1c将其编译成.c和.h文件
asn1c -no-gen-example -D out asn_files/rectangle.asn 到这里，就可以在out文件夹下得到多个文件，其中包含了Rectangle.c 和Rectangle.h。
创建一个包含main.c的文件，在main()函数中创建结构体Rectangle_t，然后使用BER、XER编码规则进行编码。main.c内容如下：
/* * @Author : lv zhipeng * @Date : 2022-06-09 16:10:41 * @LastEditors : lv zhipeng * @LastEditTime : 2022-06-09 16:11:55 * @FilePath : /asn1c/out/main.c * @Description : * */ #include &lt;Rectangle.h> /* Rectangle ASN.1 type */#include &lt;stdio.h>#include &lt;sys/types.h>/* Write the encoded output into some FILE stream. */ static int write_out(const void *buffer, size_t size, void *app_key) { FILE *out_fp = app_key; size_t wrote = fwrite(buffer, 1, size, out_fp); return (wrote == size) ? 0 : -1; } int main(int ac, char **av) { Rectangle_t *rectangle; /* Type to encode */ asn_enc_rval_t ec; /* Encoder return value */ /* Allocate the Rectangle_t */ rectangle = calloc(1, sizeof(Rectangle_t)); /* not malloc! */ if(!rectangle) { perror("calloc() failed"); exit(1); } /* Initialize the Rectangle members */ rectangle->height = 42; /* any random value */ rectangle->width = 23; /* any random value */ /* BER encode the data if filename is given */ if(ac &lt; 2) { fprintf(stderr, "Specify filename for BER output\n"); } else { const char *filename = av[1]; FILE *fp = fopen(filename, "wb"); /* for BER output */ if(!fp) { perror(filename); exit(1); } /* Encode the Rectangle type as BER (DER) */ ec = der_encode(&amp;asn_DEF_Rectangle, rectangle, write_out, fp); fclose(fp); if(ec.encoded == -1) { fprintf(stderr, "Could not encode Rectangle(at % s)\n", ec.failed_type ? ec.failed_type->name : "unknown"); exit(1); } else { fprintf(stderr, "Created % s with BER encoded Rectangle\n", filename); } } /* Also print the constructed Rectangle XER encoded (XML) */ xer_fprint(stdout, &amp;asn_DEF_Rectangle, rectangle); return 0; /* Encoding finished successfully */ } 这里有一个asn1c的bug，需要从asn1c源码目录手动复制这几个文件到out目录再编译，否则需要禁用相关OER的编解码，具体解决方案可以看这里
cd out cp ../skeletons/BIT_STRING* ./ cp ../skeletons/OCTET_STRING* ./ 编译所有文件，生成可执行文件rencode。
cc -I. -o rencode *.c 这个rencode程序，就是支持BER、XER编码的Rectangle编码器，运行程序可以看到我们在main()函数中填充的数据XER格式的输出：
╭─ caeri@ubuntu  ~/lzp/GIT/asn1c/out   master ?  INSERT   ✔ ╰─ ./rencode Specify filename for BER output &lt;Rectangle> &lt;height>42&lt;/height> &lt;width>23&lt;/width> &lt;/Rectangle> 1.3 一个“Rectangle”解码器 这个示例将帮助你新增一个“Rectangle”的BER、XER解码器。
新建一个名为rectangle.asn 的文件。内容如下：
RectangleModule DEFINITIONS ::= BEGIN Rectangle ::= SEQUENCE { height INTEGER, width INTEGER } END 执行如下指令，使用asn1c将其编译成.c和.h文件
asn1c -no-gen-example -D out asn_files/rectangle.asn 到这里，就可以在当前文件夹下得到多个文件，其中包含了Rectangle.c 和Rectangle.h。
创建一个main.c文件，包含main()函数，该函数接收一个二进制输入文件，它将输入文件按照BER编码规则进行解码为Rectangle 格式，然后会打印输出XML格式的内容。内容如下：
#include &lt;Rectangle.h> /* Rectangle ASN.1 type */#include &lt;stdio.h>#include &lt;sys/types.h>int main(int ac, char **av) { char buf[1024]; /* Temporary buffer */ asn_dec_rval_t rval; /* Decoder return value */ Rectangle_t *rectangle = 0; /* Type to decode. Note this 01! */ FILE *fp; /* Input file handler */ size_t size; /* Number of bytes read */ char *filename; /* Input file name */ /* Require a single filename argument */ if(ac != 2) { fprintf(stderr, "Usage: % s&lt;file.ber>\n", av[0]); exit(1); } else { filename = av[1]; } /* Open input file as readିonly binary */ fp = fopen(filename, "rb"); if(!fp) { perror(filename); exit(1); } /* Read up to the buffer size */ size = fread(buf, 1, sizeof(buf), fp); fclose(fp); if(!size) { fprintf(stderr, "% s: Empty or broken\n", filename); exit(1); } /* Decode the input buffer as Rectangle type */ rval = ber_decode(0, &amp;asn_DEF_Rectangle, (void **)&amp;rectangle, buf, size); if(rval.code != RC_OK) { fprintf(stderr, "% s: Broken Rectangle encoding at byte% ld\n", filename,(long)rval.consumed); exit(1); } /* Print the decoded Rectangle type as XML */ xer_fprint(stdout, &amp;asn_DEF_Rectangle, rectangle); return 0; /* Decoding finished successfully */ } 编译所有文件，生成可执行文件rencode（注意参考1.2复制缺少的文件）。
cc -I. -o rdecode *.c 这个rdncode程序，就是支持BER、XER编码的Rectangle解码器。
1.4 给“Rectangle”增加约束(数据验证) 此示例显示如何向 ASN.1 规范添加基本约束以及如何调用应用程序中的约束验证代码。
创建名为rectangle.asn的文件。内容如下:
这里我们对asn的使用手册中rectangle.asn进行了修改，将width INTEGER (0..MAX)修改为width INTEGER (0..200)，因为在使用MAX时，没有指定具体的最大值，所以在后边的asn_check_constraints()时发生错误。
RectangleModuleWithConstraints DEFINITIONS ::= BEGIN Rectangle ::= SEQUENCE { height INTEGER (0..100), -- Value range constraint width INTEGER (0..200) -- Makes width non-negative } END 参考1.3中节，编译文件生成.c和.h。
asn1c -no-gen-example -D out asn_files/rectangle.asn 新建main.c，将1.2 一个“Rectangle”编码器中的main.c复制过来，然后将如下代码加入到处理程序末尾，部分如下：
/* Also print the constructed Rectangle XER encoded (XML) */ xer_fprint(stdout, &amp;asn_DEF_Rectangle, rectangle); int ret;/* Return value */ char errbuf[128]; /* Buffer for error message */ size_t errlen = sizeof(errbuf); /* Size of the buffer */ /* ... here goes the Rectangle decoding code ... */ ret = asn_check_constraints(&amp;asn_DEF_Rectangle, rectangle, errbuf, &amp;errlen); /* assert(errlen &lt; sizeof(errbuf)); // you may rely on that */ if(ret) { fprintf(stderr, "Constraint validation failed : % s\n", errbuf); /* exit(...); // Replace with appropriate action */ } /* ... here goes the Rectangle encoding code ... */ 像上一节那样编译所有文件，这里主要要复制
cd out cp ../skeletons/BIT_STRING* ./ cp ../skeletons/OCTET_STRING* ./ cc -I. -o rencode *.c 这里我们进行两次实验，分别让填充数据合法和超限，观察程序的检测结果：
第一次，数据合法
填充合法数据
/* Initialize the Rectangle members */ rectangle->height = 15; /* any random value */ rectangle->width = 30; /* any random value */ 执行结果
╭─ caeri@ubuntu  ~/lzp/GIT/asn1c/out   master ?  INSERT   SIGINT(2) ↵ ╰─ ./rencode Specify filename for BER output &lt;Rectangle> &lt;height>15&lt;/height> &lt;width>30&lt;/width> &lt;/Rectangle> 第二次，数据超限
填充超限数据
/* Initialize the Rectangle members */ rectangle->height = 150; /* any random value */ rectangle->width = 300; /* any random value */ 执行结果
╭─ caeri@ubuntu  ~/lzp/GIT/asn1c/out   master ?  INSERT   ✔ ╰─ ./rencode Specify filename for BER output &lt;Rectangle> &lt;height>150&lt;/height> &lt;width>300&lt;/width> &lt;/Rectangle> Constraint validation failed : INTEGER: constraint failed (Rectangle.c:30) 至此，数据验证演示完毕。
ASN.1编译器 2.1 ASN1C编译工具 ASN.1编译器是将ASN.1表示语法中的规范转换为其他一些语言，例如C语言。
编译器读取(输入)规范，发出(输出)一系列目标语言的结构(struct, union, enum )来实现相应的ASN.1类型。编译器还会创建支持这些结构体序列化/反序列化的代码，代码支持BER、DER、OER、PER、XER的编码规则。
例如这个ASN.1文件：
RectangleModule DEFINITIONS ::= BEGIN Rectangle ::= SEQUENCE { height INTEGER, -- Height of the rectangle width INTEGER --Width of the rectangle } END 编译器读取上述的ASN.1定义，并生成以下C结构体：
typedef struct Rectangle_s { long height; long width; } Rectangle_t; asn1c 编译器还创建了用于将此结构转换为独立于平台的解码器代码,解码代码支持将解码内容返回到当前设备。
用于编译 ASN.1 模块：
asn1c &lt;modules.asn> 如果多个ASN.1模块包含互相依赖的关系，编译的时候需要包含多个asn文件：
asn1c &lt;module1.asn> &lt;module2.asn> ... 编译器的参数-E和-EF用来检测解析和语义错误。这些选项将指示编译器按照编译器所理解的进行转换被识别为正确的（-F 参数会尝试修复ASN.1文件中的语法问题）ASN.1 规范，这个参数可以用来检查编译器是否正确支持当前的语法构造。
asn1c -EF &lt;module-to-test.asn> -P 选项用于将编译后的输出打印到屏幕上，而不是创建一堆当前目录中磁盘上的 .c 和 .h 文件。
另一个选项 -R，询问编译器只生成需要生成的文件，并阻止生成大量链接支持文件。
打印编译输出而不是创建多个源文件：
asn1c -P &lt;module-to-compile-and-print.asn> 2.2 编译器输出 asn1c编译器会输出一些文件，包括：
.asn文件中定义的每种ASN类型对应的.c和.h文件。这些文件名的命名类似于ASN.1格式，(例如第一章提到的RectangleModule ASN.1 模块的 Rectangle.c 和 Rectangle.h)。 一些其他辅助程序的.c和.h文件，例如通用的编码器、解码器和其他有用的demo。 一个Makefile.am.libasncodecs文件，它显式的列出了所有生成的文件。这个makefile可以用来编译编解码库。 一个converter-example.c 文件，它包含了main()函数，支持编码和数据格式转换。它可以将给定的PDU文件在BER、XER、OER和PER之间进行转换。有时候我们的应用代码就是在这个文件基础上进行修改。 一个converter-example.mk 文件，该makefile文件通过编译Makefile.am.libasncodecs 和converterexample.c 文件，为你的ASN数据格式生成一个转换和调试程序。 只需要几条指令就可以编译所有内容：
asn1c -pdu=Rectangle *.asn make -f converte-example.mk # If you use ‘make‘ 这里有一个小的技巧，因为我们在第一章中，输入的asn文件在asn_files文件夹下，输出在out下，因此我这里编译的时候需要将Makefile.am.libasncodec复制到out下，然后修改converter-example.mk如下部分：
#修改前 include out/Makefile.am.libasncodec ASN_PROGRAM_SRCS ?= \ out/converter-example.c #修改后 include Makefile.am.libasncodec ASN_PROGRAM_SRCS ?= \ converter-example.c 2.3 命令行配置 下边表格总结了ASN1C的命令行选项。
阶段选择选项 描述 -E 在执行解析阶段后停止，并打印重建的 ASN.1规范代码到标准输出。 -F 和-E选项一起使用，指示编译器在 ASN.1 语法树修复阶段后停止并将重构的 ASN.1 规范转储到标准输出。 -P 将编译后的输出打印到标准输出，而不是在磁盘上创建目标语言文件。 -R 限制编译器只生成 ASN.1 表，省略通常的支持代码。 -S 指定文件夹下的ASN.1文件。 -X 为指定的ASN.1模块生成XML DTD。 警告选项 描述 -Werror 将警告视为错误； 如果产生任何警告则中止 -Wdebug-parser 在 ASN.1 解析阶段启用解析器调试 -Wdebug-lexer 在 ASN.1 解析阶段启用词法分析器调试。 -Wdebug-fixer 在修复过程中启用 ASN.1 语法树修复器调试器。 -Wdebug-compiler 在实际编译时启用调试 语言配置 描述 -fbless-SIZE *允许INTEGER, ENUMERATED和其他类型的约束，通常为了防止数据数值范围超出导致错误禁止该选项，即数值超出范围不会报错。*这违反了ASN.1标准，可能导致生成的代码没有用。待验证 -fcompound-names 对 C 结构使用复杂的名称。如果模块在多个上下文中重用相同的标识符，则使用复杂的名称可以防止名称冲突 -findirect-choice 为 CHOICE 类型生成代码时，编译 CHOICE成员作为间接指针而不是内联声明。考虑将此选项与 -fno-includedeps 一起使用以防止循环引用。 -fincludes-quoted 在“double”而不是 引号中生成 #include 行。 -fknown-extern-type= 假装指定的类型是已知的。 编译器会假设给定类型的目标语言源文件已手动提供。 -fline-refs 在生成的代码注释中包含 ASN.1 模块的行号。 -fno-constraints 不产生ASN.1的类型约束代码片段，这样可执行文件小一点 。 -fno-include-deps 不为非关键项生成#include包含。 -fwide-types 使用泛类型定义(INTEGER_t, REAL_t )，而不是机器自身的类型定义(long, double )。 -no-gen-OER 不生成OER支持代码 -no-gen-PER 不生成PER支持代码 -no-gen-example 不生产ASN.1格式转换demo。 -pdu={all|all|Type 为指定类型|所有类型 创建 PDU 表 输出选项 描述 -print-class-matrix 当配置了-EF选项，这个选项指示编译器打印收集到的ASN对象矩阵。 -print-constraints 当配置了-EF选项，此选项指示编译器打印其对子类型约束的内部理解。 -print-lines 在 -E 输出中生成“&ndash; #line”注释 API参考 本章中描述的函数供开发人员使用。这些功能在下一个主要版本之前不太可能改变或被删除。
此处未列出的 API 调用不是公开的，不应由应用程序调用。
这里我们从手册中摘取基本的asn_xxx_xxx()系列函数进行说明，其他编解码类型的功能和调用方式类似，不再此赘述。
3.1 宏定义 ASN_STRUCT_FREE() macro 概要 #define ASN_STRUCT_FREE(type_descriptor, struct_ptr) 描述 递归释放由type_descriptor描述结构体占用内存。struct_ptr指针为要释放的结构体指针。
当struct_ptr为NULL时，不执行任何操作。
返回值 无
示例 Rectangle_t *rect = ...; ASN_STRUCT_FREE(asn_DEF_Rectangle, rect); 3.2 宏定义 ASN_STRUCT_RESET() 概要 #define ASN_STRUCT_RESET(type_descriptor, struct_ptr) 描述 清空结构体指针struct_ptr的成员内容，但是不释放指针本身(还指向原来的内存，而不是指向NULL)
当 struct_ptr 为 NULL 时什么也不做。
返回值 无
示例 struct my_figure { /* The custom structure */ int flags; /* &lt;some custom member> */ /* The type is generated by the ASN.1 compiler */ Rectangle_t rect; /* other members of the structure */ }; struct my_figure *fig = ...; ASN_STRUCT_RESET(asn_DEF_Rectangle, &amp;fig->rect); 3.3 asn_check_constraints() 概要 int asn_check_constraints( const asn_TYPE_descriptor_t *type_descriptor, const void *struct_ptr, /* Target language’s structure */ char *errbuf, /* Returned error description */ size_t *errlen /* Length of the error description */ ); 描述 根据 ASN.1 规则进行数据验证。
errbuf 和 errlen 可能会被赋值，在调用此函数之前，它们应指向适当的缓冲区空间及其长度。
如果约束验证失败，则 errlen将包含 errbuf 中用于编码错误消息的实际字节数。 如果正确，则返回0.
返回值 数据校验通过返回0，否则返回-1
示例 Rectangle_t *rect = ...; char errbuf[128]; /* Buffer for error message */ size_t errlen = sizeof(errbuf); /* Size of the buffer */ int ret = asn_check_constraints(&amp;asn_DEF_Rectangle, rectangle, errbuf, &amp;errlen); /* assert(errlen &lt; sizeof(errbuf)); // Guaranteed: you may rely on that */ if(ret) { fprintf(stderr, ”Constraint validation failed: %s\n”, errbuf); } 3.4 asn_decode() 概要 asn_dec_rval_t asn_decode( const asn_codec_ctx_t *opt_codec_ctx, enum asn_transfer_syntax syntax, const asn_TYPE_descriptor_t *type_descriptor, void **struct_ptr_ptr,/* Pointer to a target structure’s ptr */ const void *buffer, /* Data to be decoded */ size_t size /* Size of that buffer */ ); 描述 根据syntax语法规则，解析大小为sizede的buffer为一个type_descriptor 类型的结构体消息。
struct_ptr_ptr 必须指向包含指向正在解码的结构(即buffer中的相同结构)的指针的内存位置。 最初通常设置 *struct_ptr_ptr 指针 到0。在这种情况下，asn_decode() 将为结构动态分配内存在解析过程中根据需要添加其成员。 如果 *struct_ptr_ptr 已经指向一些内存，asn_decode() 将根据需要分配后续成员解析 。
返回值 在不成功终止时，*struct_ptr_ptr 可能包含部分解码数据。 此数据可能对调试有用（例如通过使用 asn_fprint()）。务必通过调用 ASN_STRUCT_FREE() 或 ASN_STRUCT_RESET()释放内存。
成功的话会返回一个如下这样一个结构体:
typedef struct { enum { RC_OK, /* Decoded successfully */ RC_WMORE, /* More data expected, call again */ RC_FAIL /* Failure to decode data */ } code; /* Result code */ size_t consumed; /* Number of bytes consumed */ } asn_dec_rval_t; 重启特性(Restartability) 有一些传输语法解析器(ATS_BER))支持重启。
这意味着如果缓冲区的数据少于预期，asn_decode() 将处理可用的任何内容，并要求使用 RC_WMORE 返回 .code 提供更多数据。
请注意，在 RC_WMORE 情况下，解码器处理的数据可能比缓冲区中可用的数据少，这意味着您必须能够安排下一个缓冲区以包含前一个缓冲区未处理的部分。
RC_WMORE 代码可能仍由不支持可重启性的解析器返回。在这种情况下，部分解码的结构将被丢弃，下一次调用应使用扩展缓冲区从开始进行解析。
示例 Rectangle_t *rect = 0; /* Note this 01! */ asn_dec_rval_t rval; rval = asn_decode(0, ATS_BER, &amp;asn_DEF_Rectangle, (void **)&amp;rect, buffer, buf_size); switch(rval.code) { case RC_OK: asn_fprint(stdout, &amp;asn_DEF_Rectangle, rect); ASN_STRUCT_FREE(&amp;asn_DEF_Rectangle, rect); break; case RC_WMORE: case RC_FAIL: default: ASN_STRUCT_FREE(&amp;asn_DEF_Rectangle, rect); break; } 参考 asn_fprint()
3.5 ask_encode() 概要 #include &lt;asn_application.h>asn_enc_rval_t asn_encode( const asn_codec_ctx_t *opt_codec_ctx, enum asn_transfer_syntax syntax, const asn_TYPE_descriptor_t *type_to_encode, const void *structure_to_encode, asn_app_consume_bytes_f *callback, void *callback_key); 描述 将输入的type_to_encode结构体类型的消息structure_to_encode，以syntax的方式进行编码，通过callback函数对序列化后的数据进行处理，其中callback_key参数会被传入到callback函数。
回调的格式声明如下：
typedef int(asn_app_consume_bytes_f)(const void *buffer, size_t size, void *callback_key); 返回值 返回一个复合的结构体：
typedef struct { ssize_t encoded; const asn_TYPE_descriptor_t *failed_type; const void *structure_ptr; } asn_enc_rval_t; 如果编码不成功，.encoded 成员设置为 -1
如果编码成功，.encoded成员指定序列化输出的大小。
无论选择的 ASN.1 传输语法如何，都以字节为单位返回序列化输出大小。
出错时（当 .encoded 设置为 -1 时），errno 设置为以下值之一：
EINVAL 函数参数不正确，例如NULL。 ENOENT 编码传输语法未定义。 EBADF 结构体无效或内容限制失败。 EIO 在回调函数编码时返回了负值。 示例 static int save_to_file(const void *data, size_t size, void *key) { FILE *fp = key; return (fwrite(data, 1, size, fp) == size) ? 0 : ି1; } Rectangle_t *rect = ...; FILE *fp = ...; asn_enc_rval_t er; er = asn_encode(0, ATS_DER, &amp;asn_DEF_Rectangle, rect, save_to_file, fp); if(er.encoded == -1) { fprintf(stderr, ”Failed to encode % s\n”, asn_DEF_Rectangle.name); } else { fprintf(stderr, ”% s encoded in % zd bytes\n”, asn_DEF_Rectangle.name, er.encoded); } 3.6 asn_encode_to_buffer() 概要 #include &lt;asn_application.h>asn_enc_rval_t asn_encode_to_buffer( const asn_codec_ctx_t *opt_codec_ctx, enum asn_transfer_syntax syntax, const asn_TYPE_descriptor_t *type_to_encode, const void *structure_to_encode, void *buffer, size_t buffer_size); 描述 将输入的type_to_encode结构体类型的消息structure_to_encode，以syntax的方式进行编码至大小为buffer_siz的ebuffer中。
返回值 typedef struct { ssize_t encoded; const asn_TYPE_descriptor_t *failed_type; const void *structure_ptr; } asn_enc_rval_t; 不成功时，encoded被设置为-1；
成功时，encoded被设置为实际编码的字节数；
示例 Rectangle_t *rect = ...; uint8_t buffer[128]; asn_enc_rval_t er; er = asn_encode_to_buffer(0, ATS_DER, &amp;asn_DEF_Rectangle, rect, buffer, sizeof(buffer)); if(er.encoded == -1) { fprintf(stderr, ”Serialization of % s failed.\n”, asn_DEF_Rectangle.name); } else if(er.encoded > sizeof(buffer)) { fprintf(stderr, ”Buffer of size %zu is too small for %s, need %zu\n”, buf_size, asn_DEF_Rectangle.name, er.encoded); } 3.7 asn_encode_to_new_buffer() 概要 #include &lt;asn_application.h>typedef struct { void *buffer; /* NULL if failed to encode. */ asn_enc_rval_t result; } asn_encode_to_new_buffer_result_t; asn_encode_to_new_buffer_result_t asn_encode_to_new_buffer( const asn_codec_ctx_t *opt_codec_ctx, enum asn_transfer_syntax syntax, const asn_TYPE_descriptor_t *type_to_encode, const void *structure_to_encode); 描述 将type_to_encode类型的结构体structure_to_encode，以syntax编码方式进行编码，返回值带有编码的buffer。
返回值 失败时，buffer被设置为NULL，encoded被设置为-1；
errno如下：
EINVAL Incorrect parameters to the function, such as NULLs ENOENT Encoding transfer syntax is not defined (for this type) EBADF The structure has invalid form or content constraint failed ENOMEM Memory allocation failed due to system or internal limits 示例 asn_encode_to_new_buffer_result_t res; res = asn_encode_to_new_buffer(0, ATS_DER, &amp;asn_DEF_Rectangle, rect); if(res.buffer) { /* Encoded successfully. */ free(res.buffer); } else { fprintf(stderr, ”Failed to encode %s, estimated %zd bytes\n”, asn_DEF_Rectangle.name, res.result.encoded); } 3.8 asn_fprint() 概要 int asn_fprint(FILE *stream, /* Destination file */ const asn_TYPE_descriptor_t *type_descriptor, const void *struct_ptr /* Structure to be printed */ ); 描述 asn_fprint（） 函数打印目标语言的人类可读描述结构到由流指针指定的文档流中。
输出格式不符合任何标准。
即使对于不完整和破碎的结构体，asn_fprint（） 函数尝试生成有效的输出，这使得它更适合调试复杂的案例，而不是xer_fprint（）。
返回值 成功 0；
失败 -1；
示例 Rectangle_t *rect = ...; asn_fprint(stdout, &amp;asn_DEF_Rectangle, rect); 3.9 asn_random_fill() 概要 int asn_random_fill( const asn_TYPE_descriptor_t *type_descriptor, void **struct_ptr_ptr,/* Pointer to a target structure’s ptr */ size_t approx_max_length_limit ); 描述 根据type_descriptor类型规范，填充一个随机的struct_ptr_ptr结构体。
为了获得最佳结果，生成的代码应该在没有 -no-gen-PER 选项的情况下提供给 asn1c，使用 -no-gen-PER 选项可能会导致生成的值超出边界；
approx_max_length_limit指定结果的近似限制结构以与字节非常相似的单位表示。实际结果可能要大几倍或小于给定的长度限制。为此选择初始值的经验，则参数是采用典型结构并使用其 DER 输出大小的两倍
返回值 0 Structure was properly initialized with random data -1 Failure to initialize the structure with random data API使用示例 首先，我们在进程中包含必要的头文件。
在Rectangle中，我们包含 Rectangle.h就足够了。
#include &lt;Rectangle.h>这个头文件定义了一个ASN定义的 rectangle对应的C结构体，一个被在很多API中引用的全局的类型描述符，类型描述符一般以asn_DEF_开头，例如：
Rectangle_t *rect = ...; ASN_STRUCT_FREE(asn_DEF_Rectangle, rect); 这里定义了一个Rectangle_t类型的指针rect，这个指针使用ASN_STRUCT_FREE释放。
第二行调用了ASN_STRUCT_FREE()宏，这个宏调用Rectangle_t对应的结构体释放程序。
4.1 通用编解码 在了解特殊的编解码之前，先介绍一下通用编解码方式。
asn1c运行时支持两个高等级的接口asn_encode*和asn_decode*，可以用参数来选择编解码的语法规则。定义如下：
/* * A selection of ASN.1 Transfer Syntaxes to use with generalized * encoders and decoders declared further in this .h file. */ enum asn_transfer_syntax { /* Avoid appearance of a default transfer syntax. */ ATS_INVALID = 0, /* Plaintext output (not conforming to any standard), for debugging. */ ATS_NONSTANDARD_PLAINTEXT, /* Returns a randomly generatede structure. */ ATS_RANDOM, /* * X.690: * BER: Basic Encoding Rules. * DER: Distinguished Encoding Rules. * CER: Canonical Encoding Rules. * DER and CER are more strict variants of BER. */ ATS_BER, ATS_DER, ATS_CER, /* Only decoding is supported */ /* * X.696: * OER: Octet Encoding Rules. * CANONICAL-OER is a more strict variant of BASIC-OER. */ ATS_BASIC_OER, ATS_CANONICAL_OER, /* * X.691: * PER: Packed Encoding Rules. * CANONICAL-PER is a more strict variant of BASIC-PER. * NOTE: Produces or consumes a complete encoding (X.691 (08/2015) #11.1). */ ATS_UNALIGNED_BASIC_PER, ATS_UNALIGNED_CANONICAL_PER, /* * X.693: * XER: XML Encoding Rules. * CANONICAL-XER is a more strict variant of BASIC-XER. */ ATS_BASIC_XER, ATS_CANONICAL_XER }; 使用这个编解码的选择器，使编解码过程变得很通用。
编码 uint8_t buffer[128]; size_t buf_size = sizeof(buffer); asn_enc_rval_t er; er = asn_encode_to_buffer(0, ATS_DER, &amp;asn_DEF_Rectangle, buffer, buf_size); if(er.encoded > buf_size) { fprintf(stderr, ”Buffer of size %zu is too small for %s, need %zu\n”, buf_size, asn_DEF_Rectangle.name, er.encoded); } 解码 Rectangle_t *rect = 0; ... = asn_decode(0, ATS_BER, &amp;asn_DEF_Rectangle, (void **)&amp;rect,buffer, buf_size); 4.2 BER解码 基本编码规则描述了（由 ASN.1 社区）使用最广泛的方法以独立于机器的方式对给定结构进行编码和解码。其他几种编码规则（CER，DER）定义了限制性更强的BER版本，因此，通用 BER 解析器还能够解码由 CER 和 DER 编码器编码的数据。反之不可以。
ASN.1 编译器提供了通用 BER 解码器，能够解码 BER、CER和 DER 编码数据。
解码器是可重新启动的(面向数据流)，意味着当buffer中的数据少于期望的数据，解码器将处理有效数据，然后在返回值中使.code为RC_WMORE来请求更多数据。
注意，在RC_WMORE这种情况下，实际处理的数据可能会比实际情况要少(也就是不一定会完全处理完buffer中提供的所有数据)，因此在下一个buffer中需要包含上一个buffer中未处理的数据。
假设，有2个要编码的buffer，分别是100Bytes和200Bytes。
你可以使用一个300Bytes的buffer来代替这2个buffer的内容； 或者你可以像解码器提供一个100Bytes的buffer，它可能只会处理95Bytes；则下一次提供的buffer要提供5+200Bytes的buffer，其中的5Bytes是第一次没有处理的部分。 这并不像它可能的那样方便（BER编码器可能会消耗整个100字节并将这5个字节保存在一些临时存储中），但在现有基于流的情况下处理它实际上可能非常适合现有的算法。
这里有一个简单的示例：
Rectangle_t * simple_deserializer(const void *buffer, size_t buf_size) { asn_dec_rval_t rval; Rectangle_t *rect = 0; rval = asn_DEF_Rectangle.op->ber_decoder(0,&amp;asn_DEF_Rectangle,(void **)&amp;rect,buffer, buf_size, 0); if(rval.code == RC_OK) { return rect; /* Decoding succeeded */ } else { /* Free the partially decoded rectangle */ ASN_STRUCT_FREE(asn_DEF_Rectangle, rect); return 0; } } 上边这段代码定义了一个函数simple_deserializer()，它需要给定一个buffer和bufferd的大小，然后预计会返回一个指向Rectangle_t类型的指针。在内部，它试图通过ber_decoder()解析buffer中的内容到一个结构体rect。如果ber_decoder()函数没有完成解码，它会返回0(no data)，并且释放内存(这里的释放是必须的).
稍微简单一点的调用，是使用全局函数ber_decode()。
rval = ber_decode(0, &amp;asn_DEF_Rectangle, (void **)&amp;rect, buffer,buf_size); 这里注意使用ber_decode()调用时，最后的参数0不必要。
这两种调用方式是完全等效的。
BER decoder 的解码也可能会失败，返回值：
RC_WMORE: 需要在下一个数据流提供更多的数据 RC_FAIL: 解码失败 其他 4.3 DER编码 可分辨编码规则是 BER 编码规则的规范变体。DER最适合于对事先知道所有长度的结构进行编码。
与 BER 解码器一样，DER 编码器可以直接从 ASN.1 类型调用描述符（asn_DEF_Rectangle），这更简单一些：
/* * This is the serializer itself. * It supplies the DER encoder with the * pointer to the custom output function. */ ssize_t simple_serializer(FILE *ostream, Rectangle_t *rect) { asn_enc_rval_t er; /* Encoder return value */ er = der_encode(&amp;asn_DEF_Rect, rect, write_stream, ostream); if(er.encoded == -1) { fprintf(stderr, ”Cannot encode %s: %s\n”, er.failed_type ->name, strerror(errno)); return -1; } else { /* Return the number of bytes */ return er.encoded; } } 正如我们所看到的，der_encode()不会将写入任何buffer，而是通过调用自定义的函数(可能会调用多次)，将数据进行适当的存储。app_key参数对于der_encode()是不可见的，只由自定义函数来调用。
如果未给出自定义写入函数（作为 0 传递），则 DER 编码器基本上将执行相同的操作（即对数据进行编码），但不会调用任何回调（数据无处可去）。在确定结构编码的大小之前可能很有用.
4.4 XER编码 XER全称是XML Encoding Rules，即XML编码规则。XML是一种基本的信息交换格式，是一种可拓展的标记语言。编码器有两种类型：stdio-base和回调。使用回调的方式，编码器的处理与DER类似，我们在4.3章节有介绍过。以下示例使用write_stream()的定义：
/* * This procedure generates an XML document * by invoking the XER encoder. * NOTE: Do not copy this code verbatim! * If the stdio output is necessary, * use the xer_fprint() procedure instead. * See section 4.7 on page 62. */ int print_as_XML(FILE *ostream, Rectangle_t *rect) { asn_enc_rval_t er; /* Encoder return value */ er = xer_encode(&amp;asn_DEF_Rectangle, rect, XER_F_BASIC, /* BASIC-XER or CANONICAL-XER */ write_stream, ostream); return (er.encoded ==-1) ? ି1 : 0; } 4.5 XER解码 使用XER编码的数据，随后就可以使用xer_decode()来解码：
Rectangle_t * XML_to_Rectangle(const void *buffer, size_t buf_size) { asn_dec_rval_t rval; Rectangle_t *rect = 0; rval = xer_decode(0, &amp;asn_DEF_Rectangle, (void **)&amp;rect,buffer, buf_size); if(rval.code == RC_OK) { return rect; /* Decoding succeeded */ } else { /* Free partially decoded rect */ ASN_STRUCT_FREE(asn_DEF_Rectangle, rect); } return 0; } 解码器采用BASIC-XER和CANONICAL-XER编码.
4.6 验证目标结构体 有时候结构体需要验证数据的有效性。例如，ASN.1中定义的必填字段是否被填上；另一方面，成功解码的消息数据有可能数据是有问题的。
asn_check_constraints()函数检查类型中是否存在各种隐式和显示约束条件。建议在每次解码之后和编码之前使用该接口进行校验。
4.7 打印目标结构体 在调试时，打印目标结构体，使用asn_fprint()函数。
asn_fprint(stdout, &amp;asn_DEF_Rectangle, rect); 一个使用的替代方案是使用XML格式。默认的 BASIC-XER 编码器对输出执行合理的格式化。既有用又可读。使用 xer_fprint() 函数：
xer_fprint(stdout, &amp;asn_DEF_Rectangle, rect); 4.8 释放目标结构体 释放结构体要求结构体的所有子成员也被释放，ASN_STRUCT_FREE()宏来完成这个功能。
但是，这并不总是可行的，在下边的例子中，程序定义了一个包含ASN.1结构的结构体：
struct my_figure { /* The custom structure */ int flags; /* &lt;some custom member> */ /* The type is generated by the ASN.1 compiler */ Rectangle_t rect; /* other members of the structure */ }; 如果还是用上述ASN_STRUCT_FREE()宏来进行释放，则会情况rect成员。这种情况下，使用另外一个接口ASN_STRUCT_RESET() 。两种情况的调用情况如下：
/* 1. Rectangle_t is defined within my_figure */ struct my_figure { Rectangle_t rect; } *mf = ...; /* * Freeing the Rectangle_t * without freeing the mfି >rect area. */ ASN_STRUCT_RESET(asn_DEF_Rectangle, &amp;mf ି >rect); /* 2. Rectangle_t is a stand-alone pointer */ Rectangle_t *rect = ...; /* * Freeing the Rectangle_t * and freeing the rect pointer. */ ASN_STRUCT_FREE(asn_DEF_Rectangle, rect);</content></entry><entry><title>自上而下理解内核网络(四)---sock与传输层UDP</title><url>https://mdxz2048.github.io/post/study_linux_tcp_in_linux_04/</url><categories><category>Linux内核</category></categories><tags><tag>自上而下理解内核网络</tag></tags><content type="html"> 在上一节我们介绍了内核网络在内核应用层以struct socket结构体的形式进行创建和传递。这一节，我们继续自上而下进行分析。
在进入传输层(UDP/TCP协议栈)之前，内核有一个INET协议族层，定义了struct sock结构体，将传输层的TCP/IP协议栈(struct proto)和应用层struct socket关联起来。
因为TCP协议的复杂性，我们很难在这里简单的在传输层进行分析，分析TCP协议也不是我们这里的重点，我们更关注整个Linux内核网络对数据的逐层处理，因此，我们这一节将在传输层选取UDP相关协议实现进行分析。
本节我们主要有两个任务：
分析传输层的发送流程； 分析传输层的接收流程 sock代替socket 在《深入Linux内核架构》中，作者这样描述了sock层的意义：“尽管尚未讨论sock结构，它不可避免地使人想到术语socket(套接字)，这正是我们想要的，我们现在正处于应用层的边界上，数据迟早要使用套接字传输到用户空间，就像本章开头的示例程序那样。内核中有两种数据结构表示套接字，sock是到网络访问层的接口，而socket是到用户空间的接口”。因为我们这个系列文章是自上而下描述数据的流向，以一个数据socket的建立和数据的发送为起点进行分析，从应用层到底层的对数据进行追踪，而《深入Linux内核架构》网络部分是自下而上的。因此，我们和作者的视角刚好相反，虽然都在应用层的边界，我们是往下看的，先看到的是socket，再是sock。
在从应用层进入传输层时，内核中在net/ipv4/af_inet.c中struct sock结构体来表示上一层的socket，该层向下以sock格式与传输层的TCP/UDP协议连，向上以socket的格式与用户层进行数据传输。这里有一张图可以表示INET在内核中的位置和作用：
从上图可以看到，Linux内核网络的处理主要在协议层和网络设备驱动层，因此关于sock的收发接口我们这里就不做深入研究，这一节的主要内容我们还是直接进入UDP中研究它的发送数据和接收数据。
sock发送接口 int inet_sendmsg(struct socket *sock, struct msghdr *msg, size_t size) { struct sock *sk = sock->sk; sock_rps_record_flow(sk); /* We may need to bind the socket. */ if (!inet_sk(sk)->inet_num &amp;&amp; !sk->sk_prot->no_autobind &amp;&amp; inet_autobind(sk)) return -EAGAIN; return sk->sk_prot->sendmsg(sk, msg, size); } sock接收数据 int inet_recvmsg(struct socket *sock, struct msghdr *msg, size_t size, int flags) { struct sock *sk = sock->sk; int addr_len = 0; int err; sock_rps_record_flow(sk); err = sk->sk_prot->recvmsg(sk, msg, size, flags &amp; MSG_DONTWAIT, flags &amp; ~MSG_DONTWAIT, &amp;addr_len); if (err >= 0) msg->msg_namelen = addr_len; return err; } 传输层之UDP发送 传输层相较于应用层简单的数据检验，功能要复杂很多，我们这里选取相比之下更简单的UDP发送来进行分析。首先，这里接上一节的sendto发送流程图继续向下分析，我们可以得到如下调用图。
通过上图，我们可以看到在从INET协议族层之后，进入了传输层UDP协议层，该层发送入口是udp_sendmsg，这是一个比较长的函数我们接下来分析它，它的源代码位于net/ipv4/udp.c
检查corked 最开始，代码进行一些变量的赋值和flag的基本检查之后，检查了当前up->pending，当这个socket是被阻塞的时候，程序直接goto跳转至末尾的do_append_data处，这个我们稍后分析；
int udp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len) { /* * Check the flags. */ if (msg->msg_flags &amp; MSG_OOB) /* Mirror BSD error message compatibility */ return -EOPNOTSUPP; ipc.opt = NULL; ipc.tx_flags = 0; ipc.ttl = 0; ipc.tos = -1; getfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag; fl4 = &amp;inet->cork.fl.u.ip4; if (up->pending) { /* * There are pending frames. * The socket lock must be held while it's corked. */ lock_sock(sk); if (likely(up->pending)) { if (unlikely(up->pending != AF_INET)) { release_sock(sk); return -EINVAL; } goto do_append_data; } release_sock(sk); } 这里将socket设置成阻塞corked有2个途径：
通过setsockopt系统调用设置socket的UDP_CORK配置项； 在程序中调用send、sendto和sendmsg时，通过设置flags的MSG_MORE选项进行指定； 获取socket目的地址和端口 socket的目的地址可能有2个来源：
socket由于在某个时刻被connect，它本身存储有目的地址和端口； 地址被通过辅助结构体传递，例如我们看到的sendto调用的时候，会进行指定； 接下来，我们看内核中的处理；
/* * Get and verify the address. */ if (msg->msg_name) { DECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name); if (msg->msg_namelen &lt; sizeof(*usin)) return -EINVAL; if (usin->sin_family != AF_INET) { if (usin->sin_family != AF_UNSPEC) return -EAFNOSUPPORT; } daddr = usin->sin_addr.s_addr; dport = usin->sin_port; if (dport == 0) return -EINVAL; } else { if (sk->sk_state != TCP_ESTABLISHED) return -EDESTADDRREQ; daddr = inet->inet_daddr; dport = inet->inet_dport; /* Open fast path for connected socket. Route will not be used, if at least one option is set. */ connected = 1; } 在之前，我们调用sendto接口的时候，内核中填充了一个结构体struct msghdr，这里展示的就是如何解析这个结构体，来获取其中的目的地址和端口；
如果在到达这个函数的时候，内核没有安排一个struct msghdr，也就无法从上一步中解析出地址和端口，我们就进入了else的判断范围，这里UDP协议中有一个TCP_ESTABLISHED，用来描述一个socket的好坏，如果是被连接的socket，这里也可以获取目的地址和端口，并且将connected标志位置为1；
bookkeeping和时间戳 接下来，源地址、设备号、时间戳选项将被设置(SOCK_TIMESTAMPING_TX_HARDWARE, SOCK_TIMESTAMPING_TX_SOFTWARE, SOCK_WIFI_STATUS)。
ipc.sockc.tsflags = sk->sk_tsflags; ipc.addr = inet->inet_saddr; ipc.oif = sk->sk_bound_dev_if; Ancillary messages辅助数据 sendmsg和recvmsg允许用户除了发送和接收packets之外，还可以设置辅助数据；用户可以制作一个struct msghdr结构体，将ancillary data嵌入进去。辅助数据的格式见这里。
一个比较受欢迎的例子是IP_PKTINFO，在这种情况下，sendmsg发送数据的时候允许用户设置struct in_pktinfo，该进程可以通过填写结构in_pktinfo结构中的字段来指定要在数据包上使用的源地址。这对于一个有多个IP的服务端，是一个有用的设计。这样，服务端就可以使用客户端连接的IP进行回复。
类似的，当用户调用了sendmsg发送数据的时候，还可以使用IP_TTL和IP_TOS来设置每一包数据的TTL和TOS，请注意，可以使用 setsockopt 在所有传出数据包的套接字级别设置IP_TTL和IP_TOS，而不是根据需要按数据包进行设置。Linux内核通过一个数组将TOS转换为优先级；优先级影响了数据从排队队列被发送的时间和方式。
我们可以看到这里UDP协议处理辅助数据：
if (msg->msg_controllen) { err = ip_cmsg_send(sk, msg, &amp;ipc, sk->sk_family == AF_INET6); if (unlikely(err)) { kfree(ipc.opt); return err; } if (ipc.opt) free = 1; connected = 0; } 内核中通过ip_cmsg_send来解析ancillary message，源代码在这里。
这里只要提供了辅助数据，就要把connected标记为未连接0.
自定义IP选项 接下来，sendmsg将检查用户是否通过辅助数据(Ancillary messages)指定了IP选项。如果选项被设置，则被使用。否则，使用socket中已经存在的选项；
if (!ipc.opt) { struct ip_options_rcu *inet_opt; rcu_read_lock(); inet_opt = rcu_dereference(inet->inet_opt); if (inet_opt) { memcpy(&amp;opt_copy, inet_opt, sizeof(*inet_opt) + inet_opt->opt.optlen); ipc.opt = &amp;opt_copy.opt; } rcu_read_unlock(); } 检查源路由记录，有2个源路由记录的类型：LSR和SSR如果设置了此选项，则第一个跃点地址将被记录并存储为 faddr，并且套接字将标记为“未连接”；
if (ipc.opt &amp;&amp; ipc.opt->opt.srr) { if (!daddr) return -EINVAL; faddr = ipc.opt->opt.faddr; connected = 0; } 处理 SRR 选项后，将从用户通过辅助消息设置的值或套接字当前正在使用的值中检索 TOS IP 标志。后跟检查:
SO_DONTROUTE标准，setsockopt来设置，或者 MSG_DONTROUTE被设置，当使用sendto和sendmsg时或者 is_strictroute被设置，表示需要严格的源记录路由； 然后，tos的标志位0x1 (RTO_ONLINK)被设置，connected被标志为未连接；
tos = get_rttos(&amp;ipc, inet); if (sock_flag(sk, SOCK_LOCALROUTE) || (msg->msg_flags &amp; MSG_DONTROUTE) || (ipc.opt &amp;&amp; ipc.opt->opt.is_strictroute)) { tos |= RTO_ONLINK; connected = 0; } 多播还是单拨？ 接下来，代码试图处理多播(组播)。这是一个棘手的问题，因为用户可以通过发送辅助IP_PKTINFO消息来指定从何处发送数据包的备用源地址或设备索引，如前所述。
如果目的地址是组播地址。
写入packet的设备索引将被设置为组播设备索引； packet上的源地址将被设置为组播源地址。 如果用户没有通过IP_PKTINFO来覆盖索引，则是如下处理：
if (ipv4_is_multicast(daddr)) { if (!ipc.oif) ipc.oif = inet->mc_index; if (!saddr) saddr = inet->mc_addr; connected = 0; } else if (!ipc.oif) ipc.oif = inet->uc_index; 如果不是组播，则直接设置用户索引inet->uc_index。除非用户使用IP_PKTINFO来指定。
路由 如果socket的connected状态是连接的1，则使用一个快的路径来获取路由结构体。
if (connected) rt = (struct rtable *)sk_dst_check(sk, 0); 如果套接字未连接，或者sk_dst_check检查确定路由已过时，则划入一个慢的路径生成一个新的路由结构。通过调用flowi4_init_output来为这个UDP流构建一个结构体。
if (!rt) { struct net *net = sock_net(sk); __u8 flow_flags = inet_sk_flowi_flags(sk); fl4 = &amp;fl4_stack; flowi4_init_output(fl4, ipc.oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE, sk->sk_protocol, flow_flags, faddr, saddr, dport, inet->inet_sport); 构建此流结构后，套接字及其流结构将传递到安全子系统，以便 SELinux 或 SMACK 等系统可以在流结构上设置安全 ID 值。接下来，ip_route_output_flow将调用 IP 路由代码，为此流生成路由结构：
security_sk_classify_flow(sk, flowi4_to_flowi(fl4)); rt = ip_route_output_flow(net, fl4, sk); if (IS_ERR(rt)) { err = PTR_ERR(rt); rt = NULL; if (err == -ENETUNREACH) IP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES); goto out; } 在下来这个位置，保存统计计数器和其他计数器。其含义将在下面UDP监视部分讨论。
接下来，如果路由被设置为广播，但是socket的SOCK_BROADCAST选项没有被设置，则代码终止。如果socket被认为是“connected”的，则将路由结构缓存下来。
err = -EACCES; if ((rt->rt_flags &amp; RTCF_BROADCAST) &amp;&amp; !sock_flag(sk, SOCK_BROADCAST)) goto out; if (connected) sk_dst_set(sk, dst_clone(&amp;rt->dst)); 防止ARP缓存引起的MSG_CONFIRM过时 如果用户调用send、sendto或者sendmsg的时候，指定了MSG_CONFIRM标志，协议层将进行处理：
if (msg->msg_flags&amp;MSG_CONFIRM) goto do_confirm; back_from_confirm: 这个标志指示系统验证ARP是否有效，并防止对其进行垃圾回收。dst_confirm函数只是在目标缓存条目上设置一个标志，当查询相邻缓存并找到条目时，将在很久以后检查该标志。我们稍后会再次看到这一点。此功能通常用于 UDP 网络应用进程，以减少不必要的 ARP 流量。do_confirm标签位于此函数的末尾附近，但它很简单：
do_confirm: dst_confirm(&amp;rt->dst); if (!(msg->msg_flags&amp;MSG_PROBE) || len) goto back_from_confirm; err = 0; goto out; 如果不是probe，验证完cache的条目后，返回back_from_confirm；
一旦do_confirm返回到back_from_confirm，开始处理UDP corked的问题。
uncorked UDP sockets快速路径：准备传输数据 如果UDP未请求corked，数据可以被打包到struct sk_buff，然后通过udp_send_skb发送到IP协议层。这是通过调用ip_make_skb来完成的。
通过ip_route_output_flow生成的路由结构也会被传入，它将附着在skb中，之后在IP协议层使用。
/* Lockless fast path for the non-corking case. */ if (!corkreq) { skb = ip_make_skb(sk, fl4, getfrag, msg, ulen, sizeof(struct udphdr), &amp;ipc, &amp;rt, msg->msg_flags); err = PTR_ERR(skb); if (!IS_ERR_OR_NULL(skb)) err = udp_send_skb(skb, fl4); goto out; } ip_make_skb函数将尝试构建一个skb，同时考虑到广泛的因素，例如：
MTU UDP corking (if enabled) UDP Fragmentation Offloading (UFO) 分包传输，如果UFO不受支持并且要传输的数据的大小大于MTU。 传输数据 如果没有发生错误，udp_send_skb来处理skb，将数据传入到协议栈的下一层，也就是IP协议栈。
如果发生了 错误，错误将被记录，这里我们没有深入研究。
err = PTR_ERR(skb); if (!IS_ERR_OR_NULL(skb)) err = udp_send_skb(skb, fl4); corkingUDP sockets慢速路径 如果UDP socket被corked，同时先前数据没有被阻塞住，慢速路径开启：
LOCK这个socket； 检查应用错误bug：一个已经corked的socket被重复corked； cork the socket pend data lock_sock(sk); if (unlikely(up->pending)) { /* The socket is already corked while preparing it. */ /* ... which is an evident application bug. --ANK */ release_sock(sk); net_dbg_ratelimited("cork app bug 2\n"); err = -EINVAL; goto out; } /* * Now cork the socket to pend data. */ fl4 = &amp;inet->cork.fl.u.ip4; fl4->daddr = daddr; fl4->saddr = saddr; fl4->fl4_dport = dport; fl4->fl4_sport = inet->inet_sport; up->pending = AF_INET; do_append_data: up->len += ulen; err = ip_append_data(sk, fl4, getfrag, msg, ulen, sizeof(struct udphdr), &amp;ipc, &amp;rt, corkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags); if (err) udp_flush_pending_frames(sk); else if (!corkreq) err = udp_push_pending_frames(sk); else if (unlikely(skb_queue_empty(&amp;sk->sk_write_queue))) up->pending = 0; release_sock(sk); 传输层之UDP接收 在UDP层接收之前数据大致的流向如下：
udp_rcv udp_rcv的实现是在udp.c；
这里只有简单一行去调用__udp4_lib_rcv；
__udp4_lib_rcv __udp4_lib_rcv函数检查packet是否有效，然后获取UDP头、UDP数据报文长度、源地址和目的地址。接下来，会进行完整性检查和数据的校验。
在IP协议层，数据报文被优化，加上了dst_entry数据然后传递到了UDP协议层。
如果一个socket的dst_entry被找到，则__udp4_lib_rcv 将排队UDP数据包到socket；
sk = skb_steal_sock(skb); if (sk) { struct dst_entry *dst = skb_dst(skb); int ret; if (unlikely(sk->sk_rx_dst != dst)) udp_sk_rx_dst_set(sk, dst); ret = udp_queue_rcv_skb(sk, skb); sock_put(sk); /* a return value > 0 means to resubmit the input, but * it wants the return to be -protocol, or 0 */ if (ret > 0) return -ret; return 0; } 如果没有从early_demux操作连接套接字，则现在将通过调用__udp4_lib_lookup_skb来查找接收套接字。
if (rt->rt_flags &amp; (RTCF_BROADCAST|RTCF_MULTICAST)) return __udp4_lib_mcast_deliver(net, skb, uh, saddr, daddr, udptable, proto); sk = __udp4_lib_lookup_skb(skb, uh->source, uh->dest, udptable); if (sk) { int ret; if (inet_get_convert_csum(sk) &amp;&amp; uh->check &amp;&amp; !IS_UDPLITE(sk)) skb_checksum_try_convert(skb, IPPROTO_UDP, uh->check, inet_compute_pseudo); ret = udp_queue_rcv_skb(sk, skb); /* a return value > 0 means to resubmit the input, but * it wants the return to be -protocol, or 0 */ if (ret > 0) return -ret; return 0; } 在上述两种情况下，数据包都将被排队到socket；
ret = udp_queue_rcv_skb(sk, skb); sock_put(sk); 如果socket没有匹配上，或者校验和错误，则丢弃当前packet；
/* No socket. Drop packet silently, if checksum is wrong */ if (udp_lib_checksum_complete(skb)) goto csum_error; __UDP_INC_STATS(net, UDP_MIB_NOPORTS, proto == IPPROTO_UDPLITE); icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0); udp_queue_rcv_skb 此函数初始化部分如下所示：
确定该数据包关联的套接字是否为封装套接字，如果是，将数据传递到该层的处理函数； 确定该数据包是否是UDP-Lite数据，然后做完整的检查； 验证数据校验和，如果验证失败，则丢弃； 最后，我们到达接收队列逻辑，该逻辑首先检查套接字的接收队列是否已满。/net/ipv4/udp.c
if (sk_rcvqueues_full(sk, sk->sk_rcvbuf)) { __UDP_INC_STATS(sock_net(sk), UDP_MIB_RCVBUFERRORS, is_udplite); goto drop; } sk_rcvqueues_full sk_rcvqueues_full函数的功能是检查socket积压的数据长度，socket的sk_rmem_alloc来确定总长度是否超过sk_rcvbuf(就是上边代码片段的sk->sk_rcvbuf)。
/* * Take into account size of receive queue and backlog queue * Do not take into account this skb truesize, * to allow even a single big packet to come. */ static inline bool sk_rcvqueues_full(const struct sock *sk, unsigned int limit) { unsigned int qsize = sk->sk_backlog.len + atomic_read(&amp;sk->sk_rmem_alloc); return qsize > limit; } udp_queue_rcv_skb 现在已经验证了数据没有接收满，在这里继续处理数据报文。
bh_lock_sock(sk); if (!sock_owned_by_user(sk)) rc = __udp_queue_rcv_skb(sk, skb); else if (sk_add_backlog(sk, skb, sk->sk_rcvbuf)) { bh_unlock_sock(sk); goto drop; } bh_unlock_sock(sk); return rc; 这里第一步先确定socket是否有来自用户空间的系统调：
如果没有，则通过调用__udp_queue_rcv_skb加入到接收队列； 如果有，调用sk_add_backlog先暂存数据； 函数__udp_queue_rcv_skb调用__sock_queue_rcv_skb增加数据包到接收队列，如果无法将数据报添加到套接字的接收队列中，则碰撞统计信息计数器。
int __udp_queue_rcv_skb(struct sock *sk, struct sk_buff *skb) { int rc; if (inet_sk(sk)->inet_daddr) { sock_rps_save_rxhash(sk, skb); sk_mark_napi_id(sk, skb); sk_incoming_cpu_update(sk); } rc = __sock_queue_rcv_skb(sk, skb); if (rc &lt; 0) { int is_udplite = IS_UDPLITE(sk); /* Note that an ENOMEM error is charged twice */ if (rc == -ENOMEM) UDP_INC_STATS(sock_net(sk), UDP_MIB_RCVBUFERRORS, is_udplite); UDP_INC_STATS(sock_net(sk), UDP_MIB_INERRORS, is_udplite); kfree_skb(skb); trace_udp_fail_queue_rcv_skb(rc, sk); return -1; } return 0; } 网络数据通过 sock_queue_rcv 进入 socket 的接收队列。这个函数在将数据报最终送到接收队列之前，会做几件事情：
检查 socket 已分配的内存，如果超过了 receive buffer 的大小，丢弃这个包并更新计数； 等待通过套接字交付数据的进程，在sk_sleep等待队列上睡眠； 调用__skb_queue_tail 将包含分组数据的的套接字缓冲区插入到sk_receive_queue链表末端，其表头保存在特定于套接字的sock结构中； 调用sk_data_ready指向的函数(如果用标准函数sock_init_data来初始化sock实例，通常是sock_def_readable)，通知套接字有新数据到达。这会唤醒在sk_sleep队列上睡眠、等待数据到达的所有进程。 最后，所有在这个 socket 上等待数据的进程都收到一个通知，通过 sk_data_ready 通知处理函数
【参考文献】：
Monitoring and Tuning the Linux Networking Stack: Sending Data Monitoring and Tuning the Linux Networking Stack: Receiving Data LINUX内核网络中数据报在协议层的处理 Professional linux kernel architecture. (2010). 深入Linux内核架构. 人民邮电出版社.</content></entry><entry><title> 自上而下理解内核网络(三)---内核应用层的TCP通讯</title><url>https://mdxz2048.github.io/post/study_linux_tcp_in_linux_03/</url><categories><category>Linux内核</category></categories><tags><tag>自上而下理解内核网络</tag></tags><content type="html"> 在“自上而下理解内核网络(一)&mdash;TCP应用层介绍”我们介绍了一个简易的TCP server和TCP client，结合上一节中对Linux kernel中网络分层的相关知识，我们这一节展示在内核应用层的相关操作：
用户空间socket()之后内核空间做了什么事情？ 发送数据 接收数据 创建socket 不管是TCP服务端还是TCP客户端，建立的第一步都是创建socket。因此，我们这里首先展示一下，socket()之后都发生了什么？
为了方便观察，我们这里先将调用关系进行展示，然后再分析每一步的功能。调用关系如下图所示：
用户空间调用socket()函数；
int socket(int domain, int type, int protocol); 通过 socketcall系统调用，调用sys_socket()函数，这里进入内核空间。
long sys_socket(int family, int type, int protocol); 在sys_socket()中，
这里涉及到一个宏定义BUILD_BUG_ON，意思是该宏定义后的值为真，则会导致编译出错，这里用来检查常量的一致性； 在sys_socket()中，接着调用了sock_create(family, type, protocol, &amp;sock)函数；
int sock_create(int family, int type, int protocol, struct socket **res); 该函数内部没有其他任务，直接调用了函数__sock_create(current->nsproxy->net_ns, family, type, protocol, res, 0)；
int __sock_create(struct net *net, int family, int type, int protocol, struct socket **res, int kern) 在__sock_create()函数中，主要做了两件事情：申请内存和注册当前协议到全局数组net_families[NPROTO]，该数组定义在net/socket.c中，声明位于include/linux/net.h文件；
struct net_proto_family { int family; int (*create)(struct net *net, struct socket *sock, int protocol, int kern); struct module *owner; }; 申请内存调用的接口是sock_alloc()，在这里主要有3个功能
从全局变量sock_mnt中获取1个inode,sock_mnt是在sock_init()过程中获得的一个大块的空间； 通过SOCKET_I()来间接的调用宏container_of，来通过inode，获得socket的指针；关于container_of的用法，可以参考这里。 同时，这里将inode和socke两个对象联合起来。 最后，发回struct socket *； // net/socket.c /** * sock_alloc - allocate a socket * * Allocate a new inode and socket object. The two are bound together * and initialised. The socket is then returned. If we are out of inodes * NULL is returned. */ static struct vfsmount *sock_mnt __read_mostly; struct socket *sock_alloc(void) { struct inode *inode; struct socket *sock; inode = new_inode_pseudo(sock_mnt->mnt_sb); if (!inode) return NULL; sock = SOCKET_I(inode); kmemcheck_annotate_bitfield(sock, type); inode->i_ino = get_next_ino(); inode->i_mode = S_IFSOCK | S_IRWXUGO; inode->i_uid = current_fsuid(); inode->i_gid = current_fsgid(); inode->i_op = &amp;sockfs_inode_ops; this_cpu_add(sockets_in_use, 1); return sock; } 到这里，sock_create()就执行完成了，接下来执行sock_map_fd()函数。
static int sock_map_fd(struct socket *sock, int flags); map_sock_fd主要用于对socket的file指针初始化，经过sock_map_fd()操作后，socket就通过其**file*指针与VFS管理的文件进行了关联，便可以进行文件的各种操作，如read、write、lseek、ioctl等.
static int sock_map_fd(struct socket *sock, int flags) { struct file *newfile; int fd = get_unused_fd_flags(flags); if (unlikely(fd &lt; 0)) return fd; newfile = sock_alloc_file(sock, flags, NULL); if (likely(!IS_ERR(newfile))) { fd_install(fd, newfile); return fd; } put_unused_fd(fd); return PTR_ERR(newfile); } 至此，一个socket的创建就完成了，最终，返回到应用层的socket()就是一个socket的文件描述符。
发送数据 用户空间在发送数据时，可以调用write接口直接写入，或者使用与网络有关的接口send、sendto函数。
这些函数的控制流在内核中的某个位置会合并为一，因此，我们这里以网络有关的send和sendto接口为例，查看在应用层发送函数的控制流。
为了方便观察send&amp;sendto，我们这里先将调用关系进行展示，然后再分析每一步的功能。调用关系如下图所示：
当在应用层调用send或者sendto的时候，首先会进入glibc，通过标准库的调用，会调用sys_send（）和sys_sendto()；
在sys_send()的系统调用实现中，我们可以看到在调用中直接调用了sys_sendto()函数；
现在，我们知道了在sys_send()和sys_sendto()函数一开始，就都进入了sys_sendto()函数的入口。
//pathname:net/socket.c /* * Send a datagram down a socket. */ SYSCALL_DEFINE4(send, int, fd, void __user *, buff, size_t, len, unsigned int, flags) { return sys_sendto(fd, buff, len, flags, NULL, 0); } 我们在进入sys_sendto()函数之前，这里展示一下send()和sendto()的函数声明，要明确的是，在send()声明中，是没有入参目的地址dest_addr；
ssize_t send(int sockfd, const void *buf, size_t len, int flags); ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen); 现在，我们进入sys_sendto()的函数,这里主要做了4个工作：
填充要发送的内容到msg.msg_iter；
通过入参fd查找对应的socket;
组织消息。当由sys_sendto()调用时，即addr不为空，则调用move_addr_to_kernel()将sockaddr从用户态拷贝到内核态；
int move_addr_to_kernel(void __user *uaddr, int ulen, struct sockaddr_storage *kaddr); sock_sendmsg调 用 特 定 于 协 议 的 发 送 例 程sock->ops->sendmsg 。该例程产生一个所需协议格式的分组,并转发到更低的协议层，这里一般就是传输层。
//pathname:net/socket.c /* * Send a datagram to a given address. We move the address into kernel * space and check the user space data area is readable before invoking * the protocol. */ SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len, unsigned int, flags, struct sockaddr __user *, addr, int, addr_len) { struct socket *sock; struct sockaddr_storage address; int err; struct msghdr msg; struct iovec iov; int fput_needed; err = import_single_range(WRITE, buff, len, &amp;iov, &amp;msg.msg_iter); if (unlikely(err)) return err; sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed); if (!sock) goto out; msg.msg_name = NULL; msg.msg_control = NULL; msg.msg_controllen = 0; msg.msg_namelen = 0; if (addr) { err = move_addr_to_kernel(addr, addr_len, &amp;address); if (err &lt; 0) goto out_put; msg.msg_name = (struct sockaddr *)&amp;address; msg.msg_namelen = addr_len; } if (sock->file->f_flags &amp; O_NONBLOCK) flags |= MSG_DONTWAIT; msg.msg_flags = flags; err = sock_sendmsg(sock, &amp;msg); out_put: fput_light(sock->file, fput_needed); out: return err; } 接收数据 用户层使用recv和recvfrom函数来接收socket收到的数据，在内核应用层的接收流程如下：
接下来，我们对每一步的具体工作内容进行分析。
当用户层调用recv&amp;recvfrom时，最终都会进入sys_recvfrom()函数，这个我们从recv函数的定义就可以看出；
//pathname:net/socket.c /* * Receive a datagram from a socket. */ SYSCALL_DEFINE4(recv, int, fd, void __user *, ubuf, size_t, size, unsigned int, flags) { return sys_recvfrom(fd, ubuf, size, flags, NULL, NULL); } sys_recvfrom()函数的定义如下，在内核应用层我们主要通过这个函数来进行接收消息，这里主要工作如下：
构建msghdr； 根据fd，找出对应的socket实例； 调用sock_recvmsg函数，调用特定于协议的接收函数sock->ops->recvmsg()。例如TCP使用对应的tcp_recvmsg来进行接收； 调用move_addr_to_user，将数据从内核空间复制到用户空间； //pathname:net/socket.c /* * Receive a frame from the socket and optionally record the address of the * sender. We verify the buffers are writable and if needed move the * sender address from kernel to user space. */ SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size, unsigned int, flags, struct sockaddr __user *, addr, int __user *, addr_len) { struct socket *sock; struct iovec iov; struct msghdr msg; struct sockaddr_storage address; int err, err2; int fput_needed; err = import_single_range(READ, ubuf, size, &amp;iov, &amp;msg.msg_iter); if (unlikely(err)) return err; sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed); if (!sock) goto out; msg.msg_control = NULL; msg.msg_controllen = 0; /* Save some cycles and don't copy the address if not needed */ msg.msg_name = addr ? (struct sockaddr *)&amp;address : NULL; /* We assume all kernel code knows the size of sockaddr_storage */ msg.msg_namelen = 0; msg.msg_iocb = NULL; msg.msg_flags = 0; if (sock->file->f_flags &amp; O_NONBLOCK) flags |= MSG_DONTWAIT; err = sock_recvmsg(sock, &amp;msg, flags); if (err >= 0 &amp;&amp; addr != NULL) { err2 = move_addr_to_user(&amp;address, msg.msg_namelen, addr, addr_len); if (err2 &lt; 0) err = err2; } fput_light(sock->file, fput_needed); out: return err; } import_single_range函数主要在这里实现构建msghdr的功能，函数定义如下。这里主要工作如下：
判断buf的读写合法性，这是为了保护内核的安全设置的，同时使用unlikely告诉编译器这个条件不太有可能发生，好让编译器对这个条件判断进行正确地优化； 将buf和buf大小指向对象iov，这里实际指向的是struct msghdr msg.msg_iter，后续接收到的消息都在这里； //pathname:lib/iov_iter.c int import_single_range(int rw, void __user *buf, size_t len, struct iovec *iov, struct iov_iter *i) { if (len > MAX_RW_COUNT) len = MAX_RW_COUNT; //判断buf的读写合法性 if (unlikely(!access_ok(!rw, buf, len))) return -EFAULT; //将buf和buf大小指向对象iov，这里实际指向的是struct msghdr msg.msg_iter iov->iov_base = buf; iov->iov_len = len; //填充其他字段 iov_iter_init(i, rw, iov, 1, len); return 0; } 填充完消息头之后，调用了sockfd_lookup_light()，这里主要是根据文件描述符fd获取对应的socket实例。主要做的工作如下：
调用fdget函数，根据文件描述符fd获取对应的struct fd结构体实例；
struct fd { struct file *file; unsigned int flags; }; 调用sock_from_file函数，返回file->private_data的值，这里主要指的是返回一个socket指针；
//pathname:net/socket.c struct socket *sock_from_file(struct file *file, int *err) { if (file->f_op == &amp;socket_file_ops) return file->private_data; /* set in sock_map_fd */ *err = -ENOTSOCK; return NULL; } //pathname:net/socket.c static struct socket *sockfd_lookup_light(int fd, int *err, int *fput_needed) { struct fd f = fdget(fd); struct socket *sock; *err = -EBADF; if (f.file) { sock = sock_from_file(f.file, err); if (likely(sock)) { *fput_needed = f.flags; return sock; } fdput(f); } return NULL; } 当获取到对用的socket后，调用sock_recvmsg函数，来根据特定的协议，调用具体的接收函数sock->ops->recvmsg。根据《深入理解Linux内核》中介绍，这里的接收消息处理逻辑如下：
如果接收队列(通过sock结构的receive_queue成员实现)上至少有一个分组，则移除并返回该分组； 如果接收队列是空的，显然没有数据可以传递到用户进程。在这种情况下，进程使用wait_for_packet使自身睡眠，直到数据到达； 在新数据到达时，总是调用sock结构的data_ready函数，因而进程可以在此时被唤醒； //pathname:net/socket.c int sock_recvmsg(struct socket *sock, struct msghdr *msg, int flags) { //空函数，直接return 0 int err = security_socket_recvmsg(sock, msg, msg_data_left(msg), flags); return err ?: sock_recvmsg_nosec(sock, msg, flags); } static inline int sock_recvmsg_nosec(struct socket *sock, struct msghdr *msg, int flags) { return sock->ops->recvmsg(sock, msg, msg_data_left(msg), flags); } 当通过sock_recvmsg函数接收到数据后被唤醒，数据会被放在struct msghdr msg中，此时调用move_addr_to_user函数(实际其中主要是调用copy_to_user函数)，将数据从内核空间拷贝至用户空间；
至此，一次socket的接收数据在内核应用层就完成了。
总结 最后，我们总结一下本节内容。
本节主要展示了在内核应用层一个socket如何被创建、发送和接收数据。大致内容包含如下：
创建socket sys_socket()中，调用__sock_create()函数申请内存和注册当前协议到全局数组net_families[NPROTO]； map_sock_fd主要用于对socket的file指针初始化，经过sock_map_fd()操作后，socket就通过其**file*指针与VFS管理的文件进行了关联，便可以进行文件的各种操作，如read、write、lseek、ioctl等； 一个socket的创建就完成了，最终，返回到应用层的socket()就是一个socket的文件描述符； 发送数据 sys_send()和sys_sendto()函数一开始，就都进入了sys_sendto()； 发送时，填充要发送的内容到msg.msg_iter； 通过入参fd查找对应的socket; 组织消息，调用sock_sendmsg来调 用 特 定 于 协 议 的 发 送 例 程sock->ops->sendmsg 进行发送； 接收数据 接收数据和发送数据的流程比较相似。
当用户层调用recv&amp;recvfrom时，最终都会进入sys_recvfrom()函数； 接收时，首先构建msghdr； 然后根据fd，找出对应的socket实例； 调用sock_recvmsg函数，调用特定于协议的接收函数sock->ops->recvmsg()。例如TCP使用对应的tcp_recvmsg来进行接收； 调用move_addr_to_user，将数据从内核空间复制到用户空间；</content></entry><entry><title>Linux内核中系统调用过程分析</title><url>https://mdxz2048.github.io/post/study_linux_syscall/</url><categories><category>Linux内核</category></categories><tags><tag>syscall</tag></tags><content type="html"> 系统调用是什么 系统调用是用户进程与内核交互的经典方法。POSIX标准定义了许多系统调用，以及这些系统调用在所有遵循POSIX的系统包括Linux上的语义。
传统的系统调用不同类别分类，如下所示：
进程管理：创建新进程，查询信息，调试。 信号：发送信号，定时器以及相关处理机制。 文件：创建、打开和关闭文件，从文件读取和向文件写入，查询信息和状态。 目录和文件系统：创建、删除和重命名目录，查询信息，链接，变更目录。 保护机制：读取和变更UID/GID，命名空间的处理。 定时器函数：定时器函数和统计信息。 为什么需要系统调用 首先我们从《深入Linux内核架构》中找的内核组成部分中的这张图，可以看到Linux内核的高层次概括以及完整的Linux系统中各个层次：
从图中我们可以看到，应用程序和C库运行在用户空间，Linux内核、驱动程序运行在内核空间；内核空间相较于用户空间，对包括系统、设备硬件都有更高的操作权限，因此，应用程序需要对系统内核提出一些要求(请求)时，为了保证系统的稳定性或安全不受危及，就需要一个中间人的角色，用来在用户空间和内核空间传递指令和数据，这个中间人就是系统调用。
系统调用的工作原理 从操作系统的实现和应用程序调用两个角度来看系统调用的实现过程，实现如下：
操作系统的实现过程 应用程序调用库函数(API)，例如insmod; API将系统调用号存入寄存器，然后通过软中断SWI使系统进入内核态; 内核中的中断处理函数根据系统调用号，调用对应的内核函数(系统调用); 系统调用完成相应的功能，将返回值存入寄存器，返回到中断处理函数； 中断处理函数返回到API中； API将寄存器内容返回给应用程序。 应用程序调用系统调用过程 把系统调用的编号存入寄存器； 把函数参数存入其他通用寄存器； 触发对应中断； 系统调用过程 以程序insmod为例，追踪一个系统调用过程。
这里我们的insmod的程序来自与Busybox_1.30.0，我们先从其中开始找到调用入口。
应用层调用insmod 应用层调用insmod的入口函数位于文件modutils/insmod.c
int insmod_main(int argc UNUSED_PARAM, char **argv) 经过跟踪，可以看到insmod_main()最终是调用了init_module()函数；在modutils/modutils.c中可以看到init_module()被定义成了对系统调用__NR_init_module的调用；
#define init_module(mod, len, opts) syscall(__NR_init_module, mod, len, opts) 内核定义系统调用号 在文件arch/arm/include/uapi/asm/unistd.h中，可以看到定义了系统调用号
#define __NR_init_module (__NR_SYSCALL_BASE+128) 打开内核的调用入口arch/arm/kernel/call.S，可以看到系统调用偏移量对应的是sys_init_module系统调用；
/* 125 */ CALL(sys_mprotect) CALL(sys_sigprocmask) CALL(sys_ni_syscall) /* was sys_create_module */ CALL(sys_init_module) 我们打开include/linux/syscalls.h,可以看到对sys_init_module()的声明；
asmlinkage long sys_init_module(void __user *umod, unsigned long len, const char __user *uargs); 注：
内核中实际的系统调用函数实现的函数名并没有直接采用类似sys_init_module()这种格式进行定义，而是用一类宏定义的方式来进行修饰,在编译过程中，宏会自动替换，最后的调用依然是sys_init_module()。
例如sys_init_module()一共有3个参数，则会使用下边这个宏进行修饰
#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__) 因此，在内核中直接搜索如下内容，就可以搜到实际的函数实现
SYSCALL_DEFINE3(init_module 内核的具体实现位于kernel/module.c中，入口函数比较短，就直接贴上来。到这里，内核就开始根据传参加载模块了。
SYSCALL_DEFINE3(init_module, void __user *, umod, unsigned long, len, const char __user *, uargs) { int err; struct load_info info = { }; err = may_init_module(); if (err) return err; pr_debug("init_module: umod=%p, len=%lu, uargs=%p\n", umod, len, uargs); err = copy_module_from_user(umod, len, &amp;info); if (err) return err; return load_module(&amp;info, uargs, 0); } 至此，我们的系统调用追踪完成了。因为我的内核是编译过的，所以可以看一下module.c的编译结果，可以看到符号表中在编译过程中，已经被解析成了sys_init_module，也就验证了我们前边的说法。
nm -r module.o 000056ac T sys_init_module</content></entry><entry><title> 自上而下理解内核网络(一)---TCP应用层介绍</title><url>https://mdxz2048.github.io/post/study_linux_tcp_in_linux_01/</url><categories><category>Linux内核</category></categories><tags><tag>自上而下理解内核网络</tag></tags><content type="html"> 本系列主要以TCP应用为指导，通过参考内核的网络实现，从应用层、传输层、网络层，自上而下的理解Linux内核网络设计，以加深对网络通讯内数据流传输路径的理解。
TCP协议简述 TCP协议的全称是Transmission Control Protocol，即传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通讯协议。在简化的计算机网络OSI模型中处于第四层指定的功能，UDP(用户数据报文协议)是同一层内另一个重要的传输协议。
TCP应用层通讯过程 一个简易的TCP服务端和客户端的通讯建立过程如下：
服务端 创建一个socket套接字；
int socket(int domain, int type, int protocol); 创建一个struct sockaddr_in的变量serveraddr，将socket绑定的协议簇、IP、端口等参数完善；
struct sockaddr_in serveraddr 绑定serveraddr到socket；
int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen); 监听socket上的连接。这里listen()将 socket引用的套接字标记为被动套接字，即将用于使用 accept接收传入连接请求的套接字；
int listen(int sockfd, int backlog); 等待TCP客户端的连接；
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 当有TCP客户端与服务端建立连接后，accept会返回一个新的socket，在服务端通过对新的socket进行read/write操作，就可以与TCP客户端进行消息的接收/发送。
客户端 相比服务端的建立，客户端就比较简单。
创建一个socket套接字；
int socket(int domain, int type, int protocol); 设置服务端的IP、端口到struct sockaddr *addr，与服务端建立连接；
int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen); 当连接成功后，通过socket``read/write操作，就可以与TCP客户端进行消息的接收/发送。
演示 我们在一台Ubuntu主机上编译演示代码中的server.c和client.c,然后在该主机上进行演示.
gcc server.c -o server gcc client.c -o client 执行指令./server 8888运行服务端，端口号为8888;
执行指令./client 127.0.0.1 8888，让客户端连接本机的8888端口；
./client 127.0.0.1 8888 Please enter msg: 此时可以看到服务端监听到新的连接请求；
./server 8888 server established connection with localhost (127.0.0.1) 此时在客户端输入要发送的内容"tcp test"，然后回车发送,发送完成后，可以看到服务端会进行回显。
Please enter msg: tcp test Echo from server: tcp test 此时可以看到服务端接收到的信息:
server received 9 bytes: tcp test 至此，服务端的读写演示完成。
演示代码 服务端 /* * tcpserver.c - A simple TCP echo server * usage: tcpserver &lt;port> */ #include &lt;stdio.h>#include &lt;unistd.h>#include &lt;stdlib.h>#include &lt;string.h>#include &lt;netdb.h>#include &lt;sys/types.h>#include &lt;sys/socket.h>#include &lt;netinet/in.h>#include &lt;arpa/inet.h> #define BUFSIZE 1024 /* * error - wrapper for perror */ void error(char *msg) { perror(msg); exit(1); } int main(int argc, char **argv) { int parentfd; /* parent socket */ int childfd; /* child socket */ int portno; /* port to listen on */ int clientlen; /* byte size of client's address */ struct sockaddr_in serveraddr; /* server's addr */ struct sockaddr_in clientaddr; /* client addr */ struct hostent *hostp; /* client host info */ char buf[BUFSIZE]; /* message buffer */ char *hostaddrp; /* dotted decimal host addr string */ int optval; /* flag value for setsockopt */ int n; /* message byte size */ /* * check command line arguments */ if (argc != 2) { fprintf(stderr, "usage: %s &lt;port>\n", argv[0]); exit(1); } portno = atoi(argv[1]); /* * socket: create the parent socket */ parentfd = socket(AF_INET, SOCK_STREAM, 0); if (parentfd &lt; 0) error("ERROR opening socket"); /* setsockopt: Handy debugging trick that lets * us rerun the server immediately after we kill it; * otherwise we have to wait about 20 secs. * Eliminates "ERROR on binding: Address already in use" error. */ // optval = 1; // setsockopt(parentfd, SOL_SOCKET, SO_REUSEADDR, // (const void *)&amp;optval, sizeof(int)); /* * build the server's Internet address */ bzero((char *)&amp;serveraddr, sizeof(serveraddr)); /* this is an Internet address */ serveraddr.sin_family = AF_INET; /* let the system figure out our IP address */ serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); /* this is the port we will listen on */ serveraddr.sin_port = htons((unsigned short)portno); /* * bind: associate the parent socket with a port */ if (bind(parentfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) &lt; 0) error("ERROR on binding"); /* * listen: make this socket ready to accept connection requests */ if (listen(parentfd, 5) &lt; 0) /* allow 5 requests to queue up */ error("ERROR on listen"); /* * main loop: wait for a connection request, echo input line, * then close connection. */ clientlen = sizeof(clientaddr); while (1) { /* * accept: wait for a connection request */ childfd = accept(parentfd, (struct sockaddr *)&amp;clientaddr, &amp;clientlen); if (childfd &lt; 0) error("ERROR on accept"); /* * gethostbyaddr: determine who sent the message */ hostp = gethostbyaddr((const char *)&amp;clientaddr.sin_addr.s_addr, sizeof(clientaddr.sin_addr.s_addr), AF_INET); if (hostp == NULL) error("ERROR on gethostbyaddr"); hostaddrp = inet_ntoa(clientaddr.sin_addr); if (hostaddrp == NULL) error("ERROR on inet_ntoa\n"); printf("server established connection with %s (%s)\n", hostp->h_name, hostaddrp); /* * read: read input string from the client */ bzero(buf, BUFSIZE); n = read(childfd, buf, BUFSIZE); if (n &lt; 0) error("ERROR reading from socket"); printf("server received %d bytes: %s", n, buf); /* * write: echo the input string back to the client */ n = write(childfd, buf, strlen(buf)); if (n &lt; 0) error("ERROR writing to socket"); close(childfd); } } 客户端 #include &lt;stdio.h>#include &lt;stdlib.h>#include &lt;string.h>#include &lt;unistd.h>#include &lt;sys/types.h>#include &lt;sys/socket.h>#include &lt;netinet/in.h>#include &lt;netdb.h> #define BUFSIZE 1024 /* * error - wrapper for perror */ void error(char *msg) { perror(msg); exit(0); } int main(int argc, char **argv) { int sockfd, portno, n; struct sockaddr_in serveraddr; struct hostent *server; char *hostname; char buf[BUFSIZE]; /* check command line arguments */ if (argc != 3) { fprintf(stderr,"usage: %s &lt;hostname> &lt;port>\n", argv[0]); exit(0); } hostname = argv[1]; portno = atoi(argv[2]); /* socket: create the socket */ sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd &lt; 0) error("ERROR opening socket"); /* gethostbyname: get the server's DNS entry */ server = gethostbyname(hostname); if (server == NULL) { fprintf(stderr,"ERROR, no such host as %s\n", hostname); exit(0); } /* build the server's Internet address */ bzero((char *) &amp;serveraddr, sizeof(serveraddr)); serveraddr.sin_family = AF_INET; bcopy((char *)server->h_addr, (char *)&amp;serveraddr.sin_addr.s_addr, server->h_length); serveraddr.sin_port = htons(portno); /* connect: create a connection with the server */ if (connect(sockfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) &lt; 0) error("ERROR connecting"); /* get message line from the user */ printf("Please enter msg: "); bzero(buf, BUFSIZE); fgets(buf, BUFSIZE, stdin); /* send the message line to the server */ n = write(sockfd, buf, strlen(buf)); if (n &lt; 0) error("ERROR writing to socket"); /* print the server's reply */ bzero(buf, BUFSIZE); n = read(sockfd, buf, BUFSIZE); if (n &lt; 0) error("ERROR reading from socket"); printf("Echo from server: %s", buf); close(sockfd); return 0; }</content></entry><entry><title>当我们在谈论阅读时，我们在谈论什么</title><url>https://mdxz2048.github.io/post/thoughts_worldbookday/</url><categories><category>想法</category></categories><tags><tag>世界图书与版权日</tag></tags><content type="html"> 下一周就是“五一劳动节”了，这个糟糕的调休制度导致这个周末只休息一天，更糟糕的是，重庆的夏天就要来了，早上起床，我立马关上了阳台的窗户，这样室内才勉强待得住。当然，我的富贵竹还留在阳台上，享受着每天早晨仅有一个小时的阳光。
昨天晚上我就想着，今天早上起来一定要写点什么，一方面是和“世界读书日”这个高端、边缘的节日有一丝联系，这两年来的阅读，也逐渐让我养成了读书的习惯，自己也很是庆幸。另一方面，也是想记录一下自己在这个阶段获取信息的渠道，起码在现在看来，我认为十年后的自己，一样会认可我现在对信息的过滤方式，认可我的认可和反对。
阅读 记得栋哥调侃过，“他觉得读书很丢人，因为比较穷、比较无聊的人才读书,读书是一个便宜的打发时间的方式”。我倒是很喜欢这种说法，可能是因为我内心比较谨慎，或者本身看书也没有什么目的性，这种说法更能给自己找个轻松的理由。
选书 既然决定要看书了，我是一个很忙碌的人，总是会给自己找一些事情做，所以我深知时间的宝贵。所以在选书这件事情上我主要还是靠推荐，我信任的平台和个人推荐的书，我大部分都会尝试了解。我买的书，基本都来自豆瓣书影音的推荐、播客主播的推荐或者正在看的书里提到的作品，还有一小部分是在刷手机的时候看到，这部分比例极少。我会把要看的书分成两大类，一类是技术类，这本书我买回来会比较少看，更多的时候我会同时在zlib这类网站去再下一本电子版的盗版，技术类的书我还是更倾向于查PDF文档，除非向《程序员的自我修养》这种书我才可能会真正翻一翻；另一类书就是课外书了，课外书我又把它们分成了两个子类，一类是小说，现在更倾向于在kindle上直接借阅。另一类是其他一些心理学、社会学之类的不适合在kindle上看的，后续可能会重新翻开第二遍的书，我一般会选择买实体书回来，这其中也有一部分是新书，kindle没法借阅，只能买实体书，当然我看书的时间很少，这种情况我也不怎么遇得到。
我把自己从选书、买书做了一张图，基本就是我当前阅读的flow了。
看书，突然觉得把“阅读”、“读书”这些字眼换成“看书”之后，写起来舒服多了，感觉一下子亲切起来了，终于开始说人话了。关于看书我最近还是有一点心得，那就是只要你愿意挤时间出来，一定就会有时间。可能是《飘》写的确实吸引人，近一段时间，我基本上可以保持每天四十分钟以上的阅读时长。这对于日常要工作和学习的我来说，有这么多时间我很满足。我现在的通勤十分规律，上午7点17分进地铁安检，19分上地铁，开始在kindle上看书，基本上7点42下车。中午吃饭时间不是很固定(之前因为吃饭溜早了被领导逮到)，所以中午可能只会有10-20分钟的时间来看书，下班的时候也是一样的时长。这样的通勤，可以保证在不影响晚上其他事情的前提下，每天挤出来至少四十分钟的时间来看书，我已经相当满足了，除了看书本身的魅力之外，还有一种和生命在抢夺时间中获胜的乐趣。
总结，在看书方面，我没有像我在工作中那样热爱总结，所以所谓的读书笔记都分散在各种地方，有的在锤子便签，有的在备忘录，最近还有一个新的笔记软件，终于让我把kindle里的笔记体面的导出去了，也很满意这个软件(糯词笔记)。虽然我笔记很乱，但我打算一直这样。因为，在之前我已经决定了，不再把时间浪费在学习折腾工具上，所以后边我会偏向于先记录，哪怕记录的到处都是，等到有一天，我找到合适的方式把它们再收集起来就是了。在这之前，我还是会在备忘录、在某处存放我的读书笔记们。
写在最后,很庆幸我从事的行业是软件开发（也就是程序员？），因为计算机领域的广度和深度，能够让我在这个嘈杂的环境中，有一个可以深入学习和研究的方向，并且可以预见的是，这些东西能够很体面的养活着我，这是我足够幸运的地方。也让我养成了对知识的尊重和敬畏，让我保持好奇心去了解更多的计算机知识，养成了这种阅读的习惯，希望一直保持好奇心，继续学习。</content></entry><entry><title>在Linux上安装ResilioSync</title><url>https://mdxz2048.github.io/post/installresiliosynconlinux/</url><categories><category>工具教程</category></categories><tags><tag>ResilioSync</tag><tag>文件同步</tag></tags><content type="html"> 本文主要介绍如何在Linux上安装ResilioSync。
我日常主要使用3台Windows电脑。3台都安装ResilioSync软件，用来同步特定的文件夹。目前的主要问题是，需要其中至少有1台电脑保持开机并联网，才可以在另外一台电脑上同步之前的文件。因此，决定将树莓派装上ResilioSync软件，加入到我这个P2P网络中来，作为那个一直开机的设备。
准备工作 树莓派3B+ SD卡8GB+ SD卡烧录器 其他 使用说明 树莓派系统安装 这里我使用的Linux发行版本是Ubuntu Server 20.04.4 LTS。 使用balenaEtcher或者其他烧录软件将下载的系统镜像解压到SD卡中，这里网上教程很多，大家不清楚的可以搜一下； 部署ResilioSync 下载安装 在这里下载的版本是armhf架构 ResilioSync；
执行如下指令进行安装，安装是自动完成，这里等待即可；
sudo dpkg -i resilio-sync_2.7.2.1375-1_arm64.deb 配置激活 这里使用网页(树莓派IP:8888/gui)进行配置，首次进入时会提示需要设置一个网页登陆的账号、密码，这里根据需要设置即可；
我这里配置完成后，进入网页长这样；
配置完成后，我们把对应的License文件存放到设备上，加入我这里放在目录 /home/ubuntu/rs/ResilioSyncPro.btskey;
回到网页，在右上角点击 Preference，进入 License页面，点击 Apply License,将存放license的文件添加进来；
License激活完成后，界面长这样；
接下来就可以像在客户端上一样，在网页开始同步文件了；</content></entry><entry><title>设备间文件自动同步软件---Reaillio</title><url>https://mdxz2048.github.io/post/soft_win_reaillio/</url><categories><category>软件分享</category></categories><tags><tag>文件同步</tag></tags><content type="html"> 软件名称 Resilio Sync 网址：https://www.resilio.com/individuals/
功能介绍 Resilio Sync是一款电脑间自动同步文件夹的软件。
支持局域网同步，同时支持跨网络同步 不需要第三方服务器，几乎不受存储空间和流量限制 支持多人同时同步(越多人对文件夹进行同步，则同步速度越快) 数据私有/安全性，因为数据不在云端，而是存储在本地 首页展示 使用说明 安装 前往官网下载对应平台版本(支持win、Linux、mac)，Windows版本点击这里；
下载完成后，点击安装即可，只需要在这里填写计算机名称，以便在2台计算机之间同步时快速识别；
[image.png(https://inews.gtimg.com/newsapp_ls/0/14526417392/0.jiketuchuang.png)
点击入门后即可进入软件，点击左上角➕选择对应文件夹开始共享，随即会在主界面出现共享按钮；
主机点击共享后，会弹出如下界面，复制链接在另一台安装了Resilio Sync软件的电脑上打开即可自动同步；
到这儿，就完成了两台设备之间的文件夹自动同步。
pro版本的激活下载链接。</content></entry><entry><title>pdf格式文档在线转换</title><url>https://mdxz2048.github.io/post/soft_web_ilovepdf/</url><categories><category>软件分享</category></categories><tags><tag>PDF转换</tag></tags><content type="html"> 软件名称 ilovepdf是一个免费的PDF在线转换网站。
同时可提供付费的OCR(光学字符识别 )服务。
网址：https://www.ilovepdf.com
中文：https://www.ilovepdf.com/zh-cn
功能介绍 合并PDF
拆分PDF
压缩PDF
PDF格式转换为 Word、PPT、Excel格式，其中OCR功能为付费功能
Word、PPT、Excel转换至PDF
PDF加密、解锁、修复、签名等功能
首页展示 使用说明 在线工具的使用往往都比较简单直接，这里以一篇PDF格式的论文转换为Word文档为例，演示网站的使用。
注意：在PDF格式转换为其他格式时，如果PDF格式的文档是类似于**拍照/扫描出的PDF格式，一般需要用到OCR识别技术，即通过算法识别文本内容，类似于锤子的大爆炸，或者IOS15新推出的相机文字识别**技术。
在首页点击[PDF to Word]
在弹出的页面点击[Select PDF file]，选择一个PDF文件，例如我这里选择了之前下载的一篇论文《基于BDS的RTK模式定位精度分析_杨泰朋》。
这里我不需要OCR，选择[NO OCR]，然后点击[Convert to WORD]按钮即可。 转换完成后，会弹出下载按钮，点击[Download WORD]即可。</content></entry><entry><title>一款Markdown编辑软件-Mark Text</title><url>https://mdxz2048.github.io/post/soft_win_marktext/</url><categories><category>软件分享</category></categories><tags><tag>markdown</tag><tag>marktext</tag></tags><content type="html"> 软件名称 [marktext]()是一款简单、实时预览的markdown编辑器，是一款优秀的开源软件。
功能介绍 markdown常见语法
markdown扩展语法、数学表达式(KaTeX)、表情
支持导出HTML和PDF格式文档
更换主题
直接从剪切板粘贴图像
自动上传图片至图床
主题展示 使用说明 软件的安装，直接从github下载即可，我这里也上传一份，防止大家网络问题无法下载，在公众号后台回复“mark-text”即可获取下载链接。
图床，使用图床的配置需要先选择一个图床，默认可使用SM.MS免费图床。可可以参考这里设置，使用GitHub仓库作为图床。(由于网络原因，我这里上传图片一直失败，所以用了chrome插件即刻图床来上传，非常好用)
其他地方没有特殊设置，在使用过程中发现有软件闪烁的现象，不过影响使用。这篇推送就是用mark-text编辑的，能不能作为长期markdown编辑器，还有待考验。</content></entry><entry><title>公众号分享的一些软件</title><url>https://mdxz2048.github.io/post/soft_wechat_shares/</url><categories><category>软件分享</category></categories><tags><tag>公众号分享</tag></tags><content type="html"> 由于公众号后台自动回复频繁被删除，特将2021年以前分享过的一些下载链接同步至此，如下：
Photoshop CC 2019【小智亲测】 链接 提取码：72kv VEGAS15.0安装及破解【小智亲测】 链接 提取码：5aej 屏幕录像专家【小智亲测】 链接 提取码：jiib excel合并精灵【小智亲测，更多资源请关注公众号mddxz1995】 链接 提取码：2pfb 局域网代理软件ccproxy【小智亲测】分享链接： 链接 提取码：t4b7 office2016软件及注册机【小智亲测】分享链接： 链接 提取码：rdg7 AE2018分享链接： 链接 提取码：09za AE CC2019分享链接： 链接 提取码：urp5` Premiere Pro CC2018分享链接： 链接 提取码：253r pandownload请去官网下载最新版： https://pandownload.com http://www.mddxz.top/?p=127 树莓派安装nextcloud+内网穿透 链接 提取码: i2vr</content></entry><entry><title>谷歌搜索镜像网站</title><url>https://mdxz2048.github.io/post/soft_web_googlemirrorsites/</url><categories><category>软件分享</category></categories><tags><tag>谷歌搜索</tag></tags><content type="html"> 软件介绍 分享一个由浙江大学维护的Google搜索的公益镜像网站，供大家在网络不佳的情况下使用，有条件的同学就不要使用镜像网站了，自己直接访问即可。
Google搜索的优势和一些常用搜索技巧在我之前的一篇《学会使用高级搜索命令，提高搜索引擎使用效率》教程中有过介绍，我自己一般会使用Google和Bing两个搜索引擎，一般只有在网络不佳的情况下使用Bing。
使用方法 浏览器输入地址:https://g.luciaz.me/
这时候会有一个验证页面，验证你是否来自浙江大学，这里三个问题的答案分别是：
心灵之约、水朝夕、csxy@123
填入任何一个问题的答案，点击提交，会自动跳转至搜索页面。直接使用即可：</content></entry><entry><title>如何安装正版的WIN10</title><url>https://mdxz2048.github.io/post/installgenuinewin10/</url><categories><category>工具教程</category></categories><tags><tag>Windows10</tag></tags><content type="html"> 声明 本文档首发在我的个人公众号。
文档说明 以联想威6pro为例，使用微软官方工具，安装正版Windows10操作系统。
工具说明 U盘(8GB及以上、会被格式化) Windows电脑(可以上网) 使用说明 本次安装主要分为三个步骤
这一步由工具自动完成，通过下载微软的官方工具，将U盘制作成启动盘并下载win10进U盘； 插上U盘到待安装系统的笔记本(或主机)，进入BIOS将其设置为使用U盘启动； 等待自动安装(需要至少20分钟)； 注册激活，注意安装时不分是家庭版、专业版还是企业版，由最后安装完成后的激活码决定。 教程 将U盘插入可以上网的Windows电脑，打开资源管理器(win+E)查看盘符，检查是否插入，如下图，我这里是盘符是****I。 打开浏览器，进入win10的下载界面(https://www.microsoft.com/zh-cn/software-download/windows10)，点击立即下载工具，下载完成后，打开工具。点击接受/同意协议，出现如下界面时，选择为另一台电脑创建安装介质(U盘、DVD或ISO文件)，点击下一步。 在选择版本这里保持默认即可，点击下一步。需要安装其他版本的windows10，取消下图中红框的勾选即可选择。 选择介质，意思就是想用什么来装系统，我们这里当然选择U盘，然后下一步。 选择U盘，这里可以看到你电脑上插入的所有U盘，务必选择你要用来装系统的那个U盘。这个****U盘会被格式化，文件要提前备份好。确认好就可以点击下一步啦。 接下来就软件就会自动运行，会自动制作启动盘、下载windows10到系统。这个过程比较慢，基本上需要多等个1、2个小时，主要看网速和微软服务器给不给力了。 待安装系统的电脑完全关机，将U盘插入。 这里需要将电脑设置成从U盘启动，因为你启动了要让这个U盘给你装系统，所以需要一点设置。我们是通过设置电脑的BIOS，让系统启动后从U盘加载。这里我们以联想威6pro为例，给大家演示如果查看自己的电脑设置U盘启动 查看自己的电脑型号，这个通过电脑上的标签、查看之前买的订单基本都可以找得到。然后我查到公司这台笔记本是联想的威6pro，除了长得丑点外观也还可以； **找到电脑型号后，用搜索引擎(Google搜索、百度一下这种就叫搜索引擎)搜“**电脑型号+如何设置U盘启动”，然后在搜索结果中的方法中尝试一下，一般就可以找到答案，如果找不到，就先查怎么进入BIOS，然后进入后看下一步教程。一般情况同一品牌(实际是同一主板)进入BISO方法都是一样的，所有的BIOS也大同小异(因为会写这个软件的工程师比较少、太底层了)。 一般设置方法分3步： 进入BIOS，比如我这台电脑就是开机按住Fn+F2；
关闭安全启动；
选择U盘启动(注意这里需要插上U盘)，然后保存并退出。
退出BIOS后电脑会自己进入U盘启动。这里我们只需要按确定/下一步就好啦，能到这里，基本上系统安装已经成功了一半了，接下来就可以喝杯水休息一下。 等待安装完成后，购买密钥激活即可。
至此，正版的Windows10系统安装完成。</content></entry><entry><title>IOS设备使用系统自带Airplay投屏到电脑</title><url>https://mdxz2048.github.io/post/soft_win_deeprd/</url><categories><category>软件分享</category></categories><tags><tag>投屏</tag></tags><content type="html"> 软件 蓝莓投屏
介绍 iOS和MacOS里, 使用Airplay协议, 无需安装软件, 直接镜像投屏. 安卓和Windows安装蓝莓研发的投屏发送端, 可用投屏码 一键投屏到对应接收端. 支持同时镜像电脑屏幕到多个接收端, 接收端也可以同时显示多路屏幕, 即支持一投多和多投一, 适合会议办公, PPT演示
本次主要介绍IOS设备投屏到电脑，安卓设备和win10系统使用系统自带无线显示可完成投屏。
软件下载 官网下载：http://deeprd.com
或公众号后台回复：“手机投屏”获取软件安装包
使用教程 打开获取到的软件安装包，解压安装包，效果如图所示。 双击“Blueberry-Airplay.exe”，软件会自动运行。此时可以在状态栏看到软件，效果如图所示。 保证IOS设备和PC机处于同一局域网下(连接同一WiFi)
打开IOS设备屏幕镜像，可以看到PC机，iPhone投屏后效果如图。
ipad投屏后效果如图。</content></entry><entry><title>GitHub+hexo搭建个人博客</title><url>https://mdxz2048.github.io/post/build-blog-with-hexo/</url><categories><category>工具教程</category></categories><tags><tag>hexo</tag><tag>搭建博客</tag></tags><content type="html"> 声明 本内容非原创，主要参考该博客进行验证 http://dwz.date/buw2dwz.date
感谢GitHub提供的开源服务。 感谢Hexo提供的方案。官网： https://hexo.io/hexo.io
介绍 今天介绍使用GitHub+hexo博客框架搭建个人博客的方案。优点是****完全免费、自由，缺点是只能使用静态页面展示，使用评论、上传图片其他功能时需要配合其他插件服务使用。
参考本教程，大约需要半个小时来完成安装和使用。其他高级操作需读者自行搜索教程学习。
安装Node.s和Git终端 安装Node.js，如图下载LTS版本安装包进行下载，然后像正常安装软件一样进行安装即可。下载地址https://nodejs.org/en/ **安装成功后，如图，在windows终端下输入如下指令查看是否安装成功，如下出现版本号即安装成功。**搜索cmd(命令提示符)可进入windows终端。  node -v 安装git，点击gitWindows客户端进行下载，下载完成后像安装正常软件一样进行安装即可。 如果没有GitHub账号，请查看此教程进行注册。注册GitHub账号 创建Github Pages(博客存放仓库) 打开浏览器，进入GitHub官网，登录自己的账号。 点击头像，查看自己的****username，我的用户名为mdxz2048 点击右上角加号，在下拉选项中选择****New repository创建博客仓库。 在弹出的设置页面Repository name处填写****yourusername.github.io，然后其他配置保持默认，点击Create repository。例如我的用户名为mdxz2048，就填mdxz2048.github.io。 接下来GitHub会将该仓库设为Github Pages，以后访问该域名就可以访问到该仓库的内容，我们要搭建的博客随后会被放在这里。 配置GitHub 在桌面右键鼠标，点击****git bash here进入git终端。 在终端输入如下指令，连接GitHub与本地。  git config --global user.name "mdxz2848"  git config --global user.email "zhipeng2048@gmail.com" 生成SSH key密钥。执行如下指令，然后，在C:*Users**ASUS.ssh目录会有两个文件id_**rsa和**id_rsa.pub*,打开**id_rsa.pub**，复制里面的所有内容到 SSH keys这里 的Key，Title随便填，然后Add SSH key就可以了。  ssh-keygen -t rsa -C "zhipeng2048@gmail.com" 安装hexo 首页进入任意磁盘创建文件夹，这里文件夹命名为blog,在该文件夹下鼠标右键选择Git Bash Here，执行命令：  npm install -g hexo-cli 接着执行如下指令  hexo init  npm install 新建完成后，指定文件夹的目录如下：  _config.yml 部署 在_config.yml文件，找到deploy，进行以下配置：  deploy:  type: git  repo: https://github.com/mdxz2048/mdxz2048.github.io.git  branch: master 安装部署工具，执行如下指令。  npm install hexo-deployer-git --save 使用next主题美化 在blog文件夹下鼠标右键选择Git Bash Here，然后clone next主题：  git clone https://github.com/theme-next/hexo-theme-next themes/next 更新主题NexT：  cd themes/next  git pull 切换成NexT主题，在blog根文件夹下，修改_config.yml文件中的theme：  Extensions  Plugins: https://hexo.io/plugins/  Themes: https://hexo.io/themes/  theme: next 切换后，执行如下指令清理缓存。  hexo clean 执行如下指令，查看本地部署效果。  hexo s 浏览器打开http://localhost:4000/可以看到本地部署效果。 可以文末下载我的博客配置和主题配置文件，根据自己的需求进行修改。 新建一篇文章 执行如下指令新建一个.md的文件，然后在对应路径下打开编辑。
 hexo new 文章名 执行如下指令进行部署  hexo g //生成网页文件  hexo s //localhost:4000本地预览效果  hexo d //部署 在https://mdxz2048.github.io/查看部署效果。 文中提到的软件和配置文件均可在此下载：
 链接: https://pan.baidu.com/s/1Nw-ApHdYZkqXj65h7T7qew  提取码: ssgt</content></entry><entry><title>使用树莓派部署个人网盘</title><url>https://mdxz2048.github.io/post/how-to-install-nextcloud-on-raspberry-3b+/</url><categories><category>工具教程</category></categories><tags><tag>树莓派3B+</tag><tag>nextcloud</tag></tags><content type="html"> 效果展示 准备工作 硬件：树莓派3B+、SD卡、SD卡读卡器、网线
软件：所有需要的软件点击此处下载
提取码: hv1b
(链接失效后可在我的公众号mddxz1995后台回复个人网盘获取最新链接)。
其他环境：公网IP
(若只作为局域网访问则不需要公网IP。公网IP是为了让我们的网盘可以通过外网进行访问，此处以一台阿里云作为代理服务端来演示)
搭建方案 使用开源应用nextcloud在树莓派3B+搭建网盘(也支持其他树莓派型号)实现文件的存储。优点是是支持Android、IOS设备客户端和web端访问，日常使用比较方便。 使用开源应用frp实现内网穿透的反向代理，具体是在一台有公网IP的设备上运行frp服务端，在客户端(这里指树莓派)上运行客户端，外网访问时通过服务端作为代理访问树莓派。优点是支持 tcp, udp 协议，适配了 http 和 https 应用协议，也就是可以更好的通过远程访问我们的网盘内容。 安装镜像 Next cloud提供了树莓派专用的系统镜像，我们可以从官网下载安装，同时也可以在我提供的文件中找到镜像直接安装使用。
将下载完成的镜像解压，解压后效果如图所示。(解压软件在软件及教程\解压缩软件中提供) 将SD读卡器插入电脑，打开Win32DiskImager镜像安装软件，(在软件及教程\镜像写入工具中提供) ，点击此按钮选择上一步解压出来的文件。 在设备栏选择SD卡，我这里选择H盘，选择完效果如图所示。 点击下方写入，然后等待写入完成。 等待进度条完成后，会提示写入成功。此处需要注意若电脑提示要格式化磁盘一定不要格式化。 此时SD卡被分成两个盘。为了稍后使用SSH远程登录树莓派控制台，在资源管理器中进入SD卡boot盘，右键新建/文本文档，新建一个文件名为SSH的空文档，同时删除掉文件后缀名，效果如图所示。 将SD卡插入树莓派等待启动，上电前我们将树莓派通过网线接在路由器的lan口。 等待约十分钟左右，这个时间刚好可以在刺激战场中玩一把团队竞技。 打开路由器的后台，查看树莓派的IP。 打开shell工具，点击文件/新建，协议选择SSH，主机填写树莓派IP地址，端口选择22，然后点击连接(工具在软件及教程\Xshell 、Xftp 6中提供)。 输入默认账号密码，登入控制台，登陆成功后界面如下，也可以根据提示升级新版的nextcloud。 账号：pi
密码：raspberry
打开浏览器，输入树莓派IP，此时可以看到next cloud已经开始运行，这里务必保存好NextCloudPi和NextCloud的账号密码，然后点击下方的Activate。 在弹窗中输入NextCloudPi(也就是第一个)的账号密码，然后点击登录。 如果安装了U盘，第一次运行会提示格式化U盘，也可以选择跳过。 External access栏选择No，然后跳到最后一步就可以开始使用了。 在浏览器地址栏输入树莓派IP，就进入了登陆界面，使用第二个密码登录。 如果看到如下界面就说明已经初始化成功了，此时网盘已经可以在局域网内正常使用，可在apple store和安卓应用市场搜索nextcloud下载对应终端的APP。 Frp反向代理 Frp是一款开源的反向代理软件，我们通过在阿里服务器上运行frp服务端，在树莓派上运行客户端与服务端进行连接。这样我们可以通过服务端作为代理，转发我们对树莓派的请求，以达到外网访问树莓派的目的。这里我主要参考了《FRP中文文档》和《使用frp进行内网穿透》这两篇文档。
服务端配置 在阿里后台实例/安全组 规则添加入方向端口，比如我这里添加7500/7500、7001/7001、7600/7600三个端口分别用来作为frp的服务端管理界面的访问端口、树莓派SSH连接映射端口和树莓派网盘访问端口，配置界面如图所示。 打开xshell客户端，进入阿里服务器的控制台。 执行arch如下指令，查看服务器机器架构，我的服务器是X86_64。 root@iZ2ze68uznd431fxfr63d2Z:~# arch
x86_64
下载对应的frp软件，因为GitHub国内访问速度过慢，我这里已经将服务端的软件上传至软件及教程\frp\服务端(X86_64)，随后通过ftp客户端传至设备即可，和我设备架构相同的同学可以直接使用我提供的软件，其他架构可在frp官方下载界面下载对应的软件（ftp客户端软件在软件及教程\Xshell 、Xftp 6提供）。 打开ftp软件，连接至服务器控制台，将frp服务端软件拖到服务器Dowoload目录下。 通过Xshell连接服务器后台，进入frp服务端软件的存放目录，执行如下命令，解压。 cd Download/ sudo tar -zxvf frp_0.32.0_linux_amd64.tar.gz 执行如下命令，给文件夹改个名，方便使用。 cp -r frp_0.32.0_linux_amd64 frp 执行如下命令，编辑frp的配置文件。 cd frp sudo vim frps.ini 我的服务端配置内容如下： [common] bind_port = 7000#与树莓派绑定的端口 dashboard_port = 7500#frp服务端软件运行信息展示端口 token = 12345678#树莓派与服务端的登陆口令 dashboard_user = admin#frp服务端软件运行信息展示的访问账号 dashboard_pwd = admin#frp服务端软件运行信息展示的访问密码 vhost_http_port = 10080#此处没有使用，我也没弄明白 vhost_https_port = 10443#此处没有使用，我也没弄明白
退出并保存，执行如下指令，运行frp服务端。 ./frps -c frps.ini 此时通过服务器IP:7500就可以看到frp服务端的展示信息，效果如图所示。 再执行如下指令将其运行在后台。 nohup ./frps -c frps.ini &amp; 至此，服务端已经配置完成。 客户端配置 树莓派是armv7架构，将对应的frp软件通过ftp软件拷贝到树莓派的指定目录下。 进入对应目录，和服务端操作类似，解压、重命名。 cd ~/ tar -zxvf frp_0.32.0_linux_arm.tar.gz cp -r frp_0.32.0_linux_arm frp 执行如下指令，编辑客户端配置。 sudo apt-get install vim [common] server_addr = x.x.x.x #这里填服务器IP server_port = 7000 #这里填写服务器配置中的bind_port token = 12345678 #登录口令 [smb] type = tcp local_ip = 127.0.0.1 local_port = 443 remote_port = 7600 [SSH] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000
执行如下指令，运行客户端。 ./frpc -c frpc.ini 输出如下内容，则客户端和服务端绑定成功。 2020/03/21 09:05:14 [I] [service.go:257] [f499bd2db389d748] login to server success, get run id [f499bd2db389d748], server udp port [0] 2020/03/21 09:05:14 [I] [proxy_manager.go:144] [f499bd2db389d748] proxy added: [smb SSH] 2020/03/21 09:05:14 [I] [control.go:179] [f499bd2db389d748] [smb] start proxy success 2020/03/21 09:05:14 [I] [control.go:179] [f499bd2db389d748] [SSH] start proxy success
此时在浏览器地址栏输入服务器IP:7600即可访问树莓派。 出现以上弹窗则说明已经成功访问了树莓派，只是由于next cloud的配置，限制了服务器的IP访问，此时，我们进入next cloud的配置文件，将服务器IP添加进去，然后退出保存。效果如图所示。 sudo vim /var/www/nextcloud/config/config.php 重新运行frp客户端在后台，成功后此时可通过外网进行访问。 nohup ./frpc -c frpc.ini &amp; 特别感谢
感谢next cloud、frp团队开源分享
https://github.com/fatedier/frp https://nextcloud.com/
参考文档
使用frp进行内网穿透</content></entry><entry><title>一个理工科本科毕业生的就业经历分享</title><url>https://mdxz2048.github.io/post/how-to-find-a-job/</url><categories><category>工具教程</category></categories><tags><tag>应届生</tag><tag>找工作</tag></tags><content type="html"> 如果你有兴趣打开了这篇文档，我大概可以相信你现在也是处于大四刚开始找工作的阶段，写这篇文档是因为最近身边有一些学弟学妹来问我关于找工作的事情，就正好利用周末一点时间结合自己参加校招和社招的经历，分享一点点经验给大家。有一点要说明的是，作为我个人的一些经验分享，并不一定适用于当下找工作的形势与政策，也一定不是适用于每个人，但是对于正在或者即将面临毕业的你，我相信或多或少的会有一些有参考价值。
我是自动化专业19届本科生，现在在深圳从事嵌入式计算机行业，毕业前掌握一些单片机和嵌入式linux方面的知识，有一定的C语言基础，另外还有一些实际的学生项目经验，所以我以下的分享可能更适用于有一点技术但是没有选择考研的同学作为参考。
以下我按照我找工作的安排顺序，分为校招、和社招两部分来给大家分享：
校招： 首先是关于招聘会的选择，一开始我就比较重视也算积极的参加了校招，我是在秋季学期的9月和10中旬一共参加了两次。因为考虑毕业后打算去北京，所以当时我选择了在西安一些高校参加校招(之所以没有选择北京完全是因为我对西安更加熟悉一些)
宣讲会信息的整理，参加校招需要提前了解各个学校的宣讲会信息，提前安排好行程，每个学校的校招信息在各个学校的就业信息服务网站中的宣讲会模块都会有，为了保证信息的准确性和实时性建议大家去各高校的官网去看，我会将网址附在文末。为了自己少跑一些路，我将每天的招聘信息按照各个校区(一定注意是校区，有一些学校两个校区之间可能隔两三小时车程)进行分类整理，然后再将同一时间段内(一般就是一个上午或者下午)自己想要参加的招聘信息放在一起，当时是做了表格方便自己随时查看。
其次是校招过程自己总结出的一些经验：
(1)因为很多一场招聘会的时间都在1-2个小时，所以基本上同一间教室一个时间段内一般只有2-3个宣讲会，所以可能你在这所学校感兴趣的两个宣讲会会同时在同一个时间进行宣讲，所以为了应对这种问题建议不是在本校找工作的同学尽量结伴。
(2)关于简历的制作技巧就不在这里说了，在职位这一块我建议写成就业方向，然后选择一两个从事的方向去写，因为每个企业对岗位的叫法不一样，到时候可以在简历明显的位置用笔写上岗位就可以，这里也避免了让人事小姐姐懵O。
(3)校招的流程一般不确定，笔试、面试一般都或前或后的都有可能(如果你有机会参加的话)，这个时间也很不确定，有的是当场进行，有的是电话通知，一般这个就听安排然后按照自己的选择进行安排就行。面试也主要是问一些简历和专业方面的问题，大部分都比较基础。
社招： 对于社招，我首先想抛出我的一个观点：对于第一份工作，企业给你的成长空间比待遇会更重要一些，应当在想要从事的行业去尽可能找一些更大的平台去提升自己。(当然这个目标是在待遇能满足你正常生活的前提下，毕竟这是一件长期的事情，总得每天开开心心的去工作)
社招的准备：
(1)简历一般建议多打印几份，普通黑白打印即可，基本上每家去之前都要求带简历。
(2)行程安排我这次主要使用手机的日历功能，手机会会提前提醒，也是方便安排行程。
(3)基本上大的企业面试都是一些基础的问题，我自己是做软件，做的面试题也基本是一些C语言(主要是指针、内存、常用接口、链表&hellip;)相关和三电起的基础；问题也主要是针对简历上所写的来问，基本上只要是自己做的东西一般也不会被问住。
公司的选择：
我有在北京一家公司待过一段时间，公司主要研发港口自动化方面的系统，规模在一百人左右，其实规模已经不是特别小了，虽然进去也是研发岗位，但是由于一些管理制度上的不完善，导致工作体验比较差，可见范围内也不能很好的提升自己，因此我选择了在答辩完后去深圳找工作，大概是在校运会的那一周我在深圳参加面试，相对来说深圳研发环境比北京好一些，所以我也是很快在深圳找到了工作，但是北方的同学来深圳一定得考虑好南北气候的差异是不是能接受。
另外，如果是做技术方面的同学，尽可能去争取研发岗位，哪怕刚进去是在研发岗干的是助理的活。岗位不一样想转岗难度一般会比较大，除非你是特别优秀或者选择跳槽。
平台的选择：
我一共用了三家招聘平台的APP：BOOS直聘、前程无忧(51Job)、智联直聘，现在看来后两家企业的回复会多一些，boos直聘更多的是企业主动联系你让你发简历。
写在最后： 现在正处于九月中旬，也就是秋招刚刚开始的阶段，大家完全有时间去多参加一些面试，无论是否成功给自己积累一下经验总不是件坏事。作为本科毕业生想要从事技术领域相关工作，更多的还是要真正学到一些知识、技能，这也是你找工作的资本。如果你到现在还是一张白纸什么也不会，那么以上的内容可能并不适用。
最后，真诚的希望各位能够珍惜大学最后的这段时光，尽可能到处走走，多和朋友、老师在一起聚一聚。
个人水平有限，小小的分享只希望能够帮到一二就相当满足了，仅作为参考，不建议生搬硬套。
以下是我之前整理的一些高校的就业信息网站，基本上在百度搜索“高校+就业”就会跳出来。
北方民族大学： http://jyc.nun.edu.cn/module/careers?menu_id=6598
西安理工大学： http://job.xaut.edu.cn/website/index.aspx
长安大学： http://jyzx.chd.edu.cn/
西电： http://job.xidian.edu.cn/Special/Index/100021/0
西安邮电： http://jiuye.xupt.edu.cn/
……</content></entry><entry><title>学会使用高级搜索命令，提高搜索引擎使用效率</title><url>https://mdxz2048.github.io/post/google-search-skills/</url><categories><category>工具教程</category></categories><tags><tag>搜索技巧</tag></tags><content type="html"> 如今国内搜索引擎市场经过多年来的发展也已经完成了洗牌。根据 据析趣知 提供的数据，百度搜索无疑是国内引擎竞争中的最大赢家，虽然它有很多让我们诟病的缺点，但我们大部分人还不得不边骂边从铺天盖地的广告中找出自己需要的信息。
图 1- 2019年2月中文搜索引擎使用
数据来自：2019年2月，全球&amp;中国搜索引擎市场份额排行榜-据析趣知
当然，也有人千方百计的去追求体验更好的goole搜索，也有人转战使用新生军今日有条，但是在国内百度搜索无疑是我们的主要工具，为了提高搜索引擎的使用效率，尽量避开那些不想看到的广告，快速、准确的找到需有用的信息， 我找了四个常用的百度高级搜索技巧介绍给大家。
技巧一：完全匹配符 "" 描述：使用英文双引号"&ldquo;将搜索关键词括起来，可以让搜索结果完全匹配。
举例；使用百度搜索 格力举报 和 &ldquo;格力举报&rdquo;
结论：可以明显的看到使用了 "&rdquo; 后 格力 不会和 举报 分开，这就是搜索结果完全匹配。
对比一A： 使用 格力举报 搜索结果 对比一B： 使用 &ldquo;格力举报&rdquo; 搜索结果 技巧二：排除搜索 描述：在搜索关键词后加 -排除关键词，可以在搜索结果中排除掉需要排除的关键词。
举例：使用百度搜索 格力 和 格力 -奥克斯
结论：使用了 格力 -奥克斯 搜索后很明显的结果中排除了这两天很热的格力和奥克斯的举报纠纷。
对比二A： 使用 格力 搜索结果 对比二B： 使用 格力 -奥克斯 搜索结果 技巧三：文件格式过滤 描述：在关键词后加 filetype：xxx 可以在搜索结果中只展示指定格式结果。
举例：使用百度搜索 毕业答辩 filetype:ppt 和 毕业答辩 filetype:doc
结论：在关键词后添加 filetype:文件格式 后可以明显的看到搜索结果只包含了指定格式的结果。
对比三A： 使用 毕业答辩 filetype:ppt 搜索结果 对比三B： 使用 毕业答辩 filetype:doc 搜索结果 技巧四：主题关键字包含 描述：在关键词前加 intitle: 只展示搜索结果的主题包含关键词的结果
举例：使用百度搜索 intitle:奥克斯
结论：搜索结果中主题中都包含 奥克斯
使用 intitle:奥克斯 搜索结果 当然搜索引擎高级命令不止于此，搜索引擎的也不止百度一家， 希望以此抛砖引玉，能够帮大家更自主的使用搜索引擎，快速、高效的完成每一次搜索。
欢迎感兴趣的朋友关注我的个人公众号“mddxz1995”，获取更多资源、资讯。</content></entry><entry><title>关于我</title><url>https://mdxz2048.github.io/about.html</url><categories/><tags/><content type="html"> 警惕三种怪癖 第一种怪癖：我们对已经拥有的东西迷恋到不能自拔。
第二种怪癖：是我们总是把注意力集中到自己会失去什么上，而不是会得到什么上。
第三种怪癖：是我们经常假定别人看待交易的角度和我们一样。</content></entry><entry><title>12306</title><url>https://mdxz2048.github.io/post/12306/</url><categories><category>工具教程</category></categories><tags><tag>12306bypass</tag><tag>抢票</tag></tags><content type="html"> 这两天需要买一张火车票，但是打开12306APP时候发现已经卖完了，就想着是不是要抢票软件去买加速包了，但是看到12306提示的是 候补 而不是无票，就去了解了一下这个候补的规则，真香！
首先大概说一下没有候补之前售票流程所有官方放出来的票会直接进入一个 票池 ，12306官网、客户端以及所有抢票软件都是在这个票池中买票，当没有票的时候其实大家都买不到票，但是一发现有人退票，因为软件可以一直监测票池，所以就比人有优势抢到票，当然这是 以前 。
再来看看现在有了候补制度的售票流程因为存在候补，在放出的票 进入票池之前 会先查看是否有候补订单，如果有直接根据候补订单的下单时间顺序（注意这里是直接根据订单的提交时间顺序！）将票分配给对应的订单，这样这张票就已经售出不会进入票池，当没有候补订单时才会进入票池，接下来才是各类APP和后面的乘客继续购买。
当然候补终止时间为“不晚于开车前一天的1900”，所以在这个时间节点之后候补通道关闭，也就是开车前一天的七点之后不可以进行候补，如果这时候还没有买到票就需要去票池等别人退票了，这个时间到开车前停止售票这个时间段才是12306给抢票软件留下的生存空间。
现在我们可以分析一下，候补通道有效时，抢票软件其实是在这个候补订单之后买票，相对于这个候补机制完全没有了优势。那么我们买票完全可以直接在12306官网进行购买或候补，成功率明显高于抢票软件，而且不用去到处给别人分享加速包。而在候补通道关闭后剩下那一段时间内，你可以尽情去用你喜爱的抢票软件了。</content></entry><entry><title>Windows远程桌面</title><url>https://mdxz2048.github.io/post/windows%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/</url><categories><category>工具教程</category></categories><tags><tag>远程桌面</tag></tags><content type="html"> 软件名 rdpwrap
安装平台 Windows
功能介绍 本软件为开源软件，开源地址： 激活Windows自带的远程桌面，适用于家庭版等 实现多用户远程桌面 软件下载 比百度更快的网盘：因微信公众号平台限制，请在公众号后台回复关键字“rdpWrap”获取下载链接
安装 解压压缩包后，右键以管理员身份运行install.bat执行安装脚本，然后关闭弹窗。安装成功效果如下： 右键以管理员身份运行RDPConf.exe，可以看到我这里的Windows系统版本显示不支持，没关系，这只是配置的问题，我们继续往下看。 先关掉RDPConf.exe的弹窗，在Windows桌面进行如下操作，关闭远程桌面服务。 按Win+R按键，打开服务界面。 选中Remote Desktop Services，点击停止此服务； 其他 进入RDP Wrapper安装目录，默认为C:\Program Files\RDP Wrapper，删除rdpwrap.ini配置文件，将我分享的配置文件放进来，分享的配置文件大小为179KB。 为了保险起见，我们直接进行一下升级。将我分享链接中的autoupdate.zip文件解压出来，将升级脚本放到RDP Wrapper安装目录，默认为C:\Program Files\RDP Wrapper。右键以管理员身份运行。效果如图： 升级过程比较快，执行完之后，记得回到服务中，启动远程桌面服务，效果如图： 此时，再打开RDPConf.exe检查配置，可以看到之前红色部分的警告信息都没有了，我们的电脑就可以在局域网下访问远程桌面了，效果不要舒服。 使用 在桌面，搜索远程桌面； 输入被远程访问电脑的IP，登录账号、密码即可远程访问。 账号、密码为被访问电脑的用户： 可以在设置/账户/家庭和其他用户/将其他人添加到这台电脑进行 添加。 或者将被访问的电脑锁屏，然后用本地登录的账号密码进行登录 点击连接即可登陆。 碰到其他问题，可在公众号留言或去GitHub项目下查找解决方法。</content></entry></search>
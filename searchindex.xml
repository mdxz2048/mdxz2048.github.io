<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>自上而下理解内核网络(四)---sock与传输层UDP</title><url>https://mdxz2048.github.io/post/study_linux_tcp_in_linux_04/</url><categories><category>Linux内核</category></categories><tags><tag>自上而下理解内核网络</tag></tags><content type="html"> 在上一节我们介绍了内核网络在内核应用层以struct socket结构体的形式进行创建和传递。这一节，我们继续自上而下进行分析。
在进入传输层(UDP/TCP协议栈)之前，内核有一个INET协议族层，定义了struct sock结构体，将传输层的TCP/IP协议栈(struct proto)和应用层struct socket关联起来。因为TCP协议的复杂性，我们很难在这里简单的在传输层进行分析，分析TCP协议也不是我们这里的重点，我们更关注整个Linux内核网络对数据的逐层处理，因此，我们这一节将在传输层选取UDP相关协议实现进行分析。
本节我们主要有两个任务：
分析传输层的发送流程； 分析传输层的接收流程 sock代替socket 在从应用层进入传输层时，内核中在net/ipv4/af_inet.c中struct sock结构体来表示上一层的socket，该层向下以sock格式与传输层的TCP/UDP协议连，向上以socket的格式与用户层进行数据传输。这里有一张图可以表示INET在内核中的位置和作用：
从上图可以看到，Linux内核网络的处理主要在协议层和网络设备驱动层，因此关于sock的收发接口我们这里就不做深入研究，这一节的主要内容我们还是直接进入UDP中研究它的发送数据和接收数据。
sock发送接口 int inet_sendmsg(struct socket *sock, struct msghdr *msg, size_t size) { struct sock *sk = sock->sk; sock_rps_record_flow(sk); /* We may need to bind the socket. */ if (!inet_sk(sk)->inet_num &amp;&amp; !sk->sk_prot->no_autobind &amp;&amp; inet_autobind(sk)) return -EAGAIN; return sk->sk_prot->sendmsg(sk, msg, size); } sock接收数据 int inet_recvmsg(struct socket *sock, struct msghdr *msg, size_t size, int flags) { struct sock *sk = sock->sk; int addr_len = 0; int err; sock_rps_record_flow(sk); err = sk->sk_prot->recvmsg(sk, msg, size, flags &amp; MSG_DONTWAIT, flags &amp; ~MSG_DONTWAIT, &amp;addr_len); if (err >= 0) msg->msg_namelen = addr_len; return err; } 传输层之UDP发送 传输层相较于应用层简单的数据检验，功能要复杂很多，我们这里选取相比之下更简单的UDP发送来进行分析。首先，这里接上一节的sendto发送流程图继续向下分析，我们可以得到如下调用图。
通过上图，我们可以看到在从INET协议族层之后，进入了传输层UDP协议层，该层发送入口是udp_sendmsg，这是一个比较长的函数我们接下来分析它，它的源代码位于net/ipv4/udp.c
检查corked 最开始，代码进行一些变量的赋值和flag的基本检查之后，检查了当前up->pending，当这个socket是被阻塞的时候，程序直接goto跳转至末尾的do_append_data处，这个我们稍后分析；
int udp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len) { /* * Check the flags. */ if (msg->msg_flags &amp; MSG_OOB) /* Mirror BSD error message compatibility */ return -EOPNOTSUPP; ipc.opt = NULL; ipc.tx_flags = 0; ipc.ttl = 0; ipc.tos = -1; getfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag; fl4 = &amp;inet->cork.fl.u.ip4; if (up->pending) { /* * There are pending frames. * The socket lock must be held while it's corked. */ lock_sock(sk); if (likely(up->pending)) { if (unlikely(up->pending != AF_INET)) { release_sock(sk); return -EINVAL; } goto do_append_data; } release_sock(sk); } 这里将socket设置成阻塞corked有2个途径：
通过setsockopt系统调用设置socket的UDP_CORK配置项； 在程序中调用send、sendto和sendmsg时，通过设置flags的MSG_MORE选项进行指定； 获取socket目的地址和端口 socket的目的地址可能有2个来源：
socket由于在某个时刻被connect，它本身存储有目的地址和端口； 地址被通过辅助结构体传递，例如我们看到的sendto调用的时候，会进行指定； 接下来，我们看内核中的处理；
/* * Get and verify the address. */ if (msg->msg_name) { DECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name); if (msg->msg_namelen &lt; sizeof(*usin)) return -EINVAL; if (usin->sin_family != AF_INET) { if (usin->sin_family != AF_UNSPEC) return -EAFNOSUPPORT; } daddr = usin->sin_addr.s_addr; dport = usin->sin_port; if (dport == 0) return -EINVAL; } else { if (sk->sk_state != TCP_ESTABLISHED) return -EDESTADDRREQ; daddr = inet->inet_daddr; dport = inet->inet_dport; /* Open fast path for connected socket. Route will not be used, if at least one option is set. */ connected = 1; } 在之前，我们调用sendto接口的时候，内核中填充了一个结构体struct msghdr，这里展示的就是如何解析这个结构体，来获取其中的目的地址和端口；
如果在到达这个函数的时候，内核没有安排一个struct msghdr，也就无法从上一步中解析出地址和端口，我们就进入了else的判断范围，这里UDP协议中有一个TCP_ESTABLISHED，用来描述一个socket的好坏，如果是被连接的socket，这里也可以获取目的地址和端口，并且将connected标志位置为1；
bookkeeping和时间戳 接下来，源地址、设备号、时间戳选项将被设置(SOCK_TIMESTAMPING_TX_HARDWARE, SOCK_TIMESTAMPING_TX_SOFTWARE, SOCK_WIFI_STATUS)。
ipc.sockc.tsflags = sk->sk_tsflags; ipc.addr = inet->inet_saddr; ipc.oif = sk->sk_bound_dev_if; Ancillary messages辅助数据 sendmsg和recvmsg允许用户除了发送和接收packets之外，还可以设置辅助数据；用户可以制作一个struct msghdr结构体，将ancillary data嵌入进去。辅助数据的格式见这里。
一个比较受欢迎的例子是IP_PKTINFO，在这种情况下，sendmsg发送数据的时候允许用户设置struct in_pktinfo，该进程可以通过填写结构in_pktinfo结构中的字段来指定要在数据包上使用的源地址。这对于一个有多个IP的服务端，是一个有用的设计。这样，服务端就可以使用客户端连接的IP进行回复。
类似的，当用户调用了sendmsg发送数据的时候，还可以使用IP_TTL和IP_TOS来设置每一包数据的TTL和TOS，请注意，可以使用 setsockopt 在所有传出数据包的套接字级别设置IP_TTL和IP_TOS，而不是根据需要按数据包进行设置。Linux内核通过一个数组将TOS转换为优先级；优先级影响了数据从排队队列被发送的时间和方式。
我们可以看到这里UDP协议处理辅助数据：
if (msg->msg_controllen) { err = ip_cmsg_send(sk, msg, &amp;ipc, sk->sk_family == AF_INET6); if (unlikely(err)) { kfree(ipc.opt); return err; } if (ipc.opt) free = 1; connected = 0; } 内核中通过ip_cmsg_send来解析ancillary message，源代码在这里。
这里只要提供了辅助数据，就要把connected标记为未连接0.
自定义IP选项 接下来，sendmsg将检查用户是否通过辅助数据(Ancillary messages)指定了IP选项。如果选项被设置，则被使用。否则，使用socket中已经存在的选项；
if (!ipc.opt) { struct ip_options_rcu *inet_opt; rcu_read_lock(); inet_opt = rcu_dereference(inet->inet_opt); if (inet_opt) { memcpy(&amp;opt_copy, inet_opt, sizeof(*inet_opt) + inet_opt->opt.optlen); ipc.opt = &amp;opt_copy.opt; } rcu_read_unlock(); } 检查源路由记录，有2个源路由记录的类型：LSR和SSR如果设置了此选项，则第一个跃点地址将被记录并存储为 faddr，并且套接字将标记为“未连接”；
if (ipc.opt &amp;&amp; ipc.opt->opt.srr) { if (!daddr) return -EINVAL; faddr = ipc.opt->opt.faddr; connected = 0; } 处理 SRR 选项后，将从用户通过辅助消息设置的值或套接字当前正在使用的值中检索 TOS IP 标志。后跟检查:
SO_DONTROUTE标准，setsockopt来设置，或者 MSG_DONTROUTE被设置，当使用sendto和sendmsg时或者 is_strictroute被设置，表示需要严格的源记录路由； 然后，tos的标志位0x1 (RTO_ONLINK)被设置，connected被标志为未连接；
tos = get_rttos(&amp;ipc, inet); if (sock_flag(sk, SOCK_LOCALROUTE) || (msg->msg_flags &amp; MSG_DONTROUTE) || (ipc.opt &amp;&amp; ipc.opt->opt.is_strictroute)) { tos |= RTO_ONLINK; connected = 0; } 多播还是单拨？ 接下来，代码试图处理多播(组播)。这是一个棘手的问题，因为用户可以通过发送辅助IP_PKTINFO消息来指定从何处发送数据包的备用源地址或设备索引，如前所述。
如果目的地址是组播地址。
写入packet的设备索引将被设置为组播设备索引； packet上的源地址将被设置为组播源地址。 如果用户没有通过IP_PKTINFO来覆盖索引，则是如下处理：
if (ipv4_is_multicast(daddr)) { if (!ipc.oif) ipc.oif = inet->mc_index; if (!saddr) saddr = inet->mc_addr; connected = 0; } else if (!ipc.oif) ipc.oif = inet->uc_index; 如果不是组播，则直接设置用户索引inet->uc_index。除非用户使用IP_PKTINFO来指定。
路由 如果socket的connected状态是连接的1，则使用一个快的路径来获取路由结构体。
if (connected) rt = (struct rtable *)sk_dst_check(sk, 0); 如果套接字未连接，或者sk_dst_check检查确定路由已过时，则划入一个慢的路径生成一个新的路由结构。通过调用flowi4_init_output来为这个UDP流构建一个结构体。
if (!rt) { struct net *net = sock_net(sk); __u8 flow_flags = inet_sk_flowi_flags(sk); fl4 = &amp;fl4_stack; flowi4_init_output(fl4, ipc.oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE, sk->sk_protocol, flow_flags, faddr, saddr, dport, inet->inet_sport); 构建此流结构后，套接字及其流结构将传递到安全子系统，以便 SELinux 或 SMACK 等系统可以在流结构上设置安全 ID 值。接下来，ip_route_output_flow将调用 IP 路由代码，为此流生成路由结构：
security_sk_classify_flow(sk, flowi4_to_flowi(fl4)); rt = ip_route_output_flow(net, fl4, sk); if (IS_ERR(rt)) { err = PTR_ERR(rt); rt = NULL; if (err == -ENETUNREACH) IP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES); goto out; } 在下来这个位置，保存统计计数器和其他计数器。其含义将在下面UDP监视部分讨论。
接下来，如果路由被设置为广播，但是socket的SOCK_BROADCAST选项没有被设置，则代码终止。如果socket被认为是“connected”的，则将路由结构缓存下来。
err = -EACCES; if ((rt->rt_flags &amp; RTCF_BROADCAST) &amp;&amp; !sock_flag(sk, SOCK_BROADCAST)) goto out; if (connected) sk_dst_set(sk, dst_clone(&amp;rt->dst)); 防止ARP缓存引起的MSG_CONFIRM过时 如果用户调用send、sendto或者sendmsg的时候，指定了MSG_CONFIRM标志，协议层将进行处理：
if (msg->msg_flags&amp;MSG_CONFIRM) goto do_confirm; back_from_confirm: 这个标志指示系统验证ARP是否有效，并防止对其进行垃圾回收。dst_confirm函数只是在目标缓存条目上设置一个标志，当查询相邻缓存并找到条目时，将在很久以后检查该标志。我们稍后会再次看到这一点。此功能通常用于 UDP 网络应用进程，以减少不必要的 ARP 流量。do_confirm标签位于此函数的末尾附近，但它很简单：
do_confirm: dst_confirm(&amp;rt->dst); if (!(msg->msg_flags&amp;MSG_PROBE) || len) goto back_from_confirm; err = 0; goto out; 如果不是probe，验证完cache的条目后，返回back_from_confirm；
一旦do_confirm返回到back_from_confirm，开始处理UDP corked的问题。
uncorked UDP sockets快速路径：准备传输数据 如果UDP未请求corked，数据可以被打包到struct sk_buff，然后通过udp_send_skb发送到IP协议层。这是通过调用ip_make_skb来完成的。
通过ip_route_output_flow生成的路由结构也会被传入，它将附着在skb中，之后在IP协议层使用。
/* Lockless fast path for the non-corking case. */ if (!corkreq) { skb = ip_make_skb(sk, fl4, getfrag, msg, ulen, sizeof(struct udphdr), &amp;ipc, &amp;rt, msg->msg_flags); err = PTR_ERR(skb); if (!IS_ERR_OR_NULL(skb)) err = udp_send_skb(skb, fl4); goto out; } ip_make_skb函数将尝试构建一个skb，同时考虑到广泛的因素，例如：
MTU UDP corking (if enabled) UDP Fragmentation Offloading (UFO) 分包传输，如果UFO不受支持并且要传输的数据的大小大于MTU。 传输数据 如果没有发生错误，udp_send_skb来处理skb，将数据传入到协议栈的下一层，也就是IP协议栈。
如果发生了 错误，错误将被记录，这里我们没有深入研究。
err = PTR_ERR(skb); if (!IS_ERR_OR_NULL(skb)) err = udp_send_skb(skb, fl4); corkingUDP sockets慢速路径 如果UDP socket被corked，同时先前数据没有被阻塞住，慢速路径开启：
LOCK这个socket； 检查应用错误bug：一个已经corked的socket被重复corked； cork the socket pend data lock_sock(sk); if (unlikely(up->pending)) { /* The socket is already corked while preparing it. */ /* ... which is an evident application bug. --ANK */ release_sock(sk); net_dbg_ratelimited("cork app bug 2\n"); err = -EINVAL; goto out; } /* * Now cork the socket to pend data. */ fl4 = &amp;inet->cork.fl.u.ip4; fl4->daddr = daddr; fl4->saddr = saddr; fl4->fl4_dport = dport; fl4->fl4_sport = inet->inet_sport; up->pending = AF_INET; do_append_data: up->len += ulen; err = ip_append_data(sk, fl4, getfrag, msg, ulen, sizeof(struct udphdr), &amp;ipc, &amp;rt, corkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags); if (err) udp_flush_pending_frames(sk); else if (!corkreq) err = udp_push_pending_frames(sk); else if (unlikely(skb_queue_empty(&amp;sk->sk_write_queue))) up->pending = 0; release_sock(sk); 传输层之UDP接收 在UDP层接收之前数据大致的流向如下：
udp_rcv udp_rcv的实现是在net/ipv4/udp.c；
这里只有简单一行去调用__udp4_lib_rcv；
__udp4_lib_rcv __udp4_lib_rcv函数检查packet是否有效，然后获取UDP头、UDP数据报文长度、源地址和目的地址。接下来，会进行完整性检查和数据的校验。
在IP协议层，数据报文被优化，加上了dst_entry数据然后传递到了UDP协议层。
如果一个socket的dst_entry被找到，则__udp4_lib_rcv 将排队UDP数据包到socket；
sk = skb_steal_sock(skb); if (sk) { struct dst_entry *dst = skb_dst(skb); int ret; if (unlikely(sk->sk_rx_dst != dst)) udp_sk_rx_dst_set(sk, dst); ret = udp_queue_rcv_skb(sk, skb); sock_put(sk); /* a return value > 0 means to resubmit the input, but * it wants the return to be -protocol, or 0 */ if (ret > 0) return -ret; return 0; } 如果没有从early_demux操作连接套接字，则现在将通过调用__udp4_lib_lookup_skb来查找接收套接字。
if (rt->rt_flags &amp; (RTCF_BROADCAST|RTCF_MULTICAST)) return __udp4_lib_mcast_deliver(net, skb, uh, saddr, daddr, udptable, proto); sk = __udp4_lib_lookup_skb(skb, uh->source, uh->dest, udptable); if (sk) { int ret; if (inet_get_convert_csum(sk) &amp;&amp; uh->check &amp;&amp; !IS_UDPLITE(sk)) skb_checksum_try_convert(skb, IPPROTO_UDP, uh->check, inet_compute_pseudo); ret = udp_queue_rcv_skb(sk, skb); /* a return value > 0 means to resubmit the input, but * it wants the return to be -protocol, or 0 */ if (ret > 0) return -ret; return 0; } 在上述两种情况下，数据包都将被排队到socket；
ret = udp_queue_rcv_skb(sk, skb); sock_put(sk); 如果socket没有匹配上，或者校验和错误，则丢弃当前packet；
/* No socket. Drop packet silently, if checksum is wrong */ if (udp_lib_checksum_complete(skb)) goto csum_error; __UDP_INC_STATS(net, UDP_MIB_NOPORTS, proto == IPPROTO_UDPLITE); icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0); udp_queue_rcv_skb 此函数初始化部分如下所示：
确定该数据包关联的套接字是否为封装套接字，如果是，将数据传递到该层的处理函数； 确定该数据包是否是UDP-Lite数据，然后做完整的检查； 验证数据校验和，如果验证失败，则丢弃； 最后，我们到达接收队列逻辑，该逻辑首先检查套接字的接收队列是否已满。/net/ipv4/udp.c
参考：
Monitoring and Tuning the Linux Networking Stack: Sending Data</content></entry><entry><title> 自上而下理解内核网络(三)---内核应用层的TCP通讯</title><url>https://mdxz2048.github.io/post/study_linux_tcp_in_linux_03/</url><categories><category>Linux内核</category></categories><tags><tag>自上而下理解内核网络</tag></tags><content type="html"> 在“自上而下理解内核网络(一)&mdash;TCP应用层介绍”我们介绍了一个简易的TCP server和TCP client，结合上一节中对Linux kernel中网络分层的相关知识，我们这一节展示在内核应用层的相关操作：
用户空间socket()之后内核空间做了什么事情？ 发送数据 接收数据 创建socket 不管是TCP服务端还是TCP客户端，建立的第一步都是创建socket。因此，我们这里首先展示一下，socket()之后都发生了什么？
为了方便观察，我们这里先将调用关系进行展示，然后再分析每一步的功能。调用关系如下图所示：
用户空间调用socket()函数；
int socket(int domain, int type, int protocol); 通过 socketcall系统调用，调用sys_socket()函数，这里进入内核空间。
long sys_socket(int family, int type, int protocol); 在sys_socket()中，
这里涉及到一个宏定义BUILD_BUG_ON，意思是该宏定义后的值为真，则会导致编译出错，这里用来检查常量的一致性； 在sys_socket()中，接着调用了sock_create(family, type, protocol, &amp;sock)函数；
int sock_create(int family, int type, int protocol, struct socket **res); 该函数内部没有其他任务，直接调用了函数__sock_create(current->nsproxy->net_ns, family, type, protocol, res, 0)；
int __sock_create(struct net *net, int family, int type, int protocol, struct socket **res, int kern) 在__sock_create()函数中，主要做了两件事情：申请内存和注册当前协议到全局数组net_families[NPROTO]，该数组定义在net/socket.c中，声明位于include/linux/net.h文件；
struct net_proto_family { int family; int (*create)(struct net *net, struct socket *sock, int protocol, int kern); struct module *owner; }; 申请内存调用的接口是sock_alloc()，在这里主要有3个功能
从全局变量sock_mnt中获取1个inode,sock_mnt是在sock_init()过程中获得的一个大块的空间； 通过SOCKET_I()来间接的调用宏container_of，来通过inode，获得socket的指针；关于container_of的用法，可以参考这里。 同时，这里将inode和socke两个对象联合起来。 最后，发回struct socket *； // net/socket.c /** * sock_alloc - allocate a socket * * Allocate a new inode and socket object. The two are bound together * and initialised. The socket is then returned. If we are out of inodes * NULL is returned. */ static struct vfsmount *sock_mnt __read_mostly; struct socket *sock_alloc(void) { struct inode *inode; struct socket *sock; inode = new_inode_pseudo(sock_mnt->mnt_sb); if (!inode) return NULL; sock = SOCKET_I(inode); kmemcheck_annotate_bitfield(sock, type); inode->i_ino = get_next_ino(); inode->i_mode = S_IFSOCK | S_IRWXUGO; inode->i_uid = current_fsuid(); inode->i_gid = current_fsgid(); inode->i_op = &amp;sockfs_inode_ops; this_cpu_add(sockets_in_use, 1); return sock; } 到这里，sock_create()就执行完成了，接下来执行sock_map_fd()函数。
static int sock_map_fd(struct socket *sock, int flags); map_sock_fd主要用于对socket的file指针初始化，经过sock_map_fd()操作后，socket就通过其**file*指针与VFS管理的文件进行了关联，便可以进行文件的各种操作，如read、write、lseek、ioctl等.
static int sock_map_fd(struct socket *sock, int flags) { struct file *newfile; int fd = get_unused_fd_flags(flags); if (unlikely(fd &lt; 0)) return fd; newfile = sock_alloc_file(sock, flags, NULL); if (likely(!IS_ERR(newfile))) { fd_install(fd, newfile); return fd; } put_unused_fd(fd); return PTR_ERR(newfile); } 至此，一个socket的创建就完成了，最终，返回到应用层的socket()就是一个socket的文件描述符。
发送数据 用户空间在发送数据时，可以调用write接口直接写入，或者使用与网络有关的接口send、sendto函数。
这些函数的控制流在内核中的某个位置会合并为一，因此，我们这里以网络有关的send和sendto接口为例，查看在应用层发送函数的控制流。
为了方便观察send&amp;sendto，我们这里先将调用关系进行展示，然后再分析每一步的功能。调用关系如下图所示：
当在应用层调用send或者sendto的时候，首先会进入glibc，通过标准库的调用，会调用sys_send（）和sys_sendto()；
在sys_send()的系统调用实现中，我们可以看到在调用中直接调用了sys_sendto()函数；
现在，我们知道了在sys_send()和sys_sendto()函数一开始，就都进入了sys_sendto()函数的入口。
//pathname:net/socket.c /* * Send a datagram down a socket. */ SYSCALL_DEFINE4(send, int, fd, void __user *, buff, size_t, len, unsigned int, flags) { return sys_sendto(fd, buff, len, flags, NULL, 0); } 我们在进入sys_sendto()函数之前，这里展示一下send()和sendto()的函数声明，要明确的是，在send()声明中，是没有入参目的地址dest_addr；
ssize_t send(int sockfd, const void *buf, size_t len, int flags); ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen); 现在，我们进入sys_sendto()的函数,这里主要做了4个工作：
填充要发送的内容到msg.msg_iter；
通过入参fd查找对应的socket;
组织消息。当由sys_sendto()调用时，即addr不为空，则调用move_addr_to_kernel()将sockaddr从用户态拷贝到内核态；
int move_addr_to_kernel(void __user *uaddr, int ulen, struct sockaddr_storage *kaddr); sock_sendmsg调 用 特 定 于 协 议 的 发 送 例 程sock->ops->sendmsg 。该例程产生一个所需协议格式的分组,并转发到更低的协议层，这里一般就是传输层。
//pathname:net/socket.c /* * Send a datagram to a given address. We move the address into kernel * space and check the user space data area is readable before invoking * the protocol. */ SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len, unsigned int, flags, struct sockaddr __user *, addr, int, addr_len) { struct socket *sock; struct sockaddr_storage address; int err; struct msghdr msg; struct iovec iov; int fput_needed; err = import_single_range(WRITE, buff, len, &amp;iov, &amp;msg.msg_iter); if (unlikely(err)) return err; sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed); if (!sock) goto out; msg.msg_name = NULL; msg.msg_control = NULL; msg.msg_controllen = 0; msg.msg_namelen = 0; if (addr) { err = move_addr_to_kernel(addr, addr_len, &amp;address); if (err &lt; 0) goto out_put; msg.msg_name = (struct sockaddr *)&amp;address; msg.msg_namelen = addr_len; } if (sock->file->f_flags &amp; O_NONBLOCK) flags |= MSG_DONTWAIT; msg.msg_flags = flags; err = sock_sendmsg(sock, &amp;msg); out_put: fput_light(sock->file, fput_needed); out: return err; } 接收数据 用户层使用recv和recvfrom函数来接收socket收到的数据，在内核应用层的接收流程如下：
接下来，我们对每一步的具体工作内容进行分析。
当用户层调用recv&amp;recvfrom时，最终都会进入sys_recvfrom()函数，这个我们从recv函数的定义就可以看出；
//pathname:net/socket.c /* * Receive a datagram from a socket. */ SYSCALL_DEFINE4(recv, int, fd, void __user *, ubuf, size_t, size, unsigned int, flags) { return sys_recvfrom(fd, ubuf, size, flags, NULL, NULL); } sys_recvfrom()函数的定义如下，在内核应用层我们主要通过这个函数来进行接收消息，这里主要工作如下：
构建msghdr； 根据fd，找出对应的socket实例； 调用sock_recvmsg函数，调用特定于协议的接收函数sock->ops->recvmsg()。例如TCP使用对应的tcp_recvmsg来进行接收； 调用move_addr_to_user，将数据从内核空间复制到用户空间； //pathname:net/socket.c /* * Receive a frame from the socket and optionally record the address of the * sender. We verify the buffers are writable and if needed move the * sender address from kernel to user space. */ SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size, unsigned int, flags, struct sockaddr __user *, addr, int __user *, addr_len) { struct socket *sock; struct iovec iov; struct msghdr msg; struct sockaddr_storage address; int err, err2; int fput_needed; err = import_single_range(READ, ubuf, size, &amp;iov, &amp;msg.msg_iter); if (unlikely(err)) return err; sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed); if (!sock) goto out; msg.msg_control = NULL; msg.msg_controllen = 0; /* Save some cycles and don't copy the address if not needed */ msg.msg_name = addr ? (struct sockaddr *)&amp;address : NULL; /* We assume all kernel code knows the size of sockaddr_storage */ msg.msg_namelen = 0; msg.msg_iocb = NULL; msg.msg_flags = 0; if (sock->file->f_flags &amp; O_NONBLOCK) flags |= MSG_DONTWAIT; err = sock_recvmsg(sock, &amp;msg, flags); if (err >= 0 &amp;&amp; addr != NULL) { err2 = move_addr_to_user(&amp;address, msg.msg_namelen, addr, addr_len); if (err2 &lt; 0) err = err2; } fput_light(sock->file, fput_needed); out: return err; } import_single_range函数主要在这里实现构建msghdr的功能，函数定义如下。这里主要工作如下：
判断buf的读写合法性，这是为了保护内核的安全设置的，同时使用unlikely告诉编译器这个条件不太有可能发生，好让编译器对这个条件判断进行正确地优化； 将buf和buf大小指向对象iov，这里实际指向的是struct msghdr msg.msg_iter，后续接收到的消息都在这里； //pathname:lib/iov_iter.c int import_single_range(int rw, void __user *buf, size_t len, struct iovec *iov, struct iov_iter *i) { if (len > MAX_RW_COUNT) len = MAX_RW_COUNT; //判断buf的读写合法性 if (unlikely(!access_ok(!rw, buf, len))) return -EFAULT; //将buf和buf大小指向对象iov，这里实际指向的是struct msghdr msg.msg_iter iov->iov_base = buf; iov->iov_len = len; //填充其他字段 iov_iter_init(i, rw, iov, 1, len); return 0; } 填充完消息头之后，调用了sockfd_lookup_light()，这里主要是根据文件描述符fd获取对应的socket实例。主要做的工作如下：
调用fdget函数，根据文件描述符fd获取对应的struct fd结构体实例；
struct fd { struct file *file; unsigned int flags; }; 调用sock_from_file函数，返回file->private_data的值，这里主要指的是返回一个socket指针；
//pathname:net/socket.c struct socket *sock_from_file(struct file *file, int *err) { if (file->f_op == &amp;socket_file_ops) return file->private_data; /* set in sock_map_fd */ *err = -ENOTSOCK; return NULL; } //pathname:net/socket.c static struct socket *sockfd_lookup_light(int fd, int *err, int *fput_needed) { struct fd f = fdget(fd); struct socket *sock; *err = -EBADF; if (f.file) { sock = sock_from_file(f.file, err); if (likely(sock)) { *fput_needed = f.flags; return sock; } fdput(f); } return NULL; } 当获取到对用的socket后，调用sock_recvmsg函数，来根据特定的协议，调用具体的接收函数sock->ops->recvmsg。根据《深入理解Linux内核》中介绍，这里的接收消息处理逻辑如下：
如果接收队列(通过sock结构的receive_queue成员实现)上至少有一个分组，则移除并返回该分组； 如果接收队列是空的，显然没有数据可以传递到用户进程。在这种情况下，进程使用wait_for_packet使自身睡眠，直到数据到达； 在新数据到达时，总是调用sock结构的data_ready函数，因而进程可以在此时被唤醒； //pathname:net/socket.c int sock_recvmsg(struct socket *sock, struct msghdr *msg, int flags) { //空函数，直接return 0 int err = security_socket_recvmsg(sock, msg, msg_data_left(msg), flags); return err ?: sock_recvmsg_nosec(sock, msg, flags); } static inline int sock_recvmsg_nosec(struct socket *sock, struct msghdr *msg, int flags) { return sock->ops->recvmsg(sock, msg, msg_data_left(msg), flags); } 当通过sock_recvmsg函数接收到数据后被唤醒，数据会被放在struct msghdr msg中，此时调用move_addr_to_user函数(实际其中主要是调用copy_to_user函数)，将数据从内核空间拷贝至用户空间；
至此，一次socket的接收数据在内核应用层就完成了。
总结 最后，我们总结一下本节内容。
本节主要展示了在内核应用层一个socket如何被创建、发送和接收数据。大致内容包含如下：
创建socket sys_socket()中，调用__sock_create()函数申请内存和注册当前协议到全局数组net_families[NPROTO]； map_sock_fd主要用于对socket的file指针初始化，经过sock_map_fd()操作后，socket就通过其**file*指针与VFS管理的文件进行了关联，便可以进行文件的各种操作，如read、write、lseek、ioctl等； 一个socket的创建就完成了，最终，返回到应用层的socket()就是一个socket的文件描述符； 发送数据 sys_send()和sys_sendto()函数一开始，就都进入了sys_sendto()； 发送时，填充要发送的内容到msg.msg_iter； 通过入参fd查找对应的socket; 组织消息，调用sock_sendmsg来调 用 特 定 于 协 议 的 发 送 例 程sock->ops->sendmsg 进行发送； 接收数据 接收数据和发送数据的流程比较相似。
当用户层调用recv&amp;recvfrom时，最终都会进入sys_recvfrom()函数； 接收时，首先构建msghdr； 然后根据fd，找出对应的socket实例； 调用sock_recvmsg函数，调用特定于协议的接收函数sock->ops->recvmsg()。例如TCP使用对应的tcp_recvmsg来进行接收； 调用move_addr_to_user，将数据从内核空间复制到用户空间；</content></entry><entry><title>Linux内核中系统调用过程分析</title><url>https://mdxz2048.github.io/post/study_linux_syscall/</url><categories><category>Linux内核</category></categories><tags><tag>syscall</tag></tags><content type="html"> 系统调用是什么 系统调用是用户进程与内核交互的经典方法。POSIX标准定义了许多系统调用，以及这些系统调用在所有遵循POSIX的系统包括Linux上的语义。
传统的系统调用不同类别分类，如下所示：
进程管理：创建新进程，查询信息，调试。 信号：发送信号，定时器以及相关处理机制。 文件：创建、打开和关闭文件，从文件读取和向文件写入，查询信息和状态。 目录和文件系统：创建、删除和重命名目录，查询信息，链接，变更目录。 保护机制：读取和变更UID/GID，命名空间的处理。 定时器函数：定时器函数和统计信息。 为什么需要系统调用 首先我们从《深入Linux内核架构》中找的内核组成部分中的这张图，可以看到Linux内核的高层次概括以及完整的Linux系统中各个层次：
从图中我们可以看到，应用程序和C库运行在用户空间，Linux内核、驱动程序运行在内核空间；内核空间相较于用户空间，对包括系统、设备硬件都有更高的操作权限，因此，应用程序需要对系统内核提出一些要求(请求)时，为了保证系统的稳定性或安全不受危及，就需要一个中间人的角色，用来在用户空间和内核空间传递指令和数据，这个中间人就是系统调用。
系统调用的工作原理 从操作系统的实现和应用程序调用两个角度来看系统调用的实现过程，实现如下：
操作系统的实现过程 应用程序调用库函数(API)，例如insmod; API将系统调用号存入寄存器，然后通过软中断SWI使系统进入内核态; 内核中的中断处理函数根据系统调用号，调用对应的内核函数(系统调用); 系统调用完成相应的功能，将返回值存入寄存器，返回到中断处理函数； 中断处理函数返回到API中； API将寄存器内容返回给应用程序。 应用程序调用系统调用过程 把系统调用的编号存入寄存器； 把函数参数存入其他通用寄存器； 触发对应中断； 系统调用过程 以程序insmod为例，追踪一个系统调用过程。
这里我们的insmod的程序来自与Busybox_1.30.0，我们先从其中开始找到调用入口。
应用层调用insmod 应用层调用insmod的入口函数位于文件modutils/insmod.c
int insmod_main(int argc UNUSED_PARAM, char **argv) 经过跟踪，可以看到insmod_main()最终是调用了init_module()函数；在modutils/modutils.c中可以看到init_module()被定义成了对系统调用__NR_init_module的调用；
#define init_module(mod, len, opts) syscall(__NR_init_module, mod, len, opts) 内核定义系统调用号 在文件arch/arm/include/uapi/asm/unistd.h中，可以看到定义了系统调用号
#define __NR_init_module (__NR_SYSCALL_BASE+128) 打开内核的调用入口arch/arm/kernel/call.S，可以看到系统调用偏移量对应的是sys_init_module系统调用；
/* 125 */ CALL(sys_mprotect) CALL(sys_sigprocmask) CALL(sys_ni_syscall) /* was sys_create_module */ CALL(sys_init_module) 我们打开include/linux/syscalls.h,可以看到对sys_init_module()的声明；
asmlinkage long sys_init_module(void __user *umod, unsigned long len, const char __user *uargs); 注：
内核中实际的系统调用函数实现的函数名并没有直接采用类似sys_init_module()这种格式进行定义，而是用一类宏定义的方式来进行修饰,在编译过程中，宏会自动替换，最后的调用依然是sys_init_module()。
例如sys_init_module()一共有3个参数，则会使用下边这个宏进行修饰
#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__) 因此，在内核中直接搜索如下内容，就可以搜到实际的函数实现
SYSCALL_DEFINE3(init_module 内核的具体实现位于kernel/module.c中，入口函数比较短，就直接贴上来。到这里，内核就开始根据传参加载模块了。
SYSCALL_DEFINE3(init_module, void __user *, umod, unsigned long, len, const char __user *, uargs) { int err; struct load_info info = { }; err = may_init_module(); if (err) return err; pr_debug("init_module: umod=%p, len=%lu, uargs=%p\n", umod, len, uargs); err = copy_module_from_user(umod, len, &amp;info); if (err) return err; return load_module(&amp;info, uargs, 0); } 至此，我们的系统调用追踪完成了。因为我的内核是编译过的，所以可以看一下module.c的编译结果，可以看到符号表中在编译过程中，已经被解析成了sys_init_module，也就验证了我们前边的说法。
nm -r module.o 000056ac T sys_init_module</content></entry><entry><title> 自上而下理解内核网络(一)---TCP应用层介绍</title><url>https://mdxz2048.github.io/post/study_linux_tcp_in_linux_01/</url><categories><category>Linux内核</category></categories><tags><tag>自上而下理解内核网络</tag></tags><content type="html"> 本系列主要以TCP应用为指导，通过参考内核的网络实现，从应用层、传输层、网络层，自上而下的理解Linux内核网络设计，以加深对网络通讯内数据流传输路径的理解。
TCP协议简述 TCP协议的全称是Transmission Control Protocol，即传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通讯协议。在简化的计算机网络OSI模型中处于第四层指定的功能，UDP(用户数据报文协议)是同一层内另一个重要的传输协议。
TCP应用层通讯过程 一个简易的TCP服务端和客户端的通讯建立过程如下：
服务端 创建一个socket套接字；
int socket(int domain, int type, int protocol); 创建一个struct sockaddr_in的变量serveraddr，将socket绑定的协议簇、IP、端口等参数完善；
struct sockaddr_in serveraddr 绑定serveraddr到socket；
int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen); 监听socket上的连接。这里listen()将 socket引用的套接字标记为被动套接字，即将用于使用 accept接收传入连接请求的套接字；
int listen(int sockfd, int backlog); 等待TCP客户端的连接；
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 当有TCP客户端与服务端建立连接后，accept会返回一个新的socket，在服务端通过对新的socket进行read/write操作，就可以与TCP客户端进行消息的接收/发送。
客户端 相比服务端的建立，客户端就比较简单。
创建一个socket套接字；
int socket(int domain, int type, int protocol); 设置服务端的IP、端口到struct sockaddr *addr，与服务端建立连接；
int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen); 当连接成功后，通过socket``read/write操作，就可以与TCP客户端进行消息的接收/发送。
演示 我们在一台Ubuntu主机上编译演示代码中的server.c和client.c,然后在该主机上进行演示.
gcc server.c -o server gcc client.c -o client 执行指令./server 8888运行服务端，端口号为8888;
执行指令./client 127.0.0.1 8888，让客户端连接本机的8888端口；
./client 127.0.0.1 8888 Please enter msg: 此时可以看到服务端监听到新的连接请求；
./server 8888 server established connection with localhost (127.0.0.1) 此时在客户端输入要发送的内容"tcp test"，然后回车发送,发送完成后，可以看到服务端会进行回显。
Please enter msg: tcp test Echo from server: tcp test 此时可以看到服务端接收到的信息:
server received 9 bytes: tcp test 至此，服务端的读写演示完成。
演示代码 服务端 /* * tcpserver.c - A simple TCP echo server * usage: tcpserver &lt;port> */ #include &lt;stdio.h>#include &lt;unistd.h>#include &lt;stdlib.h>#include &lt;string.h>#include &lt;netdb.h>#include &lt;sys/types.h>#include &lt;sys/socket.h>#include &lt;netinet/in.h>#include &lt;arpa/inet.h> #define BUFSIZE 1024 /* * error - wrapper for perror */ void error(char *msg) { perror(msg); exit(1); } int main(int argc, char **argv) { int parentfd; /* parent socket */ int childfd; /* child socket */ int portno; /* port to listen on */ int clientlen; /* byte size of client's address */ struct sockaddr_in serveraddr; /* server's addr */ struct sockaddr_in clientaddr; /* client addr */ struct hostent *hostp; /* client host info */ char buf[BUFSIZE]; /* message buffer */ char *hostaddrp; /* dotted decimal host addr string */ int optval; /* flag value for setsockopt */ int n; /* message byte size */ /* * check command line arguments */ if (argc != 2) { fprintf(stderr, "usage: %s &lt;port>\n", argv[0]); exit(1); } portno = atoi(argv[1]); /* * socket: create the parent socket */ parentfd = socket(AF_INET, SOCK_STREAM, 0); if (parentfd &lt; 0) error("ERROR opening socket"); /* setsockopt: Handy debugging trick that lets * us rerun the server immediately after we kill it; * otherwise we have to wait about 20 secs. * Eliminates "ERROR on binding: Address already in use" error. */ // optval = 1; // setsockopt(parentfd, SOL_SOCKET, SO_REUSEADDR, // (const void *)&amp;optval, sizeof(int)); /* * build the server's Internet address */ bzero((char *)&amp;serveraddr, sizeof(serveraddr)); /* this is an Internet address */ serveraddr.sin_family = AF_INET; /* let the system figure out our IP address */ serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); /* this is the port we will listen on */ serveraddr.sin_port = htons((unsigned short)portno); /* * bind: associate the parent socket with a port */ if (bind(parentfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) &lt; 0) error("ERROR on binding"); /* * listen: make this socket ready to accept connection requests */ if (listen(parentfd, 5) &lt; 0) /* allow 5 requests to queue up */ error("ERROR on listen"); /* * main loop: wait for a connection request, echo input line, * then close connection. */ clientlen = sizeof(clientaddr); while (1) { /* * accept: wait for a connection request */ childfd = accept(parentfd, (struct sockaddr *)&amp;clientaddr, &amp;clientlen); if (childfd &lt; 0) error("ERROR on accept"); /* * gethostbyaddr: determine who sent the message */ hostp = gethostbyaddr((const char *)&amp;clientaddr.sin_addr.s_addr, sizeof(clientaddr.sin_addr.s_addr), AF_INET); if (hostp == NULL) error("ERROR on gethostbyaddr"); hostaddrp = inet_ntoa(clientaddr.sin_addr); if (hostaddrp == NULL) error("ERROR on inet_ntoa\n"); printf("server established connection with %s (%s)\n", hostp->h_name, hostaddrp); /* * read: read input string from the client */ bzero(buf, BUFSIZE); n = read(childfd, buf, BUFSIZE); if (n &lt; 0) error("ERROR reading from socket"); printf("server received %d bytes: %s", n, buf); /* * write: echo the input string back to the client */ n = write(childfd, buf, strlen(buf)); if (n &lt; 0) error("ERROR writing to socket"); close(childfd); } } 客户端 #include &lt;stdio.h>#include &lt;stdlib.h>#include &lt;string.h>#include &lt;unistd.h>#include &lt;sys/types.h>#include &lt;sys/socket.h>#include &lt;netinet/in.h>#include &lt;netdb.h> #define BUFSIZE 1024 /* * error - wrapper for perror */ void error(char *msg) { perror(msg); exit(0); } int main(int argc, char **argv) { int sockfd, portno, n; struct sockaddr_in serveraddr; struct hostent *server; char *hostname; char buf[BUFSIZE]; /* check command line arguments */ if (argc != 3) { fprintf(stderr,"usage: %s &lt;hostname> &lt;port>\n", argv[0]); exit(0); } hostname = argv[1]; portno = atoi(argv[2]); /* socket: create the socket */ sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd &lt; 0) error("ERROR opening socket"); /* gethostbyname: get the server's DNS entry */ server = gethostbyname(hostname); if (server == NULL) { fprintf(stderr,"ERROR, no such host as %s\n", hostname); exit(0); } /* build the server's Internet address */ bzero((char *) &amp;serveraddr, sizeof(serveraddr)); serveraddr.sin_family = AF_INET; bcopy((char *)server->h_addr, (char *)&amp;serveraddr.sin_addr.s_addr, server->h_length); serveraddr.sin_port = htons(portno); /* connect: create a connection with the server */ if (connect(sockfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) &lt; 0) error("ERROR connecting"); /* get message line from the user */ printf("Please enter msg: "); bzero(buf, BUFSIZE); fgets(buf, BUFSIZE, stdin); /* send the message line to the server */ n = write(sockfd, buf, strlen(buf)); if (n &lt; 0) error("ERROR writing to socket"); /* print the server's reply */ bzero(buf, BUFSIZE); n = read(sockfd, buf, BUFSIZE); if (n &lt; 0) error("ERROR reading from socket"); printf("Echo from server: %s", buf); close(sockfd); return 0; }</content></entry><entry><title>当我们在谈论阅读时，我们在谈论什么</title><url>https://mdxz2048.github.io/post/thoughts_worldbookday/</url><categories><category>想法</category></categories><tags><tag>世界图书与版权日</tag></tags><content type="html"> 下一周就是“五一劳动节”了，这个糟糕的调休制度导致这个周末只休息一天，更糟糕的是，重庆的夏天就要来了，早上起床，我立马关上了阳台的窗户，这样室内才勉强待得住。当然，我的富贵竹还留在阳台上，享受着每天早晨仅有一个小时的阳光。
昨天晚上我就想着，今天早上起来一定要写点什么，一方面是和“世界读书日”这个高端、边缘的节日有一丝联系，这两年来的阅读，也逐渐让我养成了读书的习惯，自己也很是庆幸。另一方面，也是想记录一下自己在这个阶段获取信息的渠道，起码在现在看来，我认为十年后的自己，一样会认可我现在对信息的过滤方式，认可我的认可和反对。
阅读 记得栋哥调侃过，“他觉得读书很丢人，因为比较穷、比较无聊的人才读书,读书是一个便宜的打发时间的方式”。我倒是很喜欢这种说法，可能是因为我内心比较谨慎，或者本身看书也没有什么目的性，这种说法更能给自己找个轻松的理由。
选书 既然决定要看书了，我是一个很忙碌的人，总是会给自己找一些事情做，所以我深知时间的宝贵。所以在选书这件事情上我主要还是靠推荐，我信任的平台和个人推荐的书，我大部分都会尝试了解。我买的书，基本都来自豆瓣书影音的推荐、播客主播的推荐或者正在看的书里提到的作品，还有一小部分是在刷手机的时候看到，这部分比例极少。我会把要看的书分成两大类，一类是技术类，这本书我买回来会比较少看，更多的时候我会同时在zlib这类网站去再下一本电子版的盗版，技术类的书我还是更倾向于查PDF文档，除非向《程序员的自我修养》这种书我才可能会真正翻一翻；另一类书就是课外书了，课外书我又把它们分成了两个子类，一类是小说，现在更倾向于在kindle上直接借阅。另一类是其他一些心理学、社会学之类的不适合在kindle上看的，后续可能会重新翻开第二遍的书，我一般会选择买实体书回来，这其中也有一部分是新书，kindle没法借阅，只能买实体书，当然我看书的时间很少，这种情况我也不怎么遇得到。
我把自己从选书、买书做了一张图，基本就是我当前阅读的flow了。
看书，突然觉得把“阅读”、“读书”这些字眼换成“看书”之后，写起来舒服多了，感觉一下子亲切起来了，终于开始说人话了。关于看书我最近还是有一点心得，那就是只要你愿意挤时间出来，一定就会有时间。可能是《飘》写的确实吸引人，近一段时间，我基本上可以保持每天四十分钟以上的阅读时长。这对于日常要工作和学习的我来说，有这么多时间我很满足。我现在的通勤十分规律，上午7点17分进地铁安检，19分上地铁，开始在kindle上看书，基本上7点42下车。中午吃饭时间不是很固定(之前因为吃饭溜早了被领导逮到)，所以中午可能只会有10-20分钟的时间来看书，下班的时候也是一样的时长。这样的通勤，可以保证在不影响晚上其他事情的前提下，每天挤出来至少四十分钟的时间来看书，我已经相当满足了，除了看书本身的魅力之外，还有一种和生命在抢夺时间中获胜的乐趣。
总结，在看书方面，我没有像我在工作中那样热爱总结，所以所谓的读书笔记都分散在各种地方，有的在锤子便签，有的在备忘录，最近还有一个新的笔记软件，终于让我把kindle里的笔记体面的导出去了，也很满意这个软件(糯词笔记)。虽然我笔记很乱，但我打算一直这样。因为，在之前我已经决定了，不再把时间浪费在学习折腾工具上，所以后边我会偏向于先记录，哪怕记录的到处都是，等到有一天，我找到合适的方式把它们再收集起来就是了。在这之前，我还是会在备忘录、在某处存放我的读书笔记们。
写在最后,很庆幸我从事的行业是软件开发（也就是程序员？），因为计算机领域的广度和深度，能够让我在这个嘈杂的环境中，有一个可以深入学习和研究的方向，并且可以预见的是，这些东西能够很体面的养活着我，这是我足够幸运的地方。也让我养成了对知识的尊重和敬畏，让我保持好奇心去了解更多的计算机知识，养成了这种阅读的习惯，希望一直保持好奇心，继续学习。</content></entry><entry><title>在Linux上安装ResilioSync</title><url>https://mdxz2048.github.io/post/installresiliosynconlinux/</url><categories><category>工具教程</category></categories><tags><tag>ResilioSync</tag><tag>文件同步</tag></tags><content type="html"> 本文主要介绍如何在Linux上安装ResilioSync。
我日常主要使用3台Windows电脑。3台都安装ResilioSync软件，用来同步特定的文件夹。目前的主要问题是，需要其中至少有1台电脑保持开机并联网，才可以在另外一台电脑上同步之前的文件。因此，决定将树莓派装上ResilioSync软件，加入到我这个P2P网络中来，作为那个一直开机的设备。
准备工作 树莓派3B+ SD卡8GB+ SD卡烧录器 其他 使用说明 树莓派系统安装 这里我使用的Linux发行版本是Ubuntu Server 20.04.4 LTS。 使用balenaEtcher或者其他烧录软件将下载的系统镜像解压到SD卡中，这里网上教程很多，大家不清楚的可以搜一下； 部署ResilioSync 下载安装 在这里下载的版本是armhf架构 ResilioSync；
执行如下指令进行安装，安装是自动完成，这里等待即可；
sudo dpkg -i resilio-sync_2.7.2.1375-1_arm64.deb 配置激活 这里使用网页(树莓派IP:8888/gui)进行配置，首次进入时会提示需要设置一个网页登陆的账号、密码，这里根据需要设置即可；
我这里配置完成后，进入网页长这样；
配置完成后，我们把对应的License文件存放到设备上，加入我这里放在目录 /home/ubuntu/rs/ResilioSyncPro.btskey;
回到网页，在右上角点击 Preference，进入 License页面，点击 Apply License,将存放license的文件添加进来；
License激活完成后，界面长这样；
接下来就可以像在客户端上一样，在网页开始同步文件了；</content></entry><entry><title>设备间文件自动同步软件---Reaillio</title><url>https://mdxz2048.github.io/post/soft_win_reaillio/</url><categories><category>软件分享</category></categories><tags><tag>文件同步</tag></tags><content type="html"> 软件名称 Resilio Sync 网址：https://www.resilio.com/individuals/
功能介绍 Resilio Sync是一款电脑间自动同步文件夹的软件。
支持局域网同步，同时支持跨网络同步 不需要第三方服务器，几乎不受存储空间和流量限制 支持多人同时同步(越多人对文件夹进行同步，则同步速度越快) 数据私有/安全性，因为数据不在云端，而是存储在本地 首页展示 使用说明 安装 前往官网下载对应平台版本(支持win、Linux、mac)，Windows版本点击这里；
下载完成后，点击安装即可，只需要在这里填写计算机名称，以便在2台计算机之间同步时快速识别；
[image.png(https://inews.gtimg.com/newsapp_ls/0/14526417392/0.jiketuchuang.png)
点击入门后即可进入软件，点击左上角➕选择对应文件夹开始共享，随即会在主界面出现共享按钮；
主机点击共享后，会弹出如下界面，复制链接在另一台安装了Resilio Sync软件的电脑上打开即可自动同步；
到这儿，就完成了两台设备之间的文件夹自动同步。
pro版本的激活下载链接。</content></entry><entry><title>pdf格式文档在线转换</title><url>https://mdxz2048.github.io/post/soft_web_ilovepdf/</url><categories><category>软件分享</category></categories><tags><tag>PDF转换</tag></tags><content type="html"> 软件名称 ilovepdf是一个免费的PDF在线转换网站。
同时可提供付费的OCR(光学字符识别 )服务。
网址：https://www.ilovepdf.com
中文：https://www.ilovepdf.com/zh-cn
功能介绍 合并PDF
拆分PDF
压缩PDF
PDF格式转换为 Word、PPT、Excel格式，其中OCR功能为付费功能
Word、PPT、Excel转换至PDF
PDF加密、解锁、修复、签名等功能
首页展示 使用说明 在线工具的使用往往都比较简单直接，这里以一篇PDF格式的论文转换为Word文档为例，演示网站的使用。
注意：在PDF格式转换为其他格式时，如果PDF格式的文档是类似于**拍照/扫描出的PDF格式，一般需要用到OCR识别技术，即通过算法识别文本内容，类似于锤子的大爆炸，或者IOS15新推出的相机文字识别**技术。
在首页点击[PDF to Word]
在弹出的页面点击[Select PDF file]，选择一个PDF文件，例如我这里选择了之前下载的一篇论文《基于BDS的RTK模式定位精度分析_杨泰朋》。
这里我不需要OCR，选择[NO OCR]，然后点击[Convert to WORD]按钮即可。 转换完成后，会弹出下载按钮，点击[Download WORD]即可。</content></entry><entry><title>一款Markdown编辑软件-Mark Text</title><url>https://mdxz2048.github.io/post/soft_win_marktext/</url><categories><category>软件分享</category></categories><tags><tag>markdown</tag><tag>marktext</tag></tags><content type="html"> 软件名称 [marktext]()是一款简单、实时预览的markdown编辑器，是一款优秀的开源软件。
功能介绍 markdown常见语法
markdown扩展语法、数学表达式(KaTeX)、表情
支持导出HTML和PDF格式文档
更换主题
直接从剪切板粘贴图像
自动上传图片至图床
主题展示 使用说明 软件的安装，直接从github下载即可，我这里也上传一份，防止大家网络问题无法下载，在公众号后台回复“mark-text”即可获取下载链接。
图床，使用图床的配置需要先选择一个图床，默认可使用SM.MS免费图床。可可以参考这里设置，使用GitHub仓库作为图床。(由于网络原因，我这里上传图片一直失败，所以用了chrome插件即刻图床来上传，非常好用)
其他地方没有特殊设置，在使用过程中发现有软件闪烁的现象，不过影响使用。这篇推送就是用mark-text编辑的，能不能作为长期markdown编辑器，还有待考验。</content></entry><entry><title>公众号分享的一些软件</title><url>https://mdxz2048.github.io/post/soft_wechat_shares/</url><categories><category>软件分享</category></categories><tags><tag>公众号分享</tag></tags><content type="html"> 由于公众号后台自动回复频繁被删除，特将2021年以前分享过的一些下载链接同步至此，如下：
Photoshop CC 2019【小智亲测】 链接 提取码：72kv VEGAS15.0安装及破解【小智亲测】 链接 提取码：5aej 屏幕录像专家【小智亲测】 链接 提取码：jiib excel合并精灵【小智亲测，更多资源请关注公众号mddxz1995】 链接 提取码：2pfb 局域网代理软件ccproxy【小智亲测】分享链接： 链接 提取码：t4b7 office2016软件及注册机【小智亲测】分享链接： 链接 提取码：rdg7 AE2018分享链接： 链接 提取码：09za AE CC2019分享链接： 链接 提取码：urp5` Premiere Pro CC2018分享链接： 链接 提取码：253r pandownload请去官网下载最新版： https://pandownload.com http://www.mddxz.top/?p=127 树莓派安装nextcloud+内网穿透 链接 提取码: i2vr</content></entry><entry><title>谷歌搜索镜像网站</title><url>https://mdxz2048.github.io/post/soft_web_googlemirrorsites/</url><categories><category>软件分享</category></categories><tags><tag>谷歌搜索</tag></tags><content type="html"> 软件介绍 分享一个由浙江大学维护的Google搜索的公益镜像网站，供大家在网络不佳的情况下使用，有条件的同学就不要使用镜像网站了，自己直接访问即可。
Google搜索的优势和一些常用搜索技巧在我之前的一篇《学会使用高级搜索命令，提高搜索引擎使用效率》教程中有过介绍，我自己一般会使用Google和Bing两个搜索引擎，一般只有在网络不佳的情况下使用Bing。
使用方法 浏览器输入地址:https://g.luciaz.me/
这时候会有一个验证页面，验证你是否来自浙江大学，这里三个问题的答案分别是：
心灵之约、水朝夕、csxy@123
填入任何一个问题的答案，点击提交，会自动跳转至搜索页面。直接使用即可：</content></entry><entry><title>如何安装正版的WIN10</title><url>https://mdxz2048.github.io/post/installgenuinewin10/</url><categories><category>工具教程</category></categories><tags><tag>Windows10</tag></tags><content type="html"> 声明 本文档首发在我的个人公众号。
文档说明 以联想威6pro为例，使用微软官方工具，安装正版Windows10操作系统。
工具说明 U盘(8GB及以上、会被格式化) Windows电脑(可以上网) 使用说明 本次安装主要分为三个步骤
这一步由工具自动完成，通过下载微软的官方工具，将U盘制作成启动盘并下载win10进U盘； 插上U盘到待安装系统的笔记本(或主机)，进入BIOS将其设置为使用U盘启动； 等待自动安装(需要至少20分钟)； 注册激活，注意安装时不分是家庭版、专业版还是企业版，由最后安装完成后的激活码决定。 教程 将U盘插入可以上网的Windows电脑，打开资源管理器(win+E)查看盘符，检查是否插入，如下图，我这里是盘符是****I。 打开浏览器，进入win10的下载界面(https://www.microsoft.com/zh-cn/software-download/windows10)，点击立即下载工具，下载完成后，打开工具。点击接受/同意协议，出现如下界面时，选择为另一台电脑创建安装介质(U盘、DVD或ISO文件)，点击下一步。 在选择版本这里保持默认即可，点击下一步。需要安装其他版本的windows10，取消下图中红框的勾选即可选择。 选择介质，意思就是想用什么来装系统，我们这里当然选择U盘，然后下一步。 选择U盘，这里可以看到你电脑上插入的所有U盘，务必选择你要用来装系统的那个U盘。这个****U盘会被格式化，文件要提前备份好。确认好就可以点击下一步啦。 接下来就软件就会自动运行，会自动制作启动盘、下载windows10到系统。这个过程比较慢，基本上需要多等个1、2个小时，主要看网速和微软服务器给不给力了。 待安装系统的电脑完全关机，将U盘插入。 这里需要将电脑设置成从U盘启动，因为你启动了要让这个U盘给你装系统，所以需要一点设置。我们是通过设置电脑的BIOS，让系统启动后从U盘加载。这里我们以联想威6pro为例，给大家演示如果查看自己的电脑设置U盘启动 查看自己的电脑型号，这个通过电脑上的标签、查看之前买的订单基本都可以找得到。然后我查到公司这台笔记本是联想的威6pro，除了长得丑点外观也还可以； **找到电脑型号后，用搜索引擎(Google搜索、百度一下这种就叫搜索引擎)搜“**电脑型号+如何设置U盘启动”，然后在搜索结果中的方法中尝试一下，一般就可以找到答案，如果找不到，就先查怎么进入BIOS，然后进入后看下一步教程。一般情况同一品牌(实际是同一主板)进入BISO方法都是一样的，所有的BIOS也大同小异(因为会写这个软件的工程师比较少、太底层了)。 一般设置方法分3步： 进入BIOS，比如我这台电脑就是开机按住Fn+F2；
关闭安全启动；
选择U盘启动(注意这里需要插上U盘)，然后保存并退出。
退出BIOS后电脑会自己进入U盘启动。这里我们只需要按确定/下一步就好啦，能到这里，基本上系统安装已经成功了一半了，接下来就可以喝杯水休息一下。 等待安装完成后，购买密钥激活即可。
至此，正版的Windows10系统安装完成。</content></entry><entry><title>IOS设备使用系统自带Airplay投屏到电脑</title><url>https://mdxz2048.github.io/post/soft_win_deeprd/</url><categories><category>软件分享</category></categories><tags><tag>投屏</tag></tags><content type="html"> 软件 蓝莓投屏
介绍 iOS和MacOS里, 使用Airplay协议, 无需安装软件, 直接镜像投屏. 安卓和Windows安装蓝莓研发的投屏发送端, 可用投屏码 一键投屏到对应接收端. 支持同时镜像电脑屏幕到多个接收端, 接收端也可以同时显示多路屏幕, 即支持一投多和多投一, 适合会议办公, PPT演示
本次主要介绍IOS设备投屏到电脑，安卓设备和win10系统使用系统自带无线显示可完成投屏。
软件下载 官网下载：http://deeprd.com
或公众号后台回复：“手机投屏”获取软件安装包
使用教程 打开获取到的软件安装包，解压安装包，效果如图所示。 双击“Blueberry-Airplay.exe”，软件会自动运行。此时可以在状态栏看到软件，效果如图所示。 保证IOS设备和PC机处于同一局域网下(连接同一WiFi)
打开IOS设备屏幕镜像，可以看到PC机，iPhone投屏后效果如图。
ipad投屏后效果如图。</content></entry><entry><title>GitHub+hexo搭建个人博客</title><url>https://mdxz2048.github.io/post/build-blog-with-hexo/</url><categories><category>工具教程</category></categories><tags><tag>hexo</tag><tag>搭建博客</tag></tags><content type="html"> 声明 本内容非原创，主要参考该博客进行验证 http://dwz.date/buw2dwz.date
感谢GitHub提供的开源服务。 感谢Hexo提供的方案。官网： https://hexo.io/hexo.io
介绍 今天介绍使用GitHub+hexo博客框架搭建个人博客的方案。优点是****完全免费、自由，缺点是只能使用静态页面展示，使用评论、上传图片其他功能时需要配合其他插件服务使用。
参考本教程，大约需要半个小时来完成安装和使用。其他高级操作需读者自行搜索教程学习。
安装Node.s和Git终端 安装Node.js，如图下载LTS版本安装包进行下载，然后像正常安装软件一样进行安装即可。下载地址https://nodejs.org/en/ **安装成功后，如图，在windows终端下输入如下指令查看是否安装成功，如下出现版本号即安装成功。**搜索cmd(命令提示符)可进入windows终端。  node -v 安装git，点击gitWindows客户端进行下载，下载完成后像安装正常软件一样进行安装即可。 如果没有GitHub账号，请查看此教程进行注册。注册GitHub账号 创建Github Pages(博客存放仓库) 打开浏览器，进入GitHub官网，登录自己的账号。 点击头像，查看自己的****username，我的用户名为mdxz2048 点击右上角加号，在下拉选项中选择****New repository创建博客仓库。 在弹出的设置页面Repository name处填写****yourusername.github.io，然后其他配置保持默认，点击Create repository。例如我的用户名为mdxz2048，就填mdxz2048.github.io。 接下来GitHub会将该仓库设为Github Pages，以后访问该域名就可以访问到该仓库的内容，我们要搭建的博客随后会被放在这里。 配置GitHub 在桌面右键鼠标，点击****git bash here进入git终端。 在终端输入如下指令，连接GitHub与本地。  git config --global user.name "mdxz2848"  git config --global user.email "zhipeng2048@gmail.com" 生成SSH key密钥。执行如下指令，然后，在C:*Users**ASUS.ssh目录会有两个文件id_**rsa和**id_rsa.pub*,打开**id_rsa.pub**，复制里面的所有内容到 SSH keys这里 的Key，Title随便填，然后Add SSH key就可以了。  ssh-keygen -t rsa -C "zhipeng2048@gmail.com" 安装hexo 首页进入任意磁盘创建文件夹，这里文件夹命名为blog,在该文件夹下鼠标右键选择Git Bash Here，执行命令：  npm install -g hexo-cli 接着执行如下指令  hexo init  npm install 新建完成后，指定文件夹的目录如下：  _config.yml 部署 在_config.yml文件，找到deploy，进行以下配置：  deploy:  type: git  repo: https://github.com/mdxz2048/mdxz2048.github.io.git  branch: master 安装部署工具，执行如下指令。  npm install hexo-deployer-git --save 使用next主题美化 在blog文件夹下鼠标右键选择Git Bash Here，然后clone next主题：  git clone https://github.com/theme-next/hexo-theme-next themes/next 更新主题NexT：  cd themes/next  git pull 切换成NexT主题，在blog根文件夹下，修改_config.yml文件中的theme：  Extensions  Plugins: https://hexo.io/plugins/  Themes: https://hexo.io/themes/  theme: next 切换后，执行如下指令清理缓存。  hexo clean 执行如下指令，查看本地部署效果。  hexo s 浏览器打开http://localhost:4000/可以看到本地部署效果。 可以文末下载我的博客配置和主题配置文件，根据自己的需求进行修改。 新建一篇文章 执行如下指令新建一个.md的文件，然后在对应路径下打开编辑。
 hexo new 文章名 执行如下指令进行部署  hexo g //生成网页文件  hexo s //localhost:4000本地预览效果  hexo d //部署 在https://mdxz2048.github.io/查看部署效果。 文中提到的软件和配置文件均可在此下载：
 链接: https://pan.baidu.com/s/1Nw-ApHdYZkqXj65h7T7qew  提取码: ssgt</content></entry><entry><title>使用树莓派部署个人网盘</title><url>https://mdxz2048.github.io/post/how-to-install-nextcloud-on-raspberry-3b+/</url><categories><category>工具教程</category></categories><tags><tag>树莓派3B+</tag><tag>nextcloud</tag></tags><content type="html"> 效果展示 准备工作 硬件：树莓派3B+、SD卡、SD卡读卡器、网线
软件：所有需要的软件点击此处下载
提取码: hv1b
(链接失效后可在我的公众号mddxz1995后台回复个人网盘获取最新链接)。
其他环境：公网IP
(若只作为局域网访问则不需要公网IP。公网IP是为了让我们的网盘可以通过外网进行访问，此处以一台阿里云作为代理服务端来演示)
搭建方案 使用开源应用nextcloud在树莓派3B+搭建网盘(也支持其他树莓派型号)实现文件的存储。优点是是支持Android、IOS设备客户端和web端访问，日常使用比较方便。 使用开源应用frp实现内网穿透的反向代理，具体是在一台有公网IP的设备上运行frp服务端，在客户端(这里指树莓派)上运行客户端，外网访问时通过服务端作为代理访问树莓派。优点是支持 tcp, udp 协议，适配了 http 和 https 应用协议，也就是可以更好的通过远程访问我们的网盘内容。 安装镜像 Next cloud提供了树莓派专用的系统镜像，我们可以从官网下载安装，同时也可以在我提供的文件中找到镜像直接安装使用。
将下载完成的镜像解压，解压后效果如图所示。(解压软件在软件及教程\解压缩软件中提供) 将SD读卡器插入电脑，打开Win32DiskImager镜像安装软件，(在软件及教程\镜像写入工具中提供) ，点击此按钮选择上一步解压出来的文件。 在设备栏选择SD卡，我这里选择H盘，选择完效果如图所示。 点击下方写入，然后等待写入完成。 等待进度条完成后，会提示写入成功。此处需要注意若电脑提示要格式化磁盘一定不要格式化。 此时SD卡被分成两个盘。为了稍后使用SSH远程登录树莓派控制台，在资源管理器中进入SD卡boot盘，右键新建/文本文档，新建一个文件名为SSH的空文档，同时删除掉文件后缀名，效果如图所示。 将SD卡插入树莓派等待启动，上电前我们将树莓派通过网线接在路由器的lan口。 等待约十分钟左右，这个时间刚好可以在刺激战场中玩一把团队竞技。 打开路由器的后台，查看树莓派的IP。 打开shell工具，点击文件/新建，协议选择SSH，主机填写树莓派IP地址，端口选择22，然后点击连接(工具在软件及教程\Xshell 、Xftp 6中提供)。 输入默认账号密码，登入控制台，登陆成功后界面如下，也可以根据提示升级新版的nextcloud。 账号：pi
密码：raspberry
打开浏览器，输入树莓派IP，此时可以看到next cloud已经开始运行，这里务必保存好NextCloudPi和NextCloud的账号密码，然后点击下方的Activate。 在弹窗中输入NextCloudPi(也就是第一个)的账号密码，然后点击登录。 如果安装了U盘，第一次运行会提示格式化U盘，也可以选择跳过。 External access栏选择No，然后跳到最后一步就可以开始使用了。 在浏览器地址栏输入树莓派IP，就进入了登陆界面，使用第二个密码登录。 如果看到如下界面就说明已经初始化成功了，此时网盘已经可以在局域网内正常使用，可在apple store和安卓应用市场搜索nextcloud下载对应终端的APP。 Frp反向代理 Frp是一款开源的反向代理软件，我们通过在阿里服务器上运行frp服务端，在树莓派上运行客户端与服务端进行连接。这样我们可以通过服务端作为代理，转发我们对树莓派的请求，以达到外网访问树莓派的目的。这里我主要参考了《FRP中文文档》和《使用frp进行内网穿透》这两篇文档。
服务端配置 在阿里后台实例/安全组 规则添加入方向端口，比如我这里添加7500/7500、7001/7001、7600/7600三个端口分别用来作为frp的服务端管理界面的访问端口、树莓派SSH连接映射端口和树莓派网盘访问端口，配置界面如图所示。 打开xshell客户端，进入阿里服务器的控制台。 执行arch如下指令，查看服务器机器架构，我的服务器是X86_64。 root@iZ2ze68uznd431fxfr63d2Z:~# arch
x86_64
下载对应的frp软件，因为GitHub国内访问速度过慢，我这里已经将服务端的软件上传至软件及教程\frp\服务端(X86_64)，随后通过ftp客户端传至设备即可，和我设备架构相同的同学可以直接使用我提供的软件，其他架构可在frp官方下载界面下载对应的软件（ftp客户端软件在软件及教程\Xshell 、Xftp 6提供）。 打开ftp软件，连接至服务器控制台，将frp服务端软件拖到服务器Dowoload目录下。 通过Xshell连接服务器后台，进入frp服务端软件的存放目录，执行如下命令，解压。 cd Download/ sudo tar -zxvf frp_0.32.0_linux_amd64.tar.gz 执行如下命令，给文件夹改个名，方便使用。 cp -r frp_0.32.0_linux_amd64 frp 执行如下命令，编辑frp的配置文件。 cd frp sudo vim frps.ini 我的服务端配置内容如下： [common] bind_port = 7000#与树莓派绑定的端口 dashboard_port = 7500#frp服务端软件运行信息展示端口 token = 12345678#树莓派与服务端的登陆口令 dashboard_user = admin#frp服务端软件运行信息展示的访问账号 dashboard_pwd = admin#frp服务端软件运行信息展示的访问密码 vhost_http_port = 10080#此处没有使用，我也没弄明白 vhost_https_port = 10443#此处没有使用，我也没弄明白
退出并保存，执行如下指令，运行frp服务端。 ./frps -c frps.ini 此时通过服务器IP:7500就可以看到frp服务端的展示信息，效果如图所示。 再执行如下指令将其运行在后台。 nohup ./frps -c frps.ini &amp; 至此，服务端已经配置完成。 客户端配置 树莓派是armv7架构，将对应的frp软件通过ftp软件拷贝到树莓派的指定目录下。 进入对应目录，和服务端操作类似，解压、重命名。 cd ~/ tar -zxvf frp_0.32.0_linux_arm.tar.gz cp -r frp_0.32.0_linux_arm frp 执行如下指令，编辑客户端配置。 sudo apt-get install vim [common] server_addr = x.x.x.x #这里填服务器IP server_port = 7000 #这里填写服务器配置中的bind_port token = 12345678 #登录口令 [smb] type = tcp local_ip = 127.0.0.1 local_port = 443 remote_port = 7600 [SSH] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000
执行如下指令，运行客户端。 ./frpc -c frpc.ini 输出如下内容，则客户端和服务端绑定成功。 2020/03/21 09:05:14 [I] [service.go:257] [f499bd2db389d748] login to server success, get run id [f499bd2db389d748], server udp port [0] 2020/03/21 09:05:14 [I] [proxy_manager.go:144] [f499bd2db389d748] proxy added: [smb SSH] 2020/03/21 09:05:14 [I] [control.go:179] [f499bd2db389d748] [smb] start proxy success 2020/03/21 09:05:14 [I] [control.go:179] [f499bd2db389d748] [SSH] start proxy success
此时在浏览器地址栏输入服务器IP:7600即可访问树莓派。 出现以上弹窗则说明已经成功访问了树莓派，只是由于next cloud的配置，限制了服务器的IP访问，此时，我们进入next cloud的配置文件，将服务器IP添加进去，然后退出保存。效果如图所示。 sudo vim /var/www/nextcloud/config/config.php 重新运行frp客户端在后台，成功后此时可通过外网进行访问。 nohup ./frpc -c frpc.ini &amp; 特别感谢
感谢next cloud、frp团队开源分享
https://github.com/fatedier/frp https://nextcloud.com/
参考文档
使用frp进行内网穿透</content></entry><entry><title>一个理工科本科毕业生的就业经历分享</title><url>https://mdxz2048.github.io/post/how-to-find-a-job/</url><categories><category>工具教程</category></categories><tags><tag>应届生</tag><tag>找工作</tag></tags><content type="html"> 如果你有兴趣打开了这篇文档，我大概可以相信你现在也是处于大四刚开始找工作的阶段，写这篇文档是因为最近身边有一些学弟学妹来问我关于找工作的事情，就正好利用周末一点时间结合自己参加校招和社招的经历，分享一点点经验给大家。有一点要说明的是，作为我个人的一些经验分享，并不一定适用于当下找工作的形势与政策，也一定不是适用于每个人，但是对于正在或者即将面临毕业的你，我相信或多或少的会有一些有参考价值。
我是自动化专业19届本科生，现在在深圳从事嵌入式计算机行业，毕业前掌握一些单片机和嵌入式linux方面的知识，有一定的C语言基础，另外还有一些实际的学生项目经验，所以我以下的分享可能更适用于有一点技术但是没有选择考研的同学作为参考。
以下我按照我找工作的安排顺序，分为校招、和社招两部分来给大家分享：
校招： 首先是关于招聘会的选择，一开始我就比较重视也算积极的参加了校招，我是在秋季学期的9月和10中旬一共参加了两次。因为考虑毕业后打算去北京，所以当时我选择了在西安一些高校参加校招(之所以没有选择北京完全是因为我对西安更加熟悉一些)
宣讲会信息的整理，参加校招需要提前了解各个学校的宣讲会信息，提前安排好行程，每个学校的校招信息在各个学校的就业信息服务网站中的宣讲会模块都会有，为了保证信息的准确性和实时性建议大家去各高校的官网去看，我会将网址附在文末。为了自己少跑一些路，我将每天的招聘信息按照各个校区(一定注意是校区，有一些学校两个校区之间可能隔两三小时车程)进行分类整理，然后再将同一时间段内(一般就是一个上午或者下午)自己想要参加的招聘信息放在一起，当时是做了表格方便自己随时查看。
其次是校招过程自己总结出的一些经验：
(1)因为很多一场招聘会的时间都在1-2个小时，所以基本上同一间教室一个时间段内一般只有2-3个宣讲会，所以可能你在这所学校感兴趣的两个宣讲会会同时在同一个时间进行宣讲，所以为了应对这种问题建议不是在本校找工作的同学尽量结伴。
(2)关于简历的制作技巧就不在这里说了，在职位这一块我建议写成就业方向，然后选择一两个从事的方向去写，因为每个企业对岗位的叫法不一样，到时候可以在简历明显的位置用笔写上岗位就可以，这里也避免了让人事小姐姐懵O。
(3)校招的流程一般不确定，笔试、面试一般都或前或后的都有可能(如果你有机会参加的话)，这个时间也很不确定，有的是当场进行，有的是电话通知，一般这个就听安排然后按照自己的选择进行安排就行。面试也主要是问一些简历和专业方面的问题，大部分都比较基础。
社招： 对于社招，我首先想抛出我的一个观点：对于第一份工作，企业给你的成长空间比待遇会更重要一些，应当在想要从事的行业去尽可能找一些更大的平台去提升自己。(当然这个目标是在待遇能满足你正常生活的前提下，毕竟这是一件长期的事情，总得每天开开心心的去工作)
社招的准备：
(1)简历一般建议多打印几份，普通黑白打印即可，基本上每家去之前都要求带简历。
(2)行程安排我这次主要使用手机的日历功能，手机会会提前提醒，也是方便安排行程。
(3)基本上大的企业面试都是一些基础的问题，我自己是做软件，做的面试题也基本是一些C语言(主要是指针、内存、常用接口、链表&hellip;)相关和三电起的基础；问题也主要是针对简历上所写的来问，基本上只要是自己做的东西一般也不会被问住。
公司的选择：
我有在北京一家公司待过一段时间，公司主要研发港口自动化方面的系统，规模在一百人左右，其实规模已经不是特别小了，虽然进去也是研发岗位，但是由于一些管理制度上的不完善，导致工作体验比较差，可见范围内也不能很好的提升自己，因此我选择了在答辩完后去深圳找工作，大概是在校运会的那一周我在深圳参加面试，相对来说深圳研发环境比北京好一些，所以我也是很快在深圳找到了工作，但是北方的同学来深圳一定得考虑好南北气候的差异是不是能接受。
另外，如果是做技术方面的同学，尽可能去争取研发岗位，哪怕刚进去是在研发岗干的是助理的活。岗位不一样想转岗难度一般会比较大，除非你是特别优秀或者选择跳槽。
平台的选择：
我一共用了三家招聘平台的APP：BOOS直聘、前程无忧(51Job)、智联直聘，现在看来后两家企业的回复会多一些，boos直聘更多的是企业主动联系你让你发简历。
写在最后： 现在正处于九月中旬，也就是秋招刚刚开始的阶段，大家完全有时间去多参加一些面试，无论是否成功给自己积累一下经验总不是件坏事。作为本科毕业生想要从事技术领域相关工作，更多的还是要真正学到一些知识、技能，这也是你找工作的资本。如果你到现在还是一张白纸什么也不会，那么以上的内容可能并不适用。
最后，真诚的希望各位能够珍惜大学最后的这段时光，尽可能到处走走，多和朋友、老师在一起聚一聚。
个人水平有限，小小的分享只希望能够帮到一二就相当满足了，仅作为参考，不建议生搬硬套。
以下是我之前整理的一些高校的就业信息网站，基本上在百度搜索“高校+就业”就会跳出来。
北方民族大学： http://jyc.nun.edu.cn/module/careers?menu_id=6598
西安理工大学： http://job.xaut.edu.cn/website/index.aspx
长安大学： http://jyzx.chd.edu.cn/
西电： http://job.xidian.edu.cn/Special/Index/100021/0
西安邮电： http://jiuye.xupt.edu.cn/
……</content></entry><entry><title>学会使用高级搜索命令，提高搜索引擎使用效率</title><url>https://mdxz2048.github.io/post/google-search-skills/</url><categories><category>工具教程</category></categories><tags><tag>搜索技巧</tag></tags><content type="html"> 如今国内搜索引擎市场经过多年来的发展也已经完成了洗牌。根据 据析趣知 提供的数据，百度搜索无疑是国内引擎竞争中的最大赢家，虽然它有很多让我们诟病的缺点，但我们大部分人还不得不边骂边从铺天盖地的广告中找出自己需要的信息。
图 1- 2019年2月中文搜索引擎使用
数据来自：2019年2月，全球&amp;中国搜索引擎市场份额排行榜-据析趣知
当然，也有人千方百计的去追求体验更好的goole搜索，也有人转战使用新生军今日有条，但是在国内百度搜索无疑是我们的主要工具，为了提高搜索引擎的使用效率，尽量避开那些不想看到的广告，快速、准确的找到需有用的信息， 我找了四个常用的百度高级搜索技巧介绍给大家。
技巧一：完全匹配符 "" 描述：使用英文双引号"&ldquo;将搜索关键词括起来，可以让搜索结果完全匹配。
举例；使用百度搜索 格力举报 和 &ldquo;格力举报&rdquo;
结论：可以明显的看到使用了 "&rdquo; 后 格力 不会和 举报 分开，这就是搜索结果完全匹配。
对比一A： 使用 格力举报 搜索结果 对比一B： 使用 &ldquo;格力举报&rdquo; 搜索结果 技巧二：排除搜索 描述：在搜索关键词后加 -排除关键词，可以在搜索结果中排除掉需要排除的关键词。
举例：使用百度搜索 格力 和 格力 -奥克斯
结论：使用了 格力 -奥克斯 搜索后很明显的结果中排除了这两天很热的格力和奥克斯的举报纠纷。
对比二A： 使用 格力 搜索结果 对比二B： 使用 格力 -奥克斯 搜索结果 技巧三：文件格式过滤 描述：在关键词后加 filetype：xxx 可以在搜索结果中只展示指定格式结果。
举例：使用百度搜索 毕业答辩 filetype:ppt 和 毕业答辩 filetype:doc
结论：在关键词后添加 filetype:文件格式 后可以明显的看到搜索结果只包含了指定格式的结果。
对比三A： 使用 毕业答辩 filetype:ppt 搜索结果 对比三B： 使用 毕业答辩 filetype:doc 搜索结果 技巧四：主题关键字包含 描述：在关键词前加 intitle: 只展示搜索结果的主题包含关键词的结果
举例：使用百度搜索 intitle:奥克斯
结论：搜索结果中主题中都包含 奥克斯
使用 intitle:奥克斯 搜索结果 当然搜索引擎高级命令不止于此，搜索引擎的也不止百度一家， 希望以此抛砖引玉，能够帮大家更自主的使用搜索引擎，快速、高效的完成每一次搜索。
欢迎感兴趣的朋友关注我的个人公众号“mddxz1995”，获取更多资源、资讯。</content></entry><entry><title>关于我</title><url>https://mdxz2048.github.io/about.html</url><categories/><tags/><content type="html"> 警惕三种怪癖 第一种怪癖：我们对已经拥有的东西迷恋到不能自拔。
第二种怪癖：是我们总是把注意力集中到自己会失去什么上，而不是会得到什么上。
第三种怪癖：是我们经常假定别人看待交易的角度和我们一样。</content></entry><entry><title>12306</title><url>https://mdxz2048.github.io/post/12306/</url><categories><category>工具教程</category></categories><tags><tag>12306bypass</tag><tag>抢票</tag></tags><content type="html"> 这两天需要买一张火车票，但是打开12306APP时候发现已经卖完了，就想着是不是要抢票软件去买加速包了，但是看到12306提示的是 候补 而不是无票，就去了解了一下这个候补的规则，真香！
首先大概说一下没有候补之前售票流程所有官方放出来的票会直接进入一个 票池 ，12306官网、客户端以及所有抢票软件都是在这个票池中买票，当没有票的时候其实大家都买不到票，但是一发现有人退票，因为软件可以一直监测票池，所以就比人有优势抢到票，当然这是 以前 。
再来看看现在有了候补制度的售票流程因为存在候补，在放出的票 进入票池之前 会先查看是否有候补订单，如果有直接根据候补订单的下单时间顺序（注意这里是直接根据订单的提交时间顺序！）将票分配给对应的订单，这样这张票就已经售出不会进入票池，当没有候补订单时才会进入票池，接下来才是各类APP和后面的乘客继续购买。
当然候补终止时间为“不晚于开车前一天的1900”，所以在这个时间节点之后候补通道关闭，也就是开车前一天的七点之后不可以进行候补，如果这时候还没有买到票就需要去票池等别人退票了，这个时间到开车前停止售票这个时间段才是12306给抢票软件留下的生存空间。
现在我们可以分析一下，候补通道有效时，抢票软件其实是在这个候补订单之后买票，相对于这个候补机制完全没有了优势。那么我们买票完全可以直接在12306官网进行购买或候补，成功率明显高于抢票软件，而且不用去到处给别人分享加速包。而在候补通道关闭后剩下那一段时间内，你可以尽情去用你喜爱的抢票软件了。</content></entry><entry><title>Windows远程桌面</title><url>https://mdxz2048.github.io/post/windows%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/</url><categories><category>工具教程</category></categories><tags><tag>远程桌面</tag></tags><content type="html"> 软件名 rdpwrap
安装平台 Windows
功能介绍 本软件为开源软件，开源地址： 激活Windows自带的远程桌面，适用于家庭版等 实现多用户远程桌面 软件下载 比百度更快的网盘：因微信公众号平台限制，请在公众号后台回复关键字“rdpWrap”获取下载链接
安装 解压压缩包后，右键以管理员身份运行install.bat执行安装脚本，然后关闭弹窗。安装成功效果如下： 右键以管理员身份运行RDPConf.exe，可以看到我这里的Windows系统版本显示不支持，没关系，这只是配置的问题，我们继续往下看。 先关掉RDPConf.exe的弹窗，在Windows桌面进行如下操作，关闭远程桌面服务。 按Win+R按键，打开服务界面。 选中Remote Desktop Services，点击停止此服务； 其他 进入RDP Wrapper安装目录，默认为C:\Program Files\RDP Wrapper，删除rdpwrap.ini配置文件，将我分享的配置文件放进来，分享的配置文件大小为179KB。 为了保险起见，我们直接进行一下升级。将我分享链接中的autoupdate.zip文件解压出来，将升级脚本放到RDP Wrapper安装目录，默认为C:\Program Files\RDP Wrapper。右键以管理员身份运行。效果如图： 升级过程比较快，执行完之后，记得回到服务中，启动远程桌面服务，效果如图： 此时，再打开RDPConf.exe检查配置，可以看到之前红色部分的警告信息都没有了，我们的电脑就可以在局域网下访问远程桌面了，效果不要舒服。 使用 在桌面，搜索远程桌面； 输入被远程访问电脑的IP，登录账号、密码即可远程访问。 账号、密码为被访问电脑的用户： 可以在设置/账户/家庭和其他用户/将其他人添加到这台电脑进行 添加。 或者将被访问的电脑锁屏，然后用本地登录的账号密码进行登录 点击连接即可登陆。 碰到其他问题，可在公众号留言或去GitHub项目下查找解决方法。</content></entry></search>
<!doctype html><html lang=zh-cn dir=content/zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>自上而下理解内核网络(五)---网络层（IP协议）数据的接收与发送 - MD小智</title><meta name=keywords content="博客,程序员,架构师,思考,读书,笔记,技术,分享"><meta name=author content="MD小智"><meta property="og:title" content="自上而下理解内核网络(五)---网络层（IP协议）数据的接收与发送"><meta property="og:site_name" content="MD小智"><meta property="og:image" content="https://mdxz2048.github.io/img/author.jpg"><meta name=title content="自上而下理解内核网络(五)---网络层（IP协议）数据的接收与发送 - MD小智"><meta name=description content="欢迎来到MD小智的个人站点，这里主要分享软件、工具教程、技术学习和思考"><link rel="shortcut icon" href=https://mdxz2048.github.io/img/favicon.ico><link rel=apple-touch-icon href=https://mdxz2048.github.io/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=https://mdxz2048.github.io/img/apple-touch-icon.png><link href=//cdn.bootcdn.net/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.css rel=stylesheet><link href=https://mdxz2048.github.io/css/main.css rel=stylesheet type=text/css><link href=https://mdxz2048.github.io/css/syntax.css rel=stylesheet type=text/css></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span>
<span class=site-title>MD小智</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>学习-思考-分享</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class=menu-item><a href=/categories rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>分类</a></li><li class=menu-item><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=/about.html rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于我</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span>
<span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://mdxz2048.github.io/post/study_linux_tcp_in_linux_05/ itemprop=url>自上而下理解内核网络(五)---网络层（IP协议）数据的接收与发送</a></h1><div class=post-meta><span class=post-time><i class="fa fa-calendar-o fa-fw"></i>
<span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2022-07-04">2022-07-04</time></span>
<span class=post-category>&nbsp; | &nbsp;
<i class="fa fa-folder-o fa-fw"></i>
<span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a class=post-category-a href=/categories/linux%E5%86%85%E6%A0%B8 itemprop=url rel=index><span itemprop=name>Linux内核</span></a>
&nbsp;</span></span>
<span>|
<i class="fa fa-file-word-o fa-fw"></i>
<span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>3190 字</span></span>
<span>|
<i class="fa fa-eye fa-fw"></i>
<span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>7分钟</span></span>
<span id=/post/study_linux_tcp_in_linux_05/ class=leancloud_visitors data-flag-title=自上而下理解内核网络(五)---网络层（IP协议）数据的接收与发送>|
<i class="fa fa-binoculars fa-fw"></i>
<span class=post-meta-item-text>阅读次数：</span>
<span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><p>终于又有时间划水了，我们接着分析网络层。在上一节中，我们介绍了<a href=https://mdxz2048.github.io/post/study_linux_tcp_in_linux_04/>sock与传输层UDP</a>，展示了在传输层(UDP协议栈）中的数据收发流。</p><p>本节，继续自上而下进行跟踪，紧挨着传输层的是<strong>网络层</strong>（我们这里主要关注IPv4协议）。网络层主要负责如下工作：</p><ul><li>本机发送和接收数据；</li><li>其他经过网卡设备的数据转发；</li></ul><p>我们这里主要关注网络层对<strong>本机ipv4数据的发送和接收处理</strong>，跟踪内核代码，了解数据是如何从传输层(UDP协议)经过**网络层(IP协议)**发送到网卡设备；同时，也会跟踪数据从网卡接收到之后，经过网络层(IP协议)进入udp的接收入口；最后，会在篇幅允许的情况下，了解网络层如何转发经过网卡非本机的数据。</p><p>​ <img src=https://raw.githubusercontent.com/mdxz2048/mddxz_top_img/main/caeri_dellTCP%E5%86%85%E6%A0%B8%E5%88%86%E5%B1%82%E5%9B%BE%20-%20%E7%BD%91%E7%BB%9C%E5%B1%82.jpg alt="TCP内核分层图 - 网络层"></p><h2 id=网络层的数据和路线>网络层的数据和路线</h2><h3 id=ipv4协议首部>ipv4协议首部</h3><p>IPv4报头成员的内容决定了IPv4协议栈处理数据包的方式，如果存在问题，则数据包将被丢弃。</p><p>在*《TCP-IP详解卷I-协议》IP:网际协议*一章节中，我们挪用了这一章节中的IP数据包的结构，如下图：</p><p><img src=https://raw.githubusercontent.com/mdxz2048/mddxz_top_img/main/caeri_dellimage-20220705084024583.png alt=image-20220705084024583></p><p>IP报头的定义位于文件<a href=https://github.com/torvalds/linux/blob/master/include/uapi/linux/ip.h#L86-L106>ip.h</a>,位于这样一个结构体中：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a2f;font-weight:700>struct</span> iphdr {
</span></span><span style=display:flex><span><span style=color:#080>#if defined(__LITTLE_ENDIAN_BITFIELD)
</span></span></span><span style=display:flex><span><span style=color:#080></span>	__u8	<span style=color:#a0a000>ihl</span>:<span style=color:#666>4</span>,
</span></span><span style=display:flex><span>		<span style=color:#a0a000>version</span>:<span style=color:#666>4</span>;
</span></span><span style=display:flex><span><span style=color:#080>#elif defined (__BIG_ENDIAN_BITFIELD)
</span></span></span><span style=display:flex><span><span style=color:#080></span>	__u8	<span style=color:#a0a000>version</span>:<span style=color:#666>4</span>,
</span></span><span style=display:flex><span>  		<span style=color:#a0a000>ihl</span>:<span style=color:#666>4</span>;
</span></span><span style=display:flex><span><span style=color:#080>#else
</span></span></span><span style=display:flex><span><span style=color:#080>#error	&#34;Please fix &lt;asm/byteorder.h&gt;&#34;
</span></span></span><span style=display:flex><span><span style=color:#080>#endif
</span></span></span><span style=display:flex><span><span style=color:#080></span>	__u8	tos;
</span></span><span style=display:flex><span>	__be16	tot_len;
</span></span><span style=display:flex><span>	__be16	id;
</span></span><span style=display:flex><span>	__be16	frag_off;
</span></span><span style=display:flex><span>	__u8	ttl;
</span></span><span style=display:flex><span>	__u8	protocol;
</span></span><span style=display:flex><span>	__sum16	check;
</span></span><span style=display:flex><span>	__be32	saddr;
</span></span><span style=display:flex><span>	__be32	daddr;
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>/*The options start here. */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>各部分含义如下：</p><ul><li>**ihl:**表示Internet报头长度。IPv4报头长度以4字节为单位，长度不固定。因为IPv4报头可包含可选的边长选项。IPv4报头最短为20字节(不包含任何选项时，对应的ihl的值为5)，最长为60字节(对应的ihl值为15).IPv4报头的长度必须是4字节的整数倍。</li><li>**version：**必须是4。</li><li>**tos：**tos表示服务类型。</li><li>**tot_len：**包括报头在内的数据包总长度，单位为字节。tot_len字段长16位，可表示最大长度为64KB。RFC 761规定，数据包最短不得少于576字节。</li><li>**id：**IPv4报头标识。对于分段来说，id字段很重要。对SKB进行分段时，所有分段的id值都必须相同；对于分段后的数据包，则要根据各个分段的id对其进行重组。</li><li>**frag_off：**分段偏移量，长16位。后13位指出了分段的偏移量。在第一个分段中，偏移量为0。偏移量以8字节为单位。前3位的值不同时，分别表示如下含义：<ul><li>001表示后边还有其他分段(More fragments,MF).除最后一个分段外，其他分段都必须设置这个标志；</li><li>010表示不分段(Don&rsquo;t Fragment,DF).</li><li>100表示拥塞(Congestion,CE).</li></ul></li><li>**ttl：**存活时间。这是一个 跳数计数器。每个转发节点都会将ttl减1，当ttl变为0时，将丢弃数据包，并发回一条ICMPv4超时消息，以避免数据包因某种原因被无休止的转发。</li><li>**protocol：**数据包的第4层协议，如IPPROTO_TCP表示TCP流量，而IPPROTO_UDP表示UDP流量。</li><li>**check：**校验和，长16位。校验和是仅根据IPv4报头计算得到的。</li><li>**saddr：**源IPv4地址，长32位。</li><li>**daddr：**目标IPv4地址，长32位。</li></ul><h2 id=ipv4的初始化>IPV4的初始化</h2><p>IPv4数据包的以太类型为0x0800(以太类型存储在14字节的以太网报头的开头两个字节中)。每种协议都必须指定一个协议处理程序并初始化，以便让网络栈能够处理归属于该协议的数据包。本机介绍的IPv4协议处理程序的注册，让读者了解导致IPv4方法对收到的IPv4数据包进行处理的起因。(也就是在这儿注册了IPv4接收回调函数)</p><p><a href=https://github.com/torvalds/linux/blob/master/net/ipv4/af_inet.c/#L1918-L2045>程序</a>部分：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a2f;font-weight:700>static</span> <span style=color:#a2f;font-weight:700>struct</span> packet_type ip_packet_type __read_mostly <span style=color:#666>=</span> {
</span></span><span style=display:flex><span>	.type <span style=color:#666>=</span> cpu_to_be16(ETH_P_IP),
</span></span><span style=display:flex><span>	.func <span style=color:#666>=</span> ip_rcv,
</span></span><span style=display:flex><span>	.list_func <span style=color:#666>=</span> ip_list_rcv,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>static</span> <span style=color:#0b0;font-weight:700>int</span> __init <span style=color:#00a000>inet_init</span>(<span style=color:#0b0;font-weight:700>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	......
</span></span><span style=display:flex><span>	dev_add_pack(<span style=color:#666>&amp;</span>ip_packet_type);
</span></span><span style=display:flex><span>	......
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>dev_add_pack()</code>将<code>ip_rcv()</code>指定为IPv4数据包的协议处理程序。<code>inet_init()</code>执行各种IPv4初始化工作，在引导阶段被调用。</p><h2 id=本机发送数据>本机发送数据</h2><p>从上一节我们知道，在UDP协议发送数据最后，由"<code>udp_send_skb</code>来处理skb，将数据传入到协议栈的下一层，也就是IP协议栈",因此，我们这里从<code>udp_send_skb()</code>开始入手。</p><p>这里大致画了一张UDP数据在IP协议层的流向，来展示数据的发送过程：</p><h2 id=image-20220707082318941httpss2lolinet20220707xjn96qdsgflkx1zpng本机接收数据ip_rcv><img src=https://s2.loli.net/2022/07/07/xJn96QdSGFLkX1z.png alt=image-20220707082318941>本机接收数据ip_rcv</h2><p><img src=https://s2.loli.net/2022/07/06/OSHJbgex2z3cFWv.jpg alt=ip_proto_ip_rcv></p><h3 id=ip_rcv>ip_rcv</h3><p>该函数的定义位于文件<a href=https://github.com/torvalds/linux/blob/master/net/ipv4/ip_input.c#L548-L571>ip_input.c</a>。<code>ip_rcv()</code>主要完成数据包的完整性检查，实际的工作通过<code>ip_rcv_finish()</code>来完成。</p><ul><li>判断是其他主机的数据包，则丢弃；</li><li>检查IPv4的包头大小和版本；</li><li>调用钩子函数NF_INET_PRE_ROUTING，我们这里假设没有调用，直接调用下一个函数ip_rcv_finish，真正处理数据。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic> * 	Main IP Receive routine.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>int</span> <span style=color:#00a000>ip_rcv</span>(<span style=color:#a2f;font-weight:700>struct</span> sk_buff <span style=color:#666>*</span>skb, <span style=color:#a2f;font-weight:700>struct</span> net_device <span style=color:#666>*</span>dev, <span style=color:#a2f;font-weight:700>struct</span> packet_type <span style=color:#666>*</span>pt, <span style=color:#a2f;font-weight:700>struct</span> net_device <span style=color:#666>*</span>orig_dev)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>const</span> <span style=color:#a2f;font-weight:700>struct</span> iphdr <span style=color:#666>*</span>iph;
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>struct</span> net <span style=color:#666>*</span>net;
</span></span><span style=display:flex><span>	u32 len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>/* When the interface is in promisc. mode, drop all the crap
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 * that it receives, do not try to analyse it.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 */</span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* 判断是其他主机的数据包，则丢弃；*/</span>
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>if</span> (skb<span style=color:#666>-&gt;</span>pkt_type <span style=color:#666>==</span> PACKET_OTHERHOST)
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>goto</span> drop;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	net <span style=color:#666>=</span> dev_net(dev);
</span></span><span style=display:flex><span>	__IP_UPD_PO_STATS(net, IPSTATS_MIB_IN, skb<span style=color:#666>-&gt;</span>len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	skb <span style=color:#666>=</span> skb_share_check(skb, GFP_ATOMIC);
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>skb) {
</span></span><span style=display:flex><span>		__IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>goto</span> out;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>pskb_may_pull(skb, <span style=color:#a2f;font-weight:700>sizeof</span>(<span style=color:#a2f;font-weight:700>struct</span> iphdr)))
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>goto</span> inhdr_error;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	iph <span style=color:#666>=</span> ip_hdr(skb);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 *	RFC1122: 3.2.1.2 MUST silently discard any IP frame that fails the checksum.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 *
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 *	Is the datagram acceptable?
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 *
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 *	1.	Length at least the size of an ip header
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 *	2.	Version of 4
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 *	3.	Checksums correctly. [Speed optimisation for later, skip loopback checksums]
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 *	4.	Doesn&#39;t have a bogus length
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>/* 检查IPv4的包头大小和版本 */</span>
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>if</span> (iph<span style=color:#666>-&gt;</span>ihl <span style=color:#666>&lt;</span> <span style=color:#666>5</span> <span style=color:#666>||</span> iph<span style=color:#666>-&gt;</span>version <span style=color:#666>!=</span> <span style=color:#666>4</span>)
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>goto</span> inhdr_error;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	BUILD_BUG_ON(IPSTATS_MIB_ECT1PKTS <span style=color:#666>!=</span> IPSTATS_MIB_NOECTPKTS <span style=color:#666>+</span> INET_ECN_ECT_1);
</span></span><span style=display:flex><span>	BUILD_BUG_ON(IPSTATS_MIB_ECT0PKTS <span style=color:#666>!=</span> IPSTATS_MIB_NOECTPKTS <span style=color:#666>+</span> INET_ECN_ECT_0);
</span></span><span style=display:flex><span>	BUILD_BUG_ON(IPSTATS_MIB_CEPKTS <span style=color:#666>!=</span> IPSTATS_MIB_NOECTPKTS <span style=color:#666>+</span> INET_ECN_CE);
</span></span><span style=display:flex><span>	__IP_ADD_STATS(net,
</span></span><span style=display:flex><span>		       IPSTATS_MIB_NOECTPKTS <span style=color:#666>+</span> (iph<span style=color:#666>-&gt;</span>tos <span style=color:#666>&amp;</span> INET_ECN_MASK),
</span></span><span style=display:flex><span>		       max_t(<span style=color:#0b0;font-weight:700>unsigned</span> <span style=color:#0b0;font-weight:700>short</span>, <span style=color:#666>1</span>, skb_shinfo(skb)<span style=color:#666>-&gt;</span>gso_segs));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>pskb_may_pull(skb, iph<span style=color:#666>-&gt;</span>ihl<span style=color:#666>*</span><span style=color:#666>4</span>))
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>goto</span> inhdr_error;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	iph <span style=color:#666>=</span> ip_hdr(skb);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>if</span> (unlikely(ip_fast_csum((u8 <span style=color:#666>*</span>)iph, iph<span style=color:#666>-&gt;</span>ihl)))
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>goto</span> csum_error;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	len <span style=color:#666>=</span> ntohs(iph<span style=color:#666>-&gt;</span>tot_len);
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>if</span> (skb<span style=color:#666>-&gt;</span>len <span style=color:#666>&lt;</span> len) {
</span></span><span style=display:flex><span>		__IP_INC_STATS(net, IPSTATS_MIB_INTRUNCATEDPKTS);
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>goto</span> drop;
</span></span><span style=display:flex><span>	} <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (len <span style=color:#666>&lt;</span> (iph<span style=color:#666>-&gt;</span>ihl<span style=color:#666>*</span><span style=color:#666>4</span>))
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>goto</span> inhdr_error;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>/* Our transport medium may have padded the buffer out. Now we know it
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 * is IP we can trim to the true length of the frame.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 * Note this now means skb-&gt;len holds ntohs(iph-&gt;tot_len).
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>if</span> (pskb_trim_rcsum(skb, len)) {
</span></span><span style=display:flex><span>		__IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>goto</span> drop;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	skb<span style=color:#666>-&gt;</span>transport_header <span style=color:#666>=</span> skb<span style=color:#666>-&gt;</span>network_header <span style=color:#666>+</span> iph<span style=color:#666>-&gt;</span>ihl<span style=color:#666>*</span><span style=color:#666>4</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>/* Remove any debris in the socket control block */</span>
</span></span><span style=display:flex><span>	memset(IPCB(skb), <span style=color:#666>0</span>, <span style=color:#a2f;font-weight:700>sizeof</span>(<span style=color:#a2f;font-weight:700>struct</span> inet_skb_parm));
</span></span><span style=display:flex><span>	IPCB(skb)<span style=color:#666>-&gt;</span>iif <span style=color:#666>=</span> skb<span style=color:#666>-&gt;</span>skb_iif;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>/* Must drop socket now because of tproxy. */</span>
</span></span><span style=display:flex><span>	skb_orphan(skb);
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>/* 调用钩子函数NF_INET_PRE_ROUTING，我们这里假设没有调用，直接调用下一个函数ip_rcv_finish，真正处理数据*/</span>
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,
</span></span><span style=display:flex><span>		       net, <span style=color:#a2f>NULL</span>, skb, dev, <span style=color:#a2f>NULL</span>,
</span></span><span style=display:flex><span>		       ip_rcv_finish);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a0a000>csum_error</span>:
</span></span><span style=display:flex><span>	__IP_INC_STATS(net, IPSTATS_MIB_CSUMERRORS);
</span></span><span style=display:flex><span><span style=color:#a0a000>inhdr_error</span>:
</span></span><span style=display:flex><span>	__IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS);
</span></span><span style=display:flex><span><span style=color:#a0a000>drop</span>:
</span></span><span style=display:flex><span>	kfree_skb(skb);
</span></span><span style=display:flex><span><span style=color:#a0a000>out</span>:
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>return</span> NET_RX_DROP;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=ip_rcv_finish>ip_rcv_finish</h3><ul><li>skb_dst()用于检查是否有与skb相关联dst对象，dst是一个dst_entry实例，表示路由选择子系统的查找结果。</li><li>如果没有与<code>SKB</code>关联的<code>dst</code>，则由<code>ip_route_input_noref()</code>在路由选择子系统中执行查找，如果查找失败，数据包被丢弃；在<code>ip_route_input_noref()</code>中，查找工作是根据路由选择表和数据包头进行的。在路由选择子系统中查找时，也会设置<code>dst</code>的<code>input</code>和<code>output</code>回调函数。例如，如果需要对数据包进行准发，在路由选择子系统查找时把<code>input</code>回调设置成<code>ip_forward()</code>；如果目的是当前机器，则<code>input</code>是为<code>ip_local_deliver()</code>；如果是组播，则<code>input</code>回调设置为<code>ip_mr_input()</code>。也就是dst决定了数据包的后续走向。</li><li>检查IPv4报头是否包含选项；</li><li>通过<code>dst_input</code>，调用<code>skb_dst(skb)->input(skb)</code>将数据传输到上一层。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a2f;font-weight:700>static</span> <span style=color:#0b0;font-weight:700>int</span> <span style=color:#00a000>ip_rcv_finish</span>(<span style=color:#a2f;font-weight:700>struct</span> net <span style=color:#666>*</span>net, <span style=color:#a2f;font-weight:700>struct</span> sock <span style=color:#666>*</span>sk, <span style=color:#a2f;font-weight:700>struct</span> sk_buff <span style=color:#666>*</span>skb)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>const</span> <span style=color:#a2f;font-weight:700>struct</span> iphdr <span style=color:#666>*</span>iph <span style=color:#666>=</span> ip_hdr(skb);
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>struct</span> rtable <span style=color:#666>*</span>rt;
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>struct</span> net_device <span style=color:#666>*</span>dev <span style=color:#666>=</span> skb<span style=color:#666>-&gt;</span>dev;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>/* if ingress device is enslaved to an L3 master device pass the
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 * skb to its handler for processing
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 */</span>
</span></span><span style=display:flex><span>	skb <span style=color:#666>=</span> l3mdev_ip_rcv(skb);
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>skb)
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>return</span> NET_RX_SUCCESS;
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>/*skb_dst()用于检查是否有与skb相关联dst对象*/</span>
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>if</span> (net<span style=color:#666>-&gt;</span>ipv4.sysctl_ip_early_demux <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>	    <span style=color:#666>!</span>skb_dst(skb) <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>	    <span style=color:#666>!</span>skb<span style=color:#666>-&gt;</span>sk <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>	    <span style=color:#666>!</span>ip_is_fragment(iph)) {
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>const</span> <span style=color:#a2f;font-weight:700>struct</span> net_protocol <span style=color:#666>*</span>ipprot;
</span></span><span style=display:flex><span>		<span style=color:#0b0;font-weight:700>int</span> protocol <span style=color:#666>=</span> iph<span style=color:#666>-&gt;</span>protocol;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		ipprot <span style=color:#666>=</span> rcu_dereference(inet_protos[protocol]);
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>if</span> (ipprot <span style=color:#666>&amp;&amp;</span> ipprot<span style=color:#666>-&gt;</span>early_demux) {
</span></span><span style=display:flex><span>			ipprot<span style=color:#666>-&gt;</span>early_demux(skb);
</span></span><span style=display:flex><span>			<span style=color:#080;font-style:italic>/* must reload iph, skb-&gt;head might have changed */</span>
</span></span><span style=display:flex><span>			iph <span style=color:#666>=</span> ip_hdr(skb);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 *	Initialise the virtual path cache for the packet. It describes
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 *	how the packet travels inside Linux networking.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>	 */</span>
</span></span><span style=display:flex><span>	 <span style=color:#080;font-style:italic>/*如果没有与SKB关联的dst，则由ip_route_input_noref()在卤藕选择子系统中执行查找，如果查找失败，数据包被丢弃。*/</span>
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>if</span> (<span style=color:#666>!</span>skb_valid_dst(skb)) {
</span></span><span style=display:flex><span>		<span style=color:#0b0;font-weight:700>int</span> err <span style=color:#666>=</span> ip_route_input_noref(skb, iph<span style=color:#666>-&gt;</span>daddr, iph<span style=color:#666>-&gt;</span>saddr,
</span></span><span style=display:flex><span>					       iph<span style=color:#666>-&gt;</span>tos, dev);
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>if</span> (unlikely(err)) {
</span></span><span style=display:flex><span>			<span style=color:#a2f;font-weight:700>if</span> (err <span style=color:#666>==</span> <span style=color:#666>-</span>EXDEV)
</span></span><span style=display:flex><span>				__NET_INC_STATS(net, LINUX_MIB_IPRPFILTER);
</span></span><span style=display:flex><span>			<span style=color:#a2f;font-weight:700>goto</span> drop;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080>#ifdef CONFIG_IP_ROUTE_CLASSID
</span></span></span><span style=display:flex><span><span style=color:#080></span>	<span style=color:#a2f;font-weight:700>if</span> (unlikely(skb_dst(skb)<span style=color:#666>-&gt;</span>tclassid)) {
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>struct</span> ip_rt_acct <span style=color:#666>*</span>st <span style=color:#666>=</span> this_cpu_ptr(ip_rt_acct);
</span></span><span style=display:flex><span>		u32 idx <span style=color:#666>=</span> skb_dst(skb)<span style=color:#666>-&gt;</span>tclassid;
</span></span><span style=display:flex><span>		st[idx<span style=color:#666>&amp;</span><span style=color:#666>0xFF</span>].o_packets<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>		st[idx<span style=color:#666>&amp;</span><span style=color:#666>0xFF</span>].o_bytes <span style=color:#666>+=</span> skb<span style=color:#666>-&gt;</span>len;
</span></span><span style=display:flex><span>		st[(idx<span style=color:#666>&gt;&gt;</span><span style=color:#666>16</span>)<span style=color:#666>&amp;</span><span style=color:#666>0xFF</span>].i_packets<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>		st[(idx<span style=color:#666>&gt;&gt;</span><span style=color:#666>16</span>)<span style=color:#666>&amp;</span><span style=color:#666>0xFF</span>].i_bytes <span style=color:#666>+=</span> skb<span style=color:#666>-&gt;</span>len;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#080>#endif
</span></span></span><span style=display:flex><span><span style=color:#080></span>	<span style=color:#080;font-style:italic>/*检查IPv4报头是否包含选项，不包含时这里ihl是4*/</span>
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>if</span> (iph<span style=color:#666>-&gt;</span>ihl <span style=color:#666>&gt;</span> <span style=color:#666>5</span> <span style=color:#666>&amp;&amp;</span> ip_rcv_options(skb))
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>goto</span> drop;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	rt <span style=color:#666>=</span> skb_rtable(skb);
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>if</span> (rt<span style=color:#666>-&gt;</span>rt_type <span style=color:#666>==</span> RTN_MULTICAST) {
</span></span><span style=display:flex><span>		__IP_UPD_PO_STATS(net, IPSTATS_MIB_INMCAST, skb<span style=color:#666>-&gt;</span>len);
</span></span><span style=display:flex><span>	} <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (rt<span style=color:#666>-&gt;</span>rt_type <span style=color:#666>==</span> RTN_BROADCAST) {
</span></span><span style=display:flex><span>		__IP_UPD_PO_STATS(net, IPSTATS_MIB_INBCAST, skb<span style=color:#666>-&gt;</span>len);
</span></span><span style=display:flex><span>	} <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> (skb<span style=color:#666>-&gt;</span>pkt_type <span style=color:#666>==</span> PACKET_BROADCAST <span style=color:#666>||</span>
</span></span><span style=display:flex><span>		   skb<span style=color:#666>-&gt;</span>pkt_type <span style=color:#666>==</span> PACKET_MULTICAST) {
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>struct</span> in_device <span style=color:#666>*</span>in_dev <span style=color:#666>=</span> __in_dev_get_rcu(dev);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#080;font-style:italic>/* RFC 1122 3.3.6:
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>		 *
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>		 *   When a host sends a datagram to a link-layer broadcast
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>		 *   address, the IP destination address MUST be a legal IP
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>		 *   broadcast or IP multicast address.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>		 *
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>		 *   A host SHOULD silently discard a datagram that is received
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>		 *   via a link-layer broadcast (see Section 2.4) but does not
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>		 *   specify an IP multicast or broadcast destination address.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>		 *
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>		 * This doesn&#39;t explicitly say L2 *broadcast*, but broadcast is
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>		 * in a way a form of multicast and the most common use case for
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>		 * this is 802.11 protecting against cross-station spoofing (the
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>		 * so-called &#34;hole-196&#34; attack) so do it for both.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>		 */</span>
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>if</span> (in_dev <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>		    IN_DEV_ORCONF(in_dev, DROP_UNICAST_IN_L2_MULTICAST))
</span></span><span style=display:flex><span>			<span style=color:#a2f;font-weight:700>goto</span> drop;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#080;font-style:italic>/*通过dst_input，调用skb_dst(skb)-&gt;input(skb)*/</span>
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>return</span> dst_input(skb);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a0a000>drop</span>:
</span></span><span style=display:flex><span>	kfree_skb(skb);
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>return</span> NET_RX_DROP;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><div class=post-tags><a href=/tags/%e8%87%aa%e4%b8%8a%e8%80%8c%e4%b8%8b%e7%90%86%e8%a7%a3%e5%86%85%e6%a0%b8%e7%bd%91%e7%bb%9c rel=tag title=自上而下理解内核网络>#自上而下理解内核网络#</a></div><div class=post-nav><div class=article-copyright><div class=article-copyright-img><img src=/img/qq_qrcode.png width=129px height=129px><div style=text-align:center>微信扫一扫关注</div></div><div class=article-copyright-info><p><span>声明：</span>自上而下理解内核网络(五)---网络层（IP协议）数据的接收与发送</p><p><span>链接：</span>https://mdxz2048.github.io/post/study_linux_tcp_in_linux_05/</p><p><span>作者：</span>MD小智</p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/3.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作实属不易，如有帮助，那就打赏博主些许茶钱吧 ^_^</div><button id=rewardButton disable=enable onclick='var qr=document.getElementById("QR");qr.style.display==="none"?qr.style.display="block":qr.style.display="none"'>
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/img/wechat-pay.png alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=/img/ali-pay.png alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=https://mdxz2048.github.io/post/study_programmer_cross_compile_for_gdb_on_ubuntu20/ rel=next title=在Ubuntu上交叉编译gdb和gdbserver><i class="fa fa-chevron-left"></i> 在Ubuntu上交叉编译gdb和gdbserver</a></div><div class="post-nav-prev post-nav-item"><a href=https://mdxz2048.github.io/post/study_valgrind_memcheck/ rel=prev title=内存调试工具Valgrind之Memcheck>内存调试工具Valgrind之Memcheck
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target=post-toc-wrap>文章目录</li><li class=sidebar-nav-overview data-target=site-overview>站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/img/avatar.png alt=MD小智><p class=site-author-name itemprop=name>MD小智</p><p class="site-description motion-element" itemprop=description>我们会高估自己所拥有的一切！</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>37</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>5</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>46</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/mdxz2048 target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>
GitHub</a></span></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>
标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/%E7%BC%96%E7%A0%81>编码</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%90%86%E8%A7%A3%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C>自上而下理解内核网络</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5>文件同步</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/12306bypass>12306bypass</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/asn.1>Asn.1</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/asn1c%E7%BC%96%E8%AF%91%E5%99%A8>Asn1c编译器</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/d%E8%A7%A6%E5%8F%91%E5%99%A8>D触发器</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/ean13>Ean13</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/gdb%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91>Gdb交叉编译</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/hexo>Hexo</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class=post-toc><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#网络层的数据和路线>网络层的数据和路线</a><ul><li><a href=#ipv4协议首部>ipv4协议首部</a></li></ul></li><li><a href=#ipv4的初始化>IPV4的初始化</a></li><li><a href=#本机发送数据>本机发送数据</a></li><li><a href=#image-20220707082318941httpss2lolinet20220707xjn96qdsgflkx1zpng本机接收数据ip_rcv><img src=https://s2.loli.net/2022/07/07/xJn96QdSGFLkX1z.png alt=image-20220707082318941>本机接收数据ip_rcv</a><ul><li><a href=#ip_rcv>ip_rcv</a></li><li><a href=#ip_rcv_finish>ip_rcv_finish</a></li></ul></li></ul></nav></div></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2010 - 2024</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=copyright-author>MD小智</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.96.0</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span class=site-uv><i class="fa fa-user"></i>
<span class=busuanzi-value id=busuanzi_value_site_uv></span></span>
<span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i>
<span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div><div class=license-info><span class=storage-info>Storage by
<a href=http://github.com/ style=font-weight:700 target=_blank>GitHub</a></span>
<span class=separator-line>/</span>
<span class=license-num><a href=http://blog.mddxz.top/ target=_blank>MD小智</a></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i>
<span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/2.1.4/jquery.min.js></script>
<script type=text/javascript src=https://mdxz2048.github.io/js/search.js></script>
<script type=text/javascript src=https://mdxz2048.github.io/js/affix.js></script>
<script type=text/javascript src=https://mdxz2048.github.io/js/scrollspy.js></script>
<script type=text/javascript>function detectIE(){var e=window.navigator.userAgent,t=e.indexOf("MSIE "),n=e.indexOf("Trident/"),s=e.indexOf("Edge/");return t>0||n>0||s>0?-1:1}function getCntViewHeight(){var t=$("#content").height(),e=$(window).height(),n=t>e?t-e:$(document).height()-e;return n}function getScrollbarWidth(){var e=$("<div />").addClass("scrollbar-measure").prependTo("body"),t=e[0],n=t.offsetWidth-t.clientWidth;return e.remove(),n}function registerBackTop(){var t=50,e=$(".back-to-top");$(window).on("scroll",function(){e.toggleClass("back-to-top-on",window.pageYOffset>t);var s=$(window).scrollTop(),o=getCntViewHeight(),i=s/o,n=Math.round(i*100),a=n>100?100:n;$("#scrollpercent>span").html(a)}),e.on("click",function(){$("html,body").animate({scrollTop:0,screenLeft:0},800)})}function initScrollSpy(){var e=".post-toc",s=$(e),t=".active-current";s.on("activate.bs.scrollspy",function(){var t=$(e+" .active").last();n(),t.addClass("active-current")}).on("clear.bs.scrollspy",n),$("body").scrollspy({target:e});function n(){$(e+" "+t).removeClass(t.substring(1))}}function initAffix(){var e=$(".header-inner").height(),t=parseInt($(".main").css("padding-bottom"),10),n=e+10;$(".sidebar-inner").affix({offset:{top:n,bottom:t}}),$(document).on("affixed.bs.affix",function(){updateTOCHeight(document.body.clientHeight-100)})}function initTOCDimension(){$(window).on("resize",function(){e&&clearTimeout(e),e=setTimeout(function(){var e=document.body.clientHeight-100;updateTOCHeight(e)},0)}),updateTOCHeight(document.body.clientHeight-100);var e,t=getScrollbarWidth();$(".post-toc").css("width","calc(100% + "+t+"px)")}function updateTOCHeight(e){e=e||"auto",$(".post-toc").css("max-height",e)}$(function(){var t=$(".header-inner").height()+10,n,s,e,o;$("#sidebar").css({'margin-top':t}).show(),n=parseInt($("#sidebar").css("margin-top")),s=parseInt($(".sidebar-inner").css("height")),e=n+s,o=$(".content-wrap").height(),o<e&&$(".content-wrap").css("min-height",e),$(".site-nav-toggle").on("click",function(){var e=$(".site-nav"),o=$(".toggle"),t="site-nav-on",i="toggle-close",n=e.hasClass(t),a=n?"slideUp":"slideDown",s=n?"removeClass":"addClass";e.stop()[a]("normal",function(){e[s](t),o[s](i)})}),registerBackTop(),initScrollSpy(),initAffix(),initTOCDimension(),$(".sidebar-nav-toc").click(function(){$(this).addClass("sidebar-nav-active"),$(this).next().removeClass("sidebar-nav-active"),$("."+$(this).next().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)}),$(".sidebar-nav-overview").click(function(){$(this).addClass("sidebar-nav-active"),$(this).prev().removeClass("sidebar-nav-active"),$("."+$(this).prev().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)})})</script><script src=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.js></script>
<script type=text/javascript>$(function(){$(".post-body").viewer()})</script><script>(function(){var e=document.createElement("script"),t,n=window.location.protocol.split(":")[0];n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script></body></html>
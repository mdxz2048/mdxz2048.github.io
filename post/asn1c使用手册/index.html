<!doctype html><html lang=zh-cn dir=content/zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>ASN1C使用手册 - MD小智</title><meta name=keywords content="博客,程序员,架构师,思考,读书,笔记,技术,分享"><meta name=author content="MD小智"><meta property="og:title" content="ASN1C使用手册"><meta property="og:site_name" content="MD小智"><meta property="og:image" content="https://mdxz2048.github.io/img/author.jpg"><meta name=title content="ASN1C使用手册 - MD小智"><meta name=description content="欢迎来到MD小智的个人站点，这里主要分享软件、工具教程、技术学习和思考"><link rel="shortcut icon" href=https://mdxz2048.github.io/img/favicon.ico><link rel=apple-touch-icon href=https://mdxz2048.github.io/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=https://mdxz2048.github.io/img/apple-touch-icon.png><link href=//cdn.bootcdn.net/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.css rel=stylesheet><link href=https://mdxz2048.github.io/css/main.css rel=stylesheet type=text/css><link href=https://mdxz2048.github.io/css/syntax.css rel=stylesheet type=text/css></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span>
<span class=site-title>MD小智</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>学习-思考-分享</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class=menu-item><a href=/categories rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>分类</a></li><li class=menu-item><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=/about.html rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于我</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span>
<span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://mdxz2048.github.io/post/asn1c%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/ itemprop=url>ASN1C使用手册</a></h1><div class=post-meta><span class=post-time><i class="fa fa-calendar-o fa-fw"></i>
<span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2022-06-09">2022-06-09</time></span>
<span class=post-category>&nbsp; | &nbsp;
<i class="fa fa-folder-o fa-fw"></i>
<span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a class=post-category-a href=/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B itemprop=url rel=index><span itemprop=name>工具教程</span></a>
&nbsp;</span></span>
<span>|
<i class="fa fa-file-word-o fa-fw"></i>
<span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>10713 字</span></span>
<span>|
<i class="fa fa-eye fa-fw"></i>
<span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>22分钟</span></span>
<span id=/post/asn1c%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/ class=leancloud_visitors data-flag-title=ASN1C使用手册>|
<i class="fa fa-binoculars fa-fw"></i>
<span class=post-meta-item-text>阅读次数：</span>
<span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><p>在介绍本文的主角asn1c之前，我们这里先看一下<a href=https://zh.m.wikipedia.org/zh-hans/ASN.1>维基百科</a>对ASN.1标准的描述：</p><p><em>在<a href=https://zh.m.wikipedia.org/wiki/%E7%94%B5%E4%BF%A1>电信</a>和<a href=https://zh.m.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C>计算机网络</a>领域，<strong>ASN.1</strong>（<strong>Abstract Syntax Notation One</strong>) 是一套<a href=https://zh.m.wikipedia.org/wiki/%E6%A0%87%E5%87%86>标准</a>，是描述<a href=https://zh.m.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE>数据</a>的表示、编码、传输、解码的灵活的记法。它提供了一套正式、无歧义和精确的规则以描述独立于特定计算机硬件的对象结构。</em></p><p>简单来说，ASN.1定义了一套描述数据的描述方法，这种方法与语言无关，无论是C语言、Java还是Go，都能通过语言本身的语法来进行定义、描述数据。在通信行业中，经常使用ASN.1来定义数据。</p><p>我们这里要介绍的<em>asn1c</em>是一个<strong>基于ASN.1语法的编译器</strong>。能根据给定的<strong>ASN.1</strong>描述文件来生成对应的C语言代码，包含了<em>BER/OER/PER/XER</em>多种格式的编解码C语言接口，有助于加快嵌入式设备对ASN.1数据的理解和处理。</p><h2 id=开源asn1编译器介绍>开源ASN.1编译器介绍</h2><p><em>ANS1C</em>的全称是<em>ASN.1 Compiler</em>，主要用来根据ASN.1文件来生成对应的兼容C++的C代码。支持<em>BER/OER/PER/XER</em>多种格式的编解码。</p><p>ASN1C是一个编译器，以ASN.1语法和ASN.1文件生成语法树，然后编译出目标语言，我们这里主要用C语言，以后要学习编译器，相信研究一下asn1c也是个不错的选择，这里我们先了解它的使用。</p><ul><li>作者：Lev Walkin <a href=mailto:vlm@lionet.info>vlm@lionet.info</a></li><li>ASN.1版本：0.9.29</li><li>开源地址：<a href=https://github.com/vlm/asn1c>asn1c</a></li></ul><h2 id=安装>安装</h2><p>以下演示在<em>Ubuntu20.04</em>虚拟机上，通过源码安装asn1c编译器，其他平台过程类似。</p><h3 id=环境依赖httpsgithubcomvlmasn1cblobmasterrequirementsmd><a href=https://github.com/vlm/asn1c/blob/master/REQUIREMENTS.md>环境依赖</a></h3><ul><li>automake大于1.15</li><li>libtool</li><li>bison等于2.x，实测3.5.1版本也可以使用</li><li>flex</li></ul><h3 id=从源码编译httpsgithubcomvlmasn1cblobmasterinstallmdcompiling-from-sources><a href=https://github.com/vlm/asn1c/blob/master/INSTALL.md#compiling-from-sources>从源码编译</a></h3><ol><li><p>执行如下指令，下载源码到本地，然后进入<em>asn1c</em>文件夹；</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>git clone git@github.com:vlm/asn1c.git
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> asn1c
</span></span></code></pre></div></li><li><p>使用默认配置设置工程：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#a2f>test</span> -f configure <span style=color:#666>||</span> autoreconf -iv
</span></span><span style=display:flex><span>./configure
</span></span><span style=display:flex><span>make
</span></span></code></pre></div><p>配置成功后效果如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>╭─ caeri@ubuntu  ~/lzp/GIT/asn1c                                                                                                                                         
</span></span><span style=display:flex><span>╰─ <span style=color:#a2f>test</span> -f configure <span style=color:#666>||</span> autoreconf -iv
</span></span><span style=display:flex><span>utoreconf: Entering directory <span style=color:#b44>`</span>.<span style=color:#b44>&#39;
</span></span></span><span style=display:flex><span><span style=color:#b44>.......
</span></span></span><span style=display:flex><span><span style=color:#b44>onfigure.ac:5: installing &#39;</span>config/install-sh<span style=color:#b44>&#39;
</span></span></span><span style=display:flex><span><span style=color:#b44>configure.ac:5: installing &#39;</span>config/missing<span style=color:#b44>&#39;
</span></span></span><span style=display:flex><span><span style=color:#b44>parallel-tests: installing &#39;</span>config/test-driver<span style=color:#b44>&#39;
</span></span></span><span style=display:flex><span><span style=color:#b44>asn1-tools/enber/Makefile.am: installing &#39;</span>config/depcomp<span style=color:#b44>&#39;
</span></span></span><span style=display:flex><span><span style=color:#b44>autoreconf: running: gnu-configize
</span></span></span><span style=display:flex><span><span style=color:#b44>autoreconf: Leaving directory `.&#39;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>╭─ caeri@ubuntu  ~/lzp/GIT/asn1c                                                                                                                                              
</span></span><span style=display:flex><span>╰─ ./configure
</span></span><span style=display:flex><span>checking <span style=color:#a2f;font-weight:700>for</span> a BSD-compatible install... /usr/bin/install -c
</span></span><span style=display:flex><span>......
</span></span><span style=display:flex><span>config.status: creating config.h
</span></span><span style=display:flex><span>config.status: executing depfiles commands
</span></span><span style=display:flex><span>config.status: executing libtool commands
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>╭─ caeri@ubuntu  ~/lzp/GIT/asn1c                                                                                                                                           
</span></span><span style=display:flex><span>╰─ make 
</span></span><span style=display:flex><span>make  all-recursive
</span></span><span style=display:flex><span>make<span style=color:#666>[</span>1<span style=color:#666>]</span>: Entering directory <span style=color:#b44>&#39;/home/caeri/lzp/GIT/asn1c&#39;</span>
</span></span><span style=display:flex><span>Making all in libasn1common
</span></span><span style=display:flex><span>......
</span></span><span style=display:flex><span>make<span style=color:#666>[</span>2<span style=color:#666>]</span>: Entering directory <span style=color:#b44>&#39;/home/caeri/lzp/GIT/asn1c&#39;</span>
</span></span><span style=display:flex><span>make<span style=color:#666>[</span>2<span style=color:#666>]</span>: Leaving directory <span style=color:#b44>&#39;/home/caeri/lzp/GIT/asn1c&#39;</span>
</span></span><span style=display:flex><span>make<span style=color:#666>[</span>1<span style=color:#666>]</span>: Leaving directory <span style=color:#b44>&#39;/home/caeri/lzp/GIT/asn1c&#39;</span>
</span></span></code></pre></div></li><li><p>编译成功后，执行如下指令，进行安装</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>make install
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>╭─ caeri@ubuntu  ~/lzp/GIT/asn1c   master  INSERT                                                                                                                                                
</span></span><span style=display:flex><span>╰─ make install
</span></span><span style=display:flex><span>Making install in libasn1common
</span></span><span style=display:flex><span>......
</span></span><span style=display:flex><span>/usr/bin/mkdir -p <span style=color:#b44>&#39;/usr/local/share/doc/asn1c&#39;</span>
</span></span><span style=display:flex><span>/usr/bin/install -c -m <span style=color:#666>644</span> README.md INSTALL.md REQUIREMENTS.md FAQ ChangeLog BUGS <span style=color:#b44>&#39;/usr/local/share/doc/asn1c&#39;</span>
</span></span><span style=display:flex><span>make<span style=color:#666>[</span>2<span style=color:#666>]</span>: Leaving directory <span style=color:#b44>&#39;/home/caeri/lzp/GIT/asn1c&#39;</span>
</span></span><span style=display:flex><span>make<span style=color:#666>[</span>1<span style=color:#666>]</span>: Leaving directory <span style=color:#b44>&#39;/home/caeri/lzp/GIT/asn1c&#39;</span>
</span></span></code></pre></div></li><li><p>执行<code>man asn1c</code>检查是否安装成功，如果有相关手册打印出来即为安装成功。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>asn1c<span style=color:#666>(</span>1<span style=color:#666>)</span>                                                                                    Version 0.9.29                                                                                   asn1c<span style=color:#666>(</span>1<span style=color:#666>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>NAME
</span></span><span style=display:flex><span>     asn1c -- the ASN.1 Compiler
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SYNOPSIS
</span></span><span style=display:flex><span>     asn1c <span style=color:#666>[</span>-E <span style=color:#666>[</span>-F<span style=color:#666>]</span> | -P | -R<span style=color:#666>]</span>
</span></span><span style=display:flex><span>     <span style=color:#666>[</span>-Sdir<span style=color:#666>]</span> <span style=color:#666>[</span>-X<span style=color:#666>]</span>
</span></span><span style=display:flex><span>     <span style=color:#666>[</span>-Wdebug-...<span style=color:#666>]</span> <span style=color:#666>[</span>-foption<span style=color:#666>]</span> <span style=color:#666>[</span>-gen-option<span style=color:#666>]</span> <span style=color:#666>[</span>-pdu<span style=color:#666>={</span>all|auto|Type<span style=color:#666>}]</span>
</span></span><span style=display:flex><span>     <span style=color:#666>[</span>-print-option<span style=color:#666>]</span>
</span></span><span style=display:flex><span>     input-filenames...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DESCRIPTION
</span></span><span style=display:flex><span>     asn1c compiles ASN.1 specifications into a <span style=color:#a2f>set</span> of target language <span style=color:#666>(</span>C/C++<span style=color:#666>)</span> encoders and decoders <span style=color:#a2f;font-weight:700>for</span> BER, DER, PER, XER, OER and other encoding rules.
</span></span></code></pre></div></li></ol><h2 id=快速开始示例>快速开始示例</h2><h3 id=11-一个rectangle转换和调试>1.1 一个“Rectangle”转换和调试</h3><p>最常见的需求是为一个已经存在的ASN.1数据文件，创建一个分析工具。让我们来为一个存在的Rectangle的二进制文件构建一个BER、OER、PER、XER(XML)的转换器。如下：</p><ol><li><p>在<code>ans1c</code>文件夹下，新建一个<em>rectangle.asn</em> 文件，写入如下内容：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ASN.1 data-lang=ASN.1><span style=display:flex><span>RectangleModule DEFINITIONS ::= BEGIN
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Rectangle ::= SEQUENCE {
</span></span><span style=display:flex><span>height INTEGER,
</span></span><span style=display:flex><span>width INTEGER
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>END
</span></span></code></pre></div></li><li><p>执行如下指令，使用asn1c将其编译成.c和.h文件</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>asn1c -no-gen-example rectangle.asn
</span></span></code></pre></div></li><li><p>执行如下指令，生成一个转换器：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>make -f converter-example.mk
</span></span></code></pre></div></li><li><p>完成后，使用二进制文件进行转换：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>./converter-example -h
</span></span></code></pre></div><p>效果如下</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>╭─ caeri@ubuntu  ~/lzp/GIT/asn1c   master ?  INSERT           SIGINT<span style=color:#666>(</span>2<span style=color:#666>)</span> ↵
</span></span><span style=display:flex><span>╰─ ./converter-example -h   
</span></span><span style=display:flex><span>Usage: ./converter-example <span style=color:#666>[</span>options<span style=color:#666>]</span> &lt;datafile&gt; ...
</span></span><span style=display:flex><span>Where options are:
</span></span><span style=display:flex><span>-iber        Input is in BER <span style=color:#666>(</span>Basic Encoding Rules<span style=color:#666>)</span> or DER
</span></span><span style=display:flex><span>-ioer        Input is in OER <span style=color:#666>(</span>Octet Encoding Rules<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-iper        Input is in Unaligned PER <span style=color:#666>(</span>Packed Encoding Rules<span style=color:#666>)</span> <span style=color:#666>(</span>DEFAULT<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-ixer        Input is in XER <span style=color:#666>(</span>XML Encoding Rules<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-oder        Output as DER <span style=color:#666>(</span>Distinguished Encoding Rules<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-ooer        Output as Canonical OER <span style=color:#666>(</span>Octet Encoding Rules<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-oper        Output as Unaligned PER <span style=color:#666>(</span>Packed Encoding Rules<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-oxer        Output as XER <span style=color:#666>(</span>XML Encoding Rules<span style=color:#666>)</span> <span style=color:#666>(</span>DEFAULT<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-otext       Output as plain semi-structured text
</span></span><span style=display:flex><span>-onull       Verify <span style=color:#666>(</span>decode<span style=color:#666>)</span> input, but <span style=color:#a2f;font-weight:700>do</span> not output
</span></span><span style=display:flex><span>-per-nopad   Assume PER PDUs are not padded <span style=color:#666>(</span>-iper<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-p &lt;PDU&gt;     Specify PDU <span style=color:#a2f>type</span> to decode
</span></span><span style=display:flex><span>-p list      List available PDUs
</span></span><span style=display:flex><span>-1           Decode only the first PDU in file
</span></span><span style=display:flex><span>-b &lt;size&gt;    Set the i/o buffer size <span style=color:#666>(</span>default is 8192<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-c           Check ASN.1 constraints after decoding
</span></span><span style=display:flex><span>-d           Enable debugging <span style=color:#666>(</span>-dd is even better<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-n &lt;num&gt;     Process files &lt;num&gt; <span style=color:#a2f>times</span>
</span></span><span style=display:flex><span>-s &lt;size&gt;    Set the stack usage limit <span style=color:#666>(</span>default is 30000<span style=color:#666>)</span>
</span></span></code></pre></div></li></ol><h3 id=12-一个rectangle编码器>1.2 一个“Rectangle”编码器</h3><p>这个示例将帮助你新增一个“Rectangle”的BER、XER编码器。</p><ol><li><p>为了方便查看文件，我们在<em>asn1c</em>下新建<em>asn_files</em>和<em>out</em>两个文件夹，分别用来存放asn源文件和输出文件；</p></li><li><p>在<code>asn_files</code>下增加一个文件<em>rectangle.asn</em> ，内容如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ASN.1 data-lang=ASN.1><span style=display:flex><span>RectangleModule DEFINITIONS ::= BEGIN
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Rectangle ::= SEQUENCE {
</span></span><span style=display:flex><span>height INTEGER,
</span></span><span style=display:flex><span>width INTEGER
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>END
</span></span></code></pre></div></li><li><p>执行如下指令，使用asn1c将其编译成.c和.h文件</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>asn1c -no-gen-example -D out asn_files/rectangle.asn
</span></span></code></pre></div></li><li><p>到这里，就可以在<em>out</em>文件夹下得到多个文件，其中包含了<em>Rectangle.c</em> 和<em>Rectangle.h</em>。</p></li><li><p>创建一个包含<em>main.c</em>的文件，在main()函数中创建结构体<code>Rectangle_t</code>，然后使用BER、XER编码规则进行编码。main.c内容如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* @Author       : lv zhipeng
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* @Date         : 2022-06-09 16:10:41
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* @LastEditors  : lv zhipeng
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* @LastEditTime : 2022-06-09 16:11:55
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* @FilePath     : /asn1c/out/main.c
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* @Description  :
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>*
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>*/</span>
</span></span><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;Rectangle.h&gt; /* Rectangle ASN.1 type */</span><span style=color:#080>
</span></span></span><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;stdio.h&gt;</span><span style=color:#080>
</span></span></span><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;sys/types.h&gt;</span><span style=color:#080>
</span></span></span><span style=display:flex><span><span style=color:#080></span><span style=color:#080;font-style:italic>/* Write the encoded output into some FILE stream. */</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>static</span> <span style=color:#0b0;font-weight:700>int</span>
</span></span><span style=display:flex><span><span style=color:#00a000>write_out</span>(<span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>buffer, size_t size, <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>app_key) {
</span></span><span style=display:flex><span>  FILE <span style=color:#666>*</span>out_fp <span style=color:#666>=</span> app_key;
</span></span><span style=display:flex><span>  size_t wrote <span style=color:#666>=</span> fwrite(buffer, <span style=color:#666>1</span>, size, out_fp);
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>return</span> (wrote <span style=color:#666>==</span> size) <span style=color:#666>?</span> <span style=color:#666>0</span> <span style=color:#666>:</span> <span style=color:#666>-</span><span style=color:#666>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>int</span>
</span></span><span style=display:flex><span><span style=color:#00a000>main</span>(<span style=color:#0b0;font-weight:700>int</span> ac, <span style=color:#0b0;font-weight:700>char</span> <span style=color:#666>**</span>av) {
</span></span><span style=display:flex><span>  Rectangle_t <span style=color:#666>*</span>rectangle; <span style=color:#080;font-style:italic>/* Type to encode */</span>
</span></span><span style=display:flex><span>  asn_enc_rval_t ec;      <span style=color:#080;font-style:italic>/* Encoder return value */</span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Allocate the Rectangle_t */</span>
</span></span><span style=display:flex><span>  rectangle <span style=color:#666>=</span> calloc(<span style=color:#666>1</span>, <span style=color:#a2f;font-weight:700>sizeof</span>(Rectangle_t)); <span style=color:#080;font-style:italic>/* not malloc! */</span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span>(<span style=color:#666>!</span>rectangle) {
</span></span><span style=display:flex><span>      perror(<span style=color:#b44>&#34;calloc() failed&#34;</span>);
</span></span><span style=display:flex><span>      exit(<span style=color:#666>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Initialize the Rectangle members */</span>
</span></span><span style=display:flex><span>  rectangle<span style=color:#666>-&gt;</span>height <span style=color:#666>=</span> <span style=color:#666>42</span>; <span style=color:#080;font-style:italic>/* any random value */</span>
</span></span><span style=display:flex><span>  rectangle<span style=color:#666>-&gt;</span>width <span style=color:#666>=</span> <span style=color:#666>23</span>;  <span style=color:#080;font-style:italic>/* any random value */</span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* BER encode the data if filename is given */</span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span>(ac <span style=color:#666>&lt;</span> <span style=color:#666>2</span>) {
</span></span><span style=display:flex><span>fprintf(stderr, <span style=color:#b44>&#34;Specify filename for BER output</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>);
</span></span><span style=display:flex><span>  } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>char</span> <span style=color:#666>*</span>filename <span style=color:#666>=</span> av[<span style=color:#666>1</span>];
</span></span><span style=display:flex><span>      FILE <span style=color:#666>*</span>fp <span style=color:#666>=</span> fopen(filename, <span style=color:#b44>&#34;wb&#34;</span>); <span style=color:#080;font-style:italic>/* for BER output */</span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span>(<span style=color:#666>!</span>fp) {
</span></span><span style=display:flex><span>          perror(filename);
</span></span><span style=display:flex><span>          exit(<span style=color:#666>1</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* Encode the Rectangle type as BER (DER) */</span>
</span></span><span style=display:flex><span>      ec <span style=color:#666>=</span> der_encode(<span style=color:#666>&amp;</span>asn_DEF_Rectangle, rectangle, write_out, fp);
</span></span><span style=display:flex><span>      fclose(fp);
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span>(ec.encoded <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#666>1</span>) {
</span></span><span style=display:flex><span>          fprintf(stderr, <span style=color:#b44>&#34;Could not encode Rectangle(at % s)</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>,
</span></span><span style=display:flex><span>                  ec.failed_type <span style=color:#666>?</span> ec.failed_type<span style=color:#666>-&gt;</span><span style=color:#a0a000>name</span> : <span style=color:#b44>&#34;unknown&#34;</span>);
</span></span><span style=display:flex><span>          exit(<span style=color:#666>1</span>);
</span></span><span style=display:flex><span>      } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>          fprintf(stderr, <span style=color:#b44>&#34;Created % s with BER encoded Rectangle</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>,
</span></span><span style=display:flex><span>                  filename);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Also print the constructed Rectangle XER encoded (XML) */</span>
</span></span><span style=display:flex><span>  xer_fprint(stdout, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, rectangle);
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>; <span style=color:#080;font-style:italic>/* Encoding finished successfully */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>这里有一个asn1c的bug，需要从<em>asn1c</em>源码目录手动复制这几个文件到out目录再编译，否则需要禁用相关OER的编解码，具体解决方案可以看<a href=https://github.com/vlm/asn1c/issues/311>这里</a></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>cd out
</span></span><span style=display:flex><span>cp ../skeletons/BIT_STRING* ./
</span></span><span style=display:flex><span>cp ../skeletons/OCTET_STRING*  ./
</span></span></code></pre></div></li><li><p>编译所有文件，生成可执行文件rencode。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cc -I. -o rencode *.c
</span></span></code></pre></div></li><li><p>这个rencode程序，就是支持BER、XER编码的Rectangle编码器，运行程序可以看到我们在<code>main()</code>函数中填充的数据XER格式的输出：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>╭─ caeri@ubuntu  ~/lzp/GIT/asn1c/out   master ?  INSERT                                                                                                                                            ✔
</span></span><span style=display:flex><span>╰─ ./rencode   
</span></span><span style=display:flex><span>Specify filename <span style=color:#a2f;font-weight:700>for</span> BER output
</span></span><span style=display:flex><span>&lt;Rectangle&gt;
</span></span><span style=display:flex><span>  &lt;height&gt;42&lt;/height&gt;
</span></span><span style=display:flex><span>  &lt;width&gt;23&lt;/width&gt;
</span></span><span style=display:flex><span>&lt;/Rectangle&gt;
</span></span></code></pre></div></li></ol><h3 id=13-一个rectangle解码器>1.3 一个“Rectangle”解码器</h3><p>这个示例将帮助你新增一个“Rectangle”的BER、XER解码器。</p><ol><li><p>新建一个名为rectangle.asn 的文件。内容如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ASN.1 data-lang=ASN.1><span style=display:flex><span>RectangleModule DEFINITIONS ::= BEGIN
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Rectangle ::= SEQUENCE {
</span></span><span style=display:flex><span>height INTEGER,
</span></span><span style=display:flex><span>width INTEGER
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>END
</span></span></code></pre></div></li><li><p>执行如下指令，使用asn1c将其编译成.c和.h文件</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>asn1c -no-gen-example -D out asn_files/rectangle.asn
</span></span></code></pre></div></li><li><p>到这里，就可以在当前文件夹下得到多个文件，其中包含了Rectangle.c 和Rectangle.h。</p></li><li><p>创建一个main.c文件，包含main()函数，该函数接收一个二进制输入文件，它将输入文件按照BER编码规则进行解码为Rectangle 格式，然后会打印输出XML格式的内容。内容如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;Rectangle.h&gt; /* Rectangle ASN.1 type */</span><span style=color:#080>
</span></span></span><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;stdio.h&gt;</span><span style=color:#080>
</span></span></span><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;sys/types.h&gt;</span><span style=color:#080>
</span></span></span><span style=display:flex><span><span style=color:#080></span><span style=color:#0b0;font-weight:700>int</span>
</span></span><span style=display:flex><span><span style=color:#00a000>main</span>(<span style=color:#0b0;font-weight:700>int</span> ac, <span style=color:#0b0;font-weight:700>char</span> <span style=color:#666>**</span>av) {
</span></span><span style=display:flex><span>  <span style=color:#0b0;font-weight:700>char</span> buf[<span style=color:#666>1024</span>];             <span style=color:#080;font-style:italic>/* Temporary buffer */</span>
</span></span><span style=display:flex><span>  asn_dec_rval_t rval;        <span style=color:#080;font-style:italic>/* Decoder return value */</span>
</span></span><span style=display:flex><span>  Rectangle_t <span style=color:#666>*</span>rectangle <span style=color:#666>=</span> <span style=color:#666>0</span>; <span style=color:#080;font-style:italic>/* Type to decode. Note this 01! */</span>
</span></span><span style=display:flex><span>  FILE <span style=color:#666>*</span>fp;                   <span style=color:#080;font-style:italic>/* Input file handler */</span>
</span></span><span style=display:flex><span>  size_t size;                <span style=color:#080;font-style:italic>/* Number of bytes read */</span>
</span></span><span style=display:flex><span>  <span style=color:#0b0;font-weight:700>char</span> <span style=color:#666>*</span>filename;             <span style=color:#080;font-style:italic>/* Input file name */</span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Require a single filename argument */</span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span>(ac <span style=color:#666>!=</span> <span style=color:#666>2</span>) {
</span></span><span style=display:flex><span>      fprintf(stderr, <span style=color:#b44>&#34;Usage: % s&lt;file.ber&gt;</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>, av[<span style=color:#666>0</span>]);
</span></span><span style=display:flex><span>      exit(<span style=color:#666>1</span>);
</span></span><span style=display:flex><span>  } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>      filename <span style=color:#666>=</span> av[<span style=color:#666>1</span>];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Open input file as readିonly binary */</span>
</span></span><span style=display:flex><span>  fp <span style=color:#666>=</span> fopen(filename, <span style=color:#b44>&#34;rb&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span>(<span style=color:#666>!</span>fp) {
</span></span><span style=display:flex><span>      perror(filename);
</span></span><span style=display:flex><span>      exit(<span style=color:#666>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Read up to the buffer size */</span>
</span></span><span style=display:flex><span>  size <span style=color:#666>=</span> fread(buf, <span style=color:#666>1</span>, <span style=color:#a2f;font-weight:700>sizeof</span>(buf), fp);
</span></span><span style=display:flex><span>  fclose(fp);
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span>(<span style=color:#666>!</span>size) {
</span></span><span style=display:flex><span>      fprintf(stderr, <span style=color:#b44>&#34;% s: Empty or broken</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>, filename);
</span></span><span style=display:flex><span>      exit(<span style=color:#666>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Decode the input buffer as Rectangle type */</span>
</span></span><span style=display:flex><span>  rval <span style=color:#666>=</span> ber_decode(<span style=color:#666>0</span>, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, (<span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>**</span>)<span style=color:#666>&amp;</span>rectangle, buf, size);
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span>(rval.code <span style=color:#666>!=</span> RC_OK) {
</span></span><span style=display:flex><span>      fprintf(stderr, <span style=color:#b44>&#34;% s: Broken Rectangle encoding at byte% ld</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44> &#34;</span>, filename,(<span style=color:#0b0;font-weight:700>long</span>)rval.consumed);
</span></span><span style=display:flex><span>      exit(<span style=color:#666>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Print the decoded Rectangle type as XML */</span>
</span></span><span style=display:flex><span>  xer_fprint(stdout, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, rectangle);
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>; <span style=color:#080;font-style:italic>/* Decoding finished successfully */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>编译所有文件，生成可执行文件rencode（<em>注意参考1.2复制缺少的文件</em>）。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cc -I. -o rdecode *.c
</span></span></code></pre></div></li><li><p>这个<code>rdncode</code>程序，就是支持<code>BER</code>、<code>XER</code>编码的<em>Rectangle</em>解码器。</p></li></ol><h3 id=14--给rectangle增加约束数据验证>1.4 给“Rectangle”增加约束(数据验证)</h3><p>此示例显示如何向 ASN.1 规范添加基本约束以及如何调用应用程序中的约束验证代码。</p><ol><li><p>创建名为rectangle.asn的文件。内容如下:</p><p>这里我们对asn的使用手册中rectangle.asn进行了修改，将<code>width INTEGER (0..MAX)</code>修改为<code>width INTEGER (0..200)</code>，因为在使用MAX时，没有指定具体的最大值，所以在后边的<code>asn_check_constraints()</code>时发生错误。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ASN.1 data-lang=ASN.1><span style=display:flex><span>RectangleModuleWithConstraints DEFINITIONS ::= BEGIN
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Rectangle ::= SEQUENCE {
</span></span><span style=display:flex><span>height INTEGER (0..100), -- Value range constraint
</span></span><span style=display:flex><span>width INTEGER (0..200) -- Makes width non-negative
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>END
</span></span></code></pre></div></li><li><p>参考1.3中节，编译文件生成.c和.h。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>asn1c -no-gen-example -D out asn_files/rectangle.asn
</span></span></code></pre></div></li><li><p>新建main.c，将<em>1.2 一个“Rectangle”编码器</em>中的<code>main.c</code>复制过来，然后将如下代码加入到处理程序末尾，部分如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/* Also print the constructed Rectangle XER encoded (XML) */</span>
</span></span><span style=display:flex><span>xer_fprint(stdout, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, rectangle);
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>int</span> ret;<span style=color:#080;font-style:italic>/* Return value */</span>
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>char</span> errbuf[<span style=color:#666>128</span>];   <span style=color:#080;font-style:italic>/* Buffer for error message */</span>
</span></span><span style=display:flex><span>size_t errlen <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>sizeof</span>(errbuf); <span style=color:#080;font-style:italic>/* Size of the buffer */</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* ... here goes the Rectangle decoding code ... */</span>
</span></span><span style=display:flex><span>ret <span style=color:#666>=</span> asn_check_constraints(<span style=color:#666>&amp;</span>asn_DEF_Rectangle, rectangle, errbuf, <span style=color:#666>&amp;</span>errlen);
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* assert(errlen &lt; sizeof(errbuf)); // you may rely on that */</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>if</span>(ret) {
</span></span><span style=display:flex><span>fprintf(stderr, <span style=color:#b44>&#34;Constraint validation failed : % s</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>, errbuf);
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* exit(...); // Replace with appropriate action */</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* ... here goes the Rectangle encoding code ... */</span>
</span></span></code></pre></div></li><li><p>像上一节那样编译所有文件，这里主要要复制</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#a2f>cd</span> out
</span></span><span style=display:flex><span>cp ../skeletons/BIT_STRING* ./
</span></span><span style=display:flex><span>cp ../skeletons/OCTET_STRING*  ./
</span></span><span style=display:flex><span>cc -I. -o rencode *.c
</span></span></code></pre></div></li><li><p>这里我们进行两次实验，分别让填充数据合法和超限，观察程序的检测结果：</p><ul><li><p>第一次，数据合法</p><ul><li><p>填充合法数据</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/* Initialize the Rectangle members */</span>
</span></span><span style=display:flex><span>rectangle<span style=color:#666>-&gt;</span>height <span style=color:#666>=</span> <span style=color:#666>15</span>; <span style=color:#080;font-style:italic>/* any random value */</span>
</span></span><span style=display:flex><span>rectangle<span style=color:#666>-&gt;</span>width <span style=color:#666>=</span> <span style=color:#666>30</span>;   <span style=color:#080;font-style:italic>/* any random value */</span>
</span></span></code></pre></div></li><li><p>执行结果</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>╭─ caeri@ubuntu  ~/lzp/GIT/asn1c/out   master ?  INSERT                                                                                                                                  SIGINT<span style=color:#666>(</span>2<span style=color:#666>)</span> ↵
</span></span><span style=display:flex><span>╰─ ./rencode 
</span></span><span style=display:flex><span>Specify filename <span style=color:#a2f;font-weight:700>for</span> BER output
</span></span><span style=display:flex><span>&lt;Rectangle&gt;
</span></span><span style=display:flex><span>    &lt;height&gt;15&lt;/height&gt;
</span></span><span style=display:flex><span>    &lt;width&gt;30&lt;/width&gt;
</span></span><span style=display:flex><span>&lt;/Rectangle&gt;
</span></span></code></pre></div></li></ul></li><li><p>第二次，数据超限</p><ul><li><p>填充超限数据</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/* Initialize the Rectangle members */</span>
</span></span><span style=display:flex><span>rectangle<span style=color:#666>-&gt;</span>height <span style=color:#666>=</span> <span style=color:#666>150</span>; <span style=color:#080;font-style:italic>/* any random value */</span>
</span></span><span style=display:flex><span>rectangle<span style=color:#666>-&gt;</span>width <span style=color:#666>=</span> <span style=color:#666>300</span>;   <span style=color:#080;font-style:italic>/* any random value */</span>
</span></span></code></pre></div></li><li><p>执行结果</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>╭─ caeri@ubuntu  ~/lzp/GIT/asn1c/out   master ?  INSERT                                                                                                                                            ✔
</span></span><span style=display:flex><span>╰─ ./rencode            
</span></span><span style=display:flex><span>Specify filename <span style=color:#a2f;font-weight:700>for</span> BER output
</span></span><span style=display:flex><span>&lt;Rectangle&gt;
</span></span><span style=display:flex><span>    &lt;height&gt;150&lt;/height&gt;
</span></span><span style=display:flex><span>    &lt;width&gt;300&lt;/width&gt;
</span></span><span style=display:flex><span>&lt;/Rectangle&gt;
</span></span><span style=display:flex><span>Constraint validation failed : INTEGER: constraint failed <span style=color:#666>(</span>Rectangle.c:30<span style=color:#666>)</span>
</span></span></code></pre></div></li></ul></li></ul></li><li><p>至此，数据验证演示完毕。</p></li></ol><h2 id=asn1编译器>ASN.1编译器</h2><h3 id=21-asn1c编译工具>2.1 ASN1C编译工具</h3><p>ASN.1编译器是将ASN.1表示语法中的规范转换为其他一些语言，例如C语言。</p><p>编译器读取(输入)规范，发出(输出)一系列目标语言的结构(struct, union, enum )来实现相应的ASN.1类型。编译器还会创建支持这些结构体序列化/反序列化的代码，代码支持BER、DER、OER、PER、XER的编码规则。</p><p>例如这个ASN.1文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ASN.1 data-lang=ASN.1><span style=display:flex><span>RectangleModule DEFINITIONS ::= BEGIN
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Rectangle ::= SEQUENCE {
</span></span><span style=display:flex><span>height INTEGER, -- Height of the rectangle
</span></span><span style=display:flex><span>width INTEGER --Width of the rectangle
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>END
</span></span></code></pre></div><p>编译器读取上述的ASN.1定义，并生成以下C结构体：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#a2f;font-weight:700>typedef</span> <span style=color:#a2f;font-weight:700>struct</span> Rectangle_s {
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>long</span> height;
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>long</span> width;
</span></span><span style=display:flex><span>} Rectangle_t;
</span></span></code></pre></div><p>asn1c 编译器还创建了用于将此结构转换为独立于平台的解码器代码,解码代码支持将解码内容返回到当前设备。</p><p>用于编译 ASN.1 模块：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SH data-lang=SH><span style=display:flex><span>asn1c &lt;modules.asn&gt;
</span></span></code></pre></div><p>如果多个ASN.1模块包含互相依赖的关系，编译的时候需要包含多个asn文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>asn1c &lt;module1.asn&gt; &lt;module2.asn&gt; ...
</span></span></code></pre></div><p>编译器的参数-E和-EF用来检测解析和语义错误。这些选项将指示编译器按照编译器所理解的进行转换被识别为正确的（-F
参数会尝试修复ASN.1文件中的语法问题）ASN.1 规范，这个参数可以用来检查编译器是否正确支持当前的语法构造。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>asn1c -EF &lt;module-to-test.asn&gt;
</span></span></code></pre></div><p>-P 选项用于将编译后的输出打印到屏幕上，而不是创建一堆当前目录中磁盘上的 .c 和 .h 文件。</p><p>另一个选项 -R，询问编译器只生成需要生成的文件，并阻止生成大量链接支持文件。</p><p>打印编译输出而不是创建多个源文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>asn1c -P &lt;module-to-compile-and-print.asn&gt;
</span></span></code></pre></div><h3 id=22-编译器输出>2.2 编译器输出</h3><p>asn1c编译器会输出一些文件，包括：</p><ul><li>.asn文件中定义的每种ASN类型对应的.c和.h文件。这些文件名的命名类似于ASN.1格式，(例如第一章提到的RectangleModule ASN.1 模块的 Rectangle.c 和 Rectangle.h)。</li><li>一些其他辅助程序的.c和.h文件，例如通用的编码器、解码器和其他有用的demo。</li><li>一个Makefile.am.libasncodecs文件，它显式的列出了所有生成的文件。这个makefile可以用来编译编解码库。</li><li>一个converter-example.c 文件，它包含了main()函数，支持编码和数据格式转换。它可以将给定的PDU文件在BER、XER、OER和PER之间进行转换。有时候我们的应用代码就是在这个文件基础上进行修改。</li><li>一个converter-example.mk 文件，该makefile文件通过编译<em>Makefile.am.libasncodecs</em> 和<em>converterexample.c</em> 文件，为你的ASN数据格式生成一个转换和调试程序。</li></ul><p>只需要几条指令就可以编译所有内容：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>asn1c -pdu<span style=color:#666>=</span>Rectangle *.asn
</span></span><span style=display:flex><span>make -f converte-example.mk <span style=color:#080;font-style:italic># If you use ‘make‘</span>
</span></span></code></pre></div><p>这里有一个小的技巧，因为我们在第一章中，输入的asn文件在asn_files文件夹下，输出在out下，因此我这里编译的时候需要将Makefile.am.libasncodec复制到out下，然后修改<em>converter-example.mk</em>如下部分：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#080;font-style:italic>#修改前
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span>include</span> <span>out/Makefile.am.libasncodec</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>ASN_PROGRAM_SRCS</span> <span style=color:#666>?=</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>	out/converter-example.c
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>#修改后
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span>include</span> <span>Makefile.am.libasncodec</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>ASN_PROGRAM_SRCS</span> <span style=color:#666>?=</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>	converter-example.c
</span></span></code></pre></div><h3 id=23-命令行配置>2.3 命令行配置</h3><p>下边表格总结了ASN1C的命令行选项。</p><table><thead><tr><th>阶段选择选项</th><th>描述</th></tr></thead><tbody><tr><td>-E</td><td>在执行解析阶段后停止，并打印重建的 ASN.1规范代码到标准输出。</td></tr><tr><td>-F</td><td>和-E选项一起使用，指示编译器在 ASN.1 语法树修复阶段后停止并将重构的 ASN.1 规范转储到标准输出。</td></tr><tr><td>-P</td><td>将编译后的输出打印到标准输出，而不是在磁盘上创建目标语言文件。</td></tr><tr><td>-R</td><td>限制编译器只生成 ASN.1 表，省略通常的支持代码。</td></tr><tr><td>-S</td><td>指定文件夹下的ASN.1文件。</td></tr><tr><td>-X</td><td>为指定的ASN.1模块生成XML DTD。</td></tr></tbody></table><table><thead><tr><th>警告选项</th><th>描述</th></tr></thead><tbody><tr><td>-Werror</td><td>将警告视为错误； 如果产生任何警告则中止</td></tr><tr><td>-Wdebug-parser</td><td>在 ASN.1 解析阶段启用解析器调试</td></tr><tr><td>-Wdebug-lexer</td><td>在 ASN.1 解析阶段启用词法分析器调试。</td></tr><tr><td>-Wdebug-fixer</td><td>在修复过程中启用 ASN.1 语法树修复器调试器。</td></tr><tr><td>-Wdebug-compiler</td><td>在实际编译时启用调试</td></tr></tbody></table><table><thead><tr><th>语言配置</th><th>描述</th></tr></thead><tbody><tr><td>-fbless-SIZE</td><td>*允许INTEGER, ENUMERATED和其他类型的约束，通常为了防止数据数值范围超出导致错误禁止该选项，即数值超出范围不会报错。*这违反了ASN.1标准，可能导致生成的代码没有用。<strong>待验证</strong></td></tr><tr><td>-fcompound-names</td><td>对 C 结构使用复杂的名称。如果模块在多个上下文中重用相同的标识符，则使用复杂的名称可以防止名称冲突</td></tr><tr><td>-findirect-choice</td><td>为 CHOICE 类型生成代码时，编译 CHOICE成员作为间接指针而不是内联声明。考虑将此选项与 -fno-includedeps 一起使用以防止循环引用。</td></tr><tr><td>-fincludes-quoted</td><td>在“double”而不是 引号中生成 #include 行。</td></tr><tr><td>-fknown-extern-type=</td><td>假装指定的类型是已知的。 编译器会假设给定类型的目标语言源文件已手动提供。</td></tr><tr><td>-fline-refs</td><td>在生成的代码注释中包含 ASN.1 模块的行号。</td></tr><tr><td>-fno-constraints</td><td>不产生ASN.1的类型约束代码片段，这样可执行文件小一点 。</td></tr><tr><td>-fno-include-deps</td><td>不为非关键项生成#include包含。</td></tr><tr><td>-fwide-types</td><td>使用泛类型定义(INTEGER_t, REAL_t )，而不是机器自身的类型定义(long, double )。</td></tr><tr><td>-no-gen-OER</td><td>不生成OER支持代码</td></tr><tr><td>-no-gen-PER</td><td>不生成PER支持代码</td></tr><tr><td>-no-gen-example</td><td>不生产ASN.1格式转换demo。</td></tr><tr><td>-pdu={all|all|Type</td><td>为指定类型|所有类型 创建 PDU 表</td></tr></tbody></table><table><thead><tr><th>输出选项</th><th>描述</th></tr></thead><tbody><tr><td>-print-class-matrix</td><td>当配置了-EF选项，这个选项指示编译器打印收集到的ASN对象矩阵。</td></tr><tr><td>-print-constraints</td><td>当配置了-EF选项，此选项指示编译器打印其对子类型约束的内部理解。</td></tr><tr><td>-print-lines</td><td>在 -E 输出中生成“&ndash; #line”注释</td></tr></tbody></table><h2 id=api参考>API参考</h2><p>本章中描述的函数供开发人员使用。这些功能在下一个主要版本之前不太可能改变或被删除。</p><p>此处未列出的 API 调用不是公开的，不应由应用程序调用。</p><p>这里我们从手册中摘取基本的asn_xxx_xxx()系列函数进行说明，其他编解码类型的功能和调用方式类似，不再此赘述。</p><h3 id=31-宏定义-asn_struct_free-macro>3.1 宏定义 ASN_STRUCT_FREE() macro</h3><h4 id=概要>概要</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080>#define ASN_STRUCT_FREE(type_descriptor, struct_ptr)
</span></span></span></code></pre></div><h4 id=描述>描述</h4><p>递归释放由type_descriptor描述结构体占用内存。struct_ptr指针为要释放的结构体指针。</p><p>当struct_ptr为NULL时，不执行任何操作。</p><h4 id=返回值>返回值</h4><p>无</p><h4 id=示例>示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Rectangle_t <span style=color:#666>*</span>rect <span style=color:#666>=</span> ...;
</span></span><span style=display:flex><span>ASN_STRUCT_FREE(asn_DEF_Rectangle, rect);
</span></span></code></pre></div><h3 id=32-宏定义-asn_struct_reset>3.2 宏定义 ASN_STRUCT_RESET()</h3><h4 id=概要-1>概要</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080>#define ASN_STRUCT_RESET(type_descriptor, struct_ptr)
</span></span></span></code></pre></div><h4 id=描述-1>描述</h4><p>清空结构体指针struct_ptr的成员内容，但是不释放指针本身(<em>还指向原来的内存，而不是指向NULL</em>)</p><p>当 struct_ptr 为 NULL 时什么也不做。</p><h4 id=返回值-1>返回值</h4><p>无</p><h4 id=示例-1>示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a2f;font-weight:700>struct</span> my_figure { <span style=color:#080;font-style:italic>/* The custom structure */</span>
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>int</span> flags; <span style=color:#080;font-style:italic>/* &lt;some custom member&gt; */</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* The type is generated by the ASN.1 compiler */</span>
</span></span><span style=display:flex><span>Rectangle_t rect;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* other members of the structure */</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>struct</span> my_figure <span style=color:#666>*</span>fig <span style=color:#666>=</span> ...;
</span></span><span style=display:flex><span>ASN_STRUCT_RESET(asn_DEF_Rectangle, <span style=color:#666>&amp;</span>fig<span style=color:#666>-&gt;</span>rect);
</span></span></code></pre></div><h3 id=33-asn_check_constraints>3.3 asn_check_constraints()</h3><h4 id=概要-2>概要</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#0b0;font-weight:700>int</span> <span style=color:#00a000>asn_check_constraints</span>(
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> asn_TYPE_descriptor_t <span style=color:#666>*</span>type_descriptor,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>struct_ptr, <span style=color:#080;font-style:italic>/* Target language’s structure */</span>
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>char</span> <span style=color:#666>*</span>errbuf, <span style=color:#080;font-style:italic>/* Returned error description */</span>
</span></span><span style=display:flex><span>size_t <span style=color:#666>*</span>errlen <span style=color:#080;font-style:italic>/* Length of the error description */</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h4 id=描述-2>描述</h4><p>根据 ASN.1 规则进行数据验证。</p><p>errbuf 和 errlen 可能会被赋值，在调用此函数之前，它们应指向适当的缓冲区空间及其长度。</p><p>如果约束验证失败，则 errlen将包含 errbuf 中用于编码错误消息的实际字节数。 如果正确，则返回0.</p><h4 id=返回值-2>返回值</h4><p>数据校验通过返回0，否则返回-1</p><h4 id=示例-2>示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Rectangle_t <span style=color:#666>*</span>rect <span style=color:#666>=</span> ...;
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>char</span> errbuf[<span style=color:#666>128</span>]; <span style=color:#080;font-style:italic>/* Buffer for error message */</span>
</span></span><span style=display:flex><span>size_t errlen <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>sizeof</span>(errbuf); <span style=color:#080;font-style:italic>/* Size of the buffer */</span>
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>int</span> ret <span style=color:#666>=</span> asn_check_constraints(<span style=color:#666>&amp;</span>asn_DEF_Rectangle, rectangle, errbuf, <span style=color:#666>&amp;</span>errlen);
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* assert(errlen &lt; sizeof(errbuf)); // Guaranteed: you may rely on that */</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>if</span>(ret) {
</span></span><span style=display:flex><span>    fprintf(stderr, <span>”</span>Constraint validation <span style=color:#a0a000>failed</span>: <span style=color:#666>%</span>s<span>\</span>n<span>”</span>, errbuf);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=34-asn_decode>3.4 asn_decode()</h3><h4 id=概要-3>概要</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>asn_dec_rval_t <span style=color:#00a000>asn_decode</span>(
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> asn_codec_ctx_t <span style=color:#666>*</span>opt_codec_ctx,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>enum</span> asn_transfer_syntax syntax,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> asn_TYPE_descriptor_t <span style=color:#666>*</span>type_descriptor,
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>**</span>struct_ptr_ptr,<span style=color:#080;font-style:italic>/* Pointer to a target structure’s ptr */</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>buffer, <span style=color:#080;font-style:italic>/* Data to be decoded */</span>
</span></span><span style=display:flex><span>size_t size <span style=color:#080;font-style:italic>/* Size of that buffer */</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h4 id=描述-3>描述</h4><p>根据syntax语法规则，解析大小为sizede的buffer为一个type_descriptor 类型的结构体消息。</p><p>struct_ptr_ptr 必须指向包含指向正在解码的结构(即buffer中的相同结构)的指针的内存位置。 最初通常设置 *struct_ptr_ptr 指针 到0。在这种情况下，asn_decode() 将为结构动态分配内存在解析过程中根据需要添加其成员。 如果 *struct_ptr_ptr 已经指向一些内存，asn_decode() 将根据需要分配后续成员解析 。</p><h4 id=返回值-3>返回值</h4><p>在不成功终止时，*struct_ptr_ptr 可能包含部分解码数据。 此数据可能对调试有用（例如通过使用 asn_fprint()）。务必通过调用 ASN_STRUCT_FREE() 或
ASN_STRUCT_RESET()释放内存。</p><p>成功的话会返回一个如下这样一个结构体:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a2f;font-weight:700>typedef</span> <span style=color:#a2f;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>enum</span> {
</span></span><span style=display:flex><span>        RC_OK, <span style=color:#080;font-style:italic>/* Decoded successfully */</span>
</span></span><span style=display:flex><span>        RC_WMORE, <span style=color:#080;font-style:italic>/* More data expected, call again */</span>
</span></span><span style=display:flex><span>        RC_FAIL <span style=color:#080;font-style:italic>/* Failure to decode data */</span>
</span></span><span style=display:flex><span>        } code; <span style=color:#080;font-style:italic>/* Result code */</span>
</span></span><span style=display:flex><span>    size_t consumed; <span style=color:#080;font-style:italic>/* Number of bytes consumed */</span>
</span></span><span style=display:flex><span>} asn_dec_rval_t;    
</span></span></code></pre></div><h4 id=重启特性restartability>重启特性(Restartability)</h4><p>有一些传输语法解析器(ATS_BER))支持重启。</p><p>这意味着如果缓冲区的数据少于预期，asn_decode() 将处理可用的任何内容，并要求使用 RC_WMORE 返回 .code 提供更多数据。</p><p>请注意，在 RC_WMORE 情况下，解码器处理的数据可能比缓冲区中可用的数据少，这意味着您<strong>必须能够安排下一个缓冲区以包含前一个缓冲区未处理的部分</strong>。</p><p>RC_WMORE 代码可能仍由不支持可重启性的解析器返回。在这种情况下，部分解码的结构将被丢弃，下一次调用应使用扩展缓冲区从开始进行解析。</p><h4 id=示例-3>示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Rectangle_t <span style=color:#666>*</span>rect <span style=color:#666>=</span> <span style=color:#666>0</span>; <span style=color:#080;font-style:italic>/* Note this 01! */</span>
</span></span><span style=display:flex><span>asn_dec_rval_t rval;
</span></span><span style=display:flex><span>rval <span style=color:#666>=</span> asn_decode(<span style=color:#666>0</span>, ATS_BER, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, (<span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>**</span>)<span style=color:#666>&amp;</span>rect, buffer, buf_size);
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>switch</span>(rval.code) {
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>case</span> <span style=color:#a0a000>RC_OK</span>:
</span></span><span style=display:flex><span>    asn_fprint(stdout, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, rect);
</span></span><span style=display:flex><span>    ASN_STRUCT_FREE(<span style=color:#666>&amp;</span>asn_DEF_Rectangle, rect);
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>case</span> <span style=color:#a0a000>RC_WMORE</span>:
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>case</span> <span style=color:#a0a000>RC_FAIL</span>:
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>default</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>    ASN_STRUCT_FREE(<span style=color:#666>&amp;</span>asn_DEF_Rectangle, rect);
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=参考>参考</h4><p><strong>asn_fprint()</strong></p><h3 id=35-ask_encode>3.5 ask_encode()</h3><h4 id=概要-4>概要</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;asn_application.h&gt;</span><span style=color:#080>
</span></span></span><span style=display:flex><span><span style=color:#080></span>asn_enc_rval_t <span style=color:#00a000>asn_encode</span>(
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> asn_codec_ctx_t <span style=color:#666>*</span>opt_codec_ctx,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>enum</span> asn_transfer_syntax syntax,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> asn_TYPE_descriptor_t <span style=color:#666>*</span>type_to_encode,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>structure_to_encode,
</span></span><span style=display:flex><span>asn_app_consume_bytes_f <span style=color:#666>*</span>callback, <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>callback_key);
</span></span></code></pre></div><h4 id=描述-4>描述</h4><p>将输入的type_to_encode结构体类型的消息structure_to_encode，以syntax的方式进行编码，通过callback函数对序列化后的数据进行处理，其中callback_key参数会被传入到callback函数。</p><p>回调的格式声明如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a2f;font-weight:700>typedef</span> <span style=color:#00a000>int</span>(asn_app_consume_bytes_f)(<span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>buffer, size_t size, <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>callback_key);
</span></span></code></pre></div><h4 id=返回值-4>返回值</h4><p>返回一个复合的结构体：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a2f;font-weight:700>typedef</span> <span style=color:#a2f;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    ssize_t encoded;
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>const</span> asn_TYPE_descriptor_t <span style=color:#666>*</span>failed_type;
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>structure_ptr;
</span></span><span style=display:flex><span>} asn_enc_rval_t;
</span></span></code></pre></div><p>如果编码不成功，.encoded 成员设置为 -1</p><p>如果编码成功，.encoded成员指定序列化输出的大小。</p><p>无论选择的 ASN.1 传输语法如何，都以字节为单位返回序列化输出大小。</p><p>出错时（当 .encoded 设置为 -1 时），errno 设置为以下值之一：</p><ul><li>EINVAL 函数参数不正确，例如NULL。</li><li>ENOENT 编码传输语法未定义。</li><li>EBADF 结构体无效或内容限制失败。</li><li>EIO 在回调函数编码时返回了负值。</li></ul><h4 id=示例-4>示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a2f;font-weight:700>static</span> <span style=color:#0b0;font-weight:700>int</span> <span style=color:#00a000>save_to_file</span>(<span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>data, size_t size, <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>key) 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	FILE <span style=color:#666>*</span>fp <span style=color:#666>=</span> key;
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>return</span> (fwrite(data, <span style=color:#666>1</span>, size, fp) <span style=color:#666>==</span> size) <span style=color:#666>?</span> <span style=color:#666>0</span> <span style=color:#666>:</span> <span>ି</span><span style=color:#666>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Rectangle_t <span style=color:#666>*</span>rect <span style=color:#666>=</span> ...;
</span></span><span style=display:flex><span>FILE <span style=color:#666>*</span>fp <span style=color:#666>=</span> ...;
</span></span><span style=display:flex><span>asn_enc_rval_t er;
</span></span><span style=display:flex><span>er <span style=color:#666>=</span> asn_encode(<span style=color:#666>0</span>, ATS_DER, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, rect, save_to_file, fp);
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>if</span>(er.encoded <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#666>1</span>) {
</span></span><span style=display:flex><span>	fprintf(stderr, <span>”</span>Failed to encode <span style=color:#666>%</span> s<span>\</span>n<span>”</span>, asn_DEF_Rectangle.name);
</span></span><span style=display:flex><span>} <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>	fprintf(stderr, <span>”</span><span style=color:#666>%</span> s encoded in <span style=color:#666>%</span> zd bytes<span>\</span>n<span>”</span>, asn_DEF_Rectangle.name,
</span></span><span style=display:flex><span>	er.encoded);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=36-asn_encode_to_buffer>3.6 asn_encode_to_buffer()</h3><h4 id=概要-5>概要</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;asn_application.h&gt;</span><span style=color:#080>
</span></span></span><span style=display:flex><span><span style=color:#080></span>asn_enc_rval_t <span style=color:#00a000>asn_encode_to_buffer</span>(
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> asn_codec_ctx_t <span style=color:#666>*</span>opt_codec_ctx,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>enum</span> asn_transfer_syntax syntax,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> asn_TYPE_descriptor_t <span style=color:#666>*</span>type_to_encode,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>structure_to_encode,
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>buffer, size_t buffer_size);
</span></span></code></pre></div><h4 id=描述-5>描述</h4><p>将输入的type_to_encode结构体类型的消息structure_to_encode，以syntax的方式进行编码至大小为buffer_siz的ebuffer中。</p><h4 id=返回值-5>返回值</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a2f;font-weight:700>typedef</span> <span style=color:#a2f;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>ssize_t encoded;
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> asn_TYPE_descriptor_t <span style=color:#666>*</span>failed_type;
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>structure_ptr;
</span></span><span style=display:flex><span>} asn_enc_rval_t;
</span></span></code></pre></div><p>不成功时，encoded被设置为-1；</p><p>成功时，encoded被设置为实际编码的字节数；</p><h4 id=示例-5>示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Rectangle_t <span style=color:#666>*</span>rect <span style=color:#666>=</span> ...;
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>uint8_t</span> buffer[<span style=color:#666>128</span>];
</span></span><span style=display:flex><span>asn_enc_rval_t er;
</span></span><span style=display:flex><span>er <span style=color:#666>=</span> asn_encode_to_buffer(<span style=color:#666>0</span>, ATS_DER, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, rect, buffer,
</span></span><span style=display:flex><span>                          <span style=color:#a2f;font-weight:700>sizeof</span>(buffer));
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>if</span>(er.encoded <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#666>1</span>) {
</span></span><span style=display:flex><span>    fprintf(stderr, <span>”</span>Serialization of <span style=color:#666>%</span> s failed.<span>\</span>n<span>”</span>,
</span></span><span style=display:flex><span>            asn_DEF_Rectangle.name);
</span></span><span style=display:flex><span>} <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span>(er.encoded <span style=color:#666>&gt;</span> <span style=color:#a2f;font-weight:700>sizeof</span>(buffer)) {
</span></span><span style=display:flex><span>fprintf(stderr, <span>”</span>Buffer of size <span style=color:#666>%</span>zu is too small <span style=color:#a2f;font-weight:700>for</span> <span style=color:#666>%</span>s, need <span style=color:#666>%</span>zu<span>\</span>n<span>”</span>,
</span></span><span style=display:flex><span>buf_size, asn_DEF_Rectangle.name, er.encoded);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=37-asn_encode_to_new_buffer>3.7 asn_encode_to_new_buffer()</h3><h4 id=概要-6>概要</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;asn_application.h&gt;</span><span style=color:#080>
</span></span></span><span style=display:flex><span><span style=color:#080></span><span style=color:#a2f;font-weight:700>typedef</span> <span style=color:#a2f;font-weight:700>struct</span> {
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>buffer;
</span></span><span style=display:flex><span> <span style=color:#080;font-style:italic>/* NULL if failed to encode. */</span>
</span></span><span style=display:flex><span>asn_enc_rval_t result;
</span></span><span style=display:flex><span>} asn_encode_to_new_buffer_result_t;
</span></span><span style=display:flex><span>asn_encode_to_new_buffer_result_t <span style=color:#00a000>asn_encode_to_new_buffer</span>(
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> asn_codec_ctx_t <span style=color:#666>*</span>opt_codec_ctx,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>enum</span> asn_transfer_syntax syntax,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> asn_TYPE_descriptor_t <span style=color:#666>*</span>type_to_encode,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>structure_to_encode);
</span></span></code></pre></div><h4 id=描述-6>描述</h4><p>将type_to_encode类型的结构体structure_to_encode，以syntax编码方式进行编码，返回值带有编码的buffer。</p><h4 id=返回值-6>返回值</h4><p>失败时，buffer被设置为NULL，encoded被设置为-1；</p><p>errno如下：</p><ul><li>EINVAL Incorrect parameters to the function, such as NULLs</li><li>ENOENT Encoding transfer syntax is not defined (for this type)</li><li>EBADF The structure has invalid form or content constraint failed</li><li>ENOMEM Memory allocation failed due to system or internal limits</li></ul><h4 id=示例-6>示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>asn_encode_to_new_buffer_result_t res;
</span></span><span style=display:flex><span>res <span style=color:#666>=</span> asn_encode_to_new_buffer(<span style=color:#666>0</span>, ATS_DER, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, rect);
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>if</span>(res.buffer) {
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* Encoded successfully. */</span>
</span></span><span style=display:flex><span>free(res.buffer);
</span></span><span style=display:flex><span>} <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>fprintf(stderr, <span>”</span>Failed to encode <span style=color:#666>%</span>s, estimated <span style=color:#666>%</span>zd bytes<span>\</span>n<span>”</span>,
</span></span><span style=display:flex><span>asn_DEF_Rectangle.name, res.result.encoded);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=38-asn_fprint>3.8 asn_fprint()</h3><h4 id=概要-7>概要</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#0b0;font-weight:700>int</span> <span style=color:#00a000>asn_fprint</span>(FILE <span style=color:#666>*</span>stream,
</span></span><span style=display:flex><span> <span style=color:#080;font-style:italic>/* Destination file */</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> asn_TYPE_descriptor_t <span style=color:#666>*</span>type_descriptor,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>struct_ptr
</span></span><span style=display:flex><span> <span style=color:#080;font-style:italic>/* Structure to be printed */</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h4 id=描述-7>描述</h4><p>asn_fprint（） 函数打印目标语言的人类可读描述结构到由流指针指定的文档流中。</p><p>输出格式不符合任何标准。</p><p>即使对于不完整和破碎的结构体，asn_fprint（） 函数尝试生成有效的输出，这使得它更适合调试复杂的案例，而不是xer_fprint（）。</p><h4 id=返回值-7>返回值</h4><p>成功 0；</p><p>失败 -1；</p><h4 id=示例-7>示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Rectangle_t <span style=color:#666>*</span>rect <span style=color:#666>=</span> ...;
</span></span><span style=display:flex><span>asn_fprint(stdout, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, rect);
</span></span></code></pre></div><h3 id=39-asn_random_fill>3.9 asn_random_fill()</h3><h4 id=概要-8>概要</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#0b0;font-weight:700>int</span> <span style=color:#00a000>asn_random_fill</span>(
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> asn_TYPE_descriptor_t <span style=color:#666>*</span>type_descriptor,
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>**</span>struct_ptr_ptr,<span style=color:#080;font-style:italic>/* Pointer to a target structure’s ptr */</span>
</span></span><span style=display:flex><span>size_t approx_max_length_limit
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h4 id=描述-8>描述</h4><p>根据type_descriptor类型规范，填充一个随机的struct_ptr_ptr结构体。</p><p>为了获得最佳结果，生成的代码应该在没有 <code>-no-gen-PER</code> 选项的情况下提供给 asn1c，使用 <code>-no-gen-PER</code> 选项可能会导致生成的值超出边界；</p><p><code>approx_max_length_limit</code>指定结果的近似限制结构以与字节非常相似的单位表示。实际结果可能要大几倍或小于给定的长度限制。为此选择初始值的经验，则参数是采用典型结构并使用其 DER 输出大小的两倍</p><h4 id=返回值-8>返回值</h4><ul><li>0 Structure was properly initialized with random data</li><li>-1 Failure to initialize the structure with random data</li></ul><h2 id=api使用示例>API使用示例</h2><p>首先，我们在进程中包含必要的头文件。</p><p>在Rectangle中，我们包含 <em>Rectangle.h</em>就足够了。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;Rectangle.h&gt;</span><span style=color:#080>
</span></span></span></code></pre></div><p>这个头文件定义了一个ASN定义的 rectangle对应的C结构体，一个被在很多API中引用的全局的类型描述符，类型描述符一般以<code>asn_DEF_</code>开头，例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Rectangle_t <span style=color:#666>*</span>rect <span style=color:#666>=</span> ...;
</span></span><span style=display:flex><span>ASN_STRUCT_FREE(asn_DEF_Rectangle, rect);
</span></span></code></pre></div><p>这里定义了一个<code>Rectangle_t</code>类型的指针<code>rect</code>，这个指针使用<code>ASN_STRUCT_FREE</code>释放。</p><p>第二行调用了ASN_STRUCT_FREE()宏，这个宏调用<code>Rectangle_t</code>对应的结构体释放程序。</p><h3 id=41-通用编解码>4.1 通用编解码</h3><p>在了解特殊的编解码之前，先介绍一下通用编解码方式。</p><p>asn1c运行时支持两个高等级的接口<code>asn_encode*</code>和<code>asn_decode*</code>，可以用参数来选择编解码的语法规则。定义如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic> * A selection of ASN.1 Transfer Syntaxes to use with generalized
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic> * encoders and decoders declared further in this .h file.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>enum</span> asn_transfer_syntax {
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Avoid appearance of a default transfer syntax. */</span>
</span></span><span style=display:flex><span>    ATS_INVALID <span style=color:#666>=</span> <span style=color:#666>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Plaintext output (not conforming to any standard), for debugging. */</span>
</span></span><span style=display:flex><span>    ATS_NONSTANDARD_PLAINTEXT,
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Returns a randomly generatede structure. */</span>
</span></span><span style=display:flex><span>    ATS_RANDOM,
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     * X.690:
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     * BER: Basic Encoding Rules.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     * DER: Distinguished Encoding Rules.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     * CER: Canonical Encoding Rules.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     * DER and CER are more strict variants of BER.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    ATS_BER,
</span></span><span style=display:flex><span>    ATS_DER,
</span></span><span style=display:flex><span>    ATS_CER, <span style=color:#080;font-style:italic>/* Only decoding is supported */</span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     * X.696:
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     * OER: Octet Encoding Rules.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     * CANONICAL-OER is a more strict variant of BASIC-OER.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    ATS_BASIC_OER,
</span></span><span style=display:flex><span>    ATS_CANONICAL_OER,
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     * X.691:
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     * PER: Packed Encoding Rules.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     * CANONICAL-PER is a more strict variant of BASIC-PER.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     * NOTE: Produces or consumes a complete encoding (X.691 (08/2015) #11.1).
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    ATS_UNALIGNED_BASIC_PER,
</span></span><span style=display:flex><span>    ATS_UNALIGNED_CANONICAL_PER,
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     * X.693:
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     * XER: XML Encoding Rules.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     * CANONICAL-XER is a more strict variant of BASIC-XER.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    ATS_BASIC_XER,
</span></span><span style=display:flex><span>    ATS_CANONICAL_XER
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>使用这个编解码的选择器，使编解码过程变得很通用。</p><h4 id=编码>编码</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#0b0;font-weight:700>uint8_t</span> buffer[<span style=color:#666>128</span>];
</span></span><span style=display:flex><span>size_t buf_size <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>sizeof</span>(buffer);
</span></span><span style=display:flex><span>asn_enc_rval_t er;
</span></span><span style=display:flex><span>er <span style=color:#666>=</span> asn_encode_to_buffer(<span style=color:#666>0</span>, ATS_DER, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, buffer, buf_size);
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>if</span>(er.encoded <span style=color:#666>&gt;</span> buf_size) {
</span></span><span style=display:flex><span>fprintf(stderr, <span>”</span>Buffer of size <span style=color:#666>%</span>zu is too small <span style=color:#a2f;font-weight:700>for</span> <span style=color:#666>%</span>s, need <span style=color:#666>%</span>zu<span>\</span>n<span>”</span>,
</span></span><span style=display:flex><span>buf_size, asn_DEF_Rectangle.name, er.encoded);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=解码>解码</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Rectangle_t <span style=color:#666>*</span>rect <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>... <span style=color:#666>=</span> asn_decode(<span style=color:#666>0</span>, ATS_BER, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, (<span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>**</span>)<span style=color:#666>&amp;</span>rect,buffer, buf_size);
</span></span></code></pre></div><h3 id=42-ber解码>4.2 BER解码</h3><p>基本编码规则描述了（由 ASN.1 社区）使用最广泛的方法以独立于机器的方式对给定结构进行编码和解码。其他几种编码规则（CER，DER）定义了限制性更强的BER版本，因此，通用 BER 解析器还能够解码由 CER 和 DER 编码器编码的数据。反之不可以。</p><p>ASN.1 编译器提供了通用 BER 解码器，能够解码 BER、CER和 DER 编码数据。</p><p>解码器是可重新启动的(面向数据流)，意味着当buffer中的数据少于期望的数据，解码器将处理有效数据，然后在返回值中使<code>.code</code>为<code>RC_WMORE</code>来请求更多数据。</p><p><strong>注意</strong>，在<code>RC_WMORE</code>这种情况下，实际处理的数据可能会比实际情况要少(也就是不一定会完全处理完buffer中提供的所有数据)，因此在下一个buffer中需要包含上一个buffer中未处理的数据。</p><p>假设，有2个要编码的buffer，分别是100Bytes和200Bytes。</p><ul><li>你可以使用一个300Bytes的buffer来代替这2个buffer的内容；</li><li>或者你可以像解码器提供一个100Bytes的buffer，它可能只会处理95Bytes；则下一次提供的buffer要提供5+200Bytes的buffer，其中的5Bytes是第一次没有处理的部分。</li></ul><p>这并不像它可能的那样方便（BER编码器可能会消耗整个100字节并将这5个字节保存在一些临时存储中），但在现有基于流的情况下处理它实际上可能非常适合现有的算法。</p><p>这里有一个简单的示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Rectangle_t <span style=color:#666>*</span> <span style=color:#00a000>simple_deserializer</span>(<span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>buffer, size_t buf_size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    asn_dec_rval_t rval;
</span></span><span style=display:flex><span>    Rectangle_t <span style=color:#666>*</span>rect <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    rval <span style=color:#666>=</span> asn_DEF_Rectangle.op<span style=color:#666>-&gt;</span>ber_decoder(<span style=color:#666>0</span>,<span style=color:#666>&amp;</span>asn_DEF_Rectangle,(<span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>**</span>)<span style=color:#666>&amp;</span>rect,buffer, buf_size, <span style=color:#666>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span>(rval.code <span style=color:#666>==</span> RC_OK) {
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span> rect;
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Decoding succeeded */</span>
</span></span><span style=display:flex><span>    } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>/* Free the partially decoded rectangle */</span>
</span></span><span style=display:flex><span>    ASN_STRUCT_FREE(asn_DEF_Rectangle, rect);
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上边这段代码定义了一个函数<code>simple_deserializer()</code>，它需要给定一个buffer和bufferd的大小，然后预计会返回一个指向<code>Rectangle_t</code>类型的指针。在内部，它试图通过<code>ber_decoder()</code>解析buffer中的内容到一个结构体<code>rect</code>。如果<code>ber_decoder()</code>函数没有完成解码，它会返回0(no data)，并且释放内存(这里的释放是必须的).</p><p>稍微简单一点的调用，是使用全局函数<code>ber_decode()</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>rval <span style=color:#666>=</span> ber_decode(<span style=color:#666>0</span>, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, (<span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>**</span>)<span style=color:#666>&amp;</span>rect, buffer,buf_size);
</span></span></code></pre></div><p>这里注意使用ber_decode()调用时，最后的参数0不必要。</p><p>这两种调用方式是<strong>完全等效</strong>的。</p><p>BER decoder 的解码也可能会失败，返回值：</p><ul><li>RC_WMORE: 需要在下一个数据流提供更多的数据</li><li>RC_FAIL: 解码失败</li><li>其他</li></ul><h3 id=43-der编码>4.3 DER编码</h3><p>可分辨编码规则是 BER 编码规则的规范变体。DER最适合于对事先知道所有长度的结构进行编码。</p><p>与 BER 解码器一样，DER 编码器可以直接从 ASN.1 类型调用描述符（asn_DEF_Rectangle），这更简单一些：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* This is the serializer itself.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* It supplies the DER encoder with the
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* pointer to the custom output function.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>*/</span>
</span></span><span style=display:flex><span>ssize_t <span style=color:#00a000>simple_serializer</span>(FILE <span style=color:#666>*</span>ostream, Rectangle_t <span style=color:#666>*</span>rect) 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    asn_enc_rval_t er; <span style=color:#080;font-style:italic>/* Encoder return value */</span>
</span></span><span style=display:flex><span>        er <span style=color:#666>=</span> der_encode(<span style=color:#666>&amp;</span>asn_DEF_Rect, rect, write_stream, ostream);
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span>(er.encoded <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#666>1</span>) {
</span></span><span style=display:flex><span>        fprintf(stderr, <span>”</span>Cannot encode <span style=color:#666>%</span><span style=color:#a0a000>s</span>: <span style=color:#666>%</span>s<span>\</span>n<span>”</span>,
</span></span><span style=display:flex><span>        er.failed_type <span style=color:#666>-&gt;</span>name, strerror(errno));
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>-</span><span style=color:#666>1</span>;
</span></span><span style=display:flex><span>    } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>/* Return the number of bytes */</span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>return</span> er.encoded;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>正如我们所看到的，<code>der_encode()</code>不会将写入任何buffer，而是通过调用自定义的函数(可能会调用多次)，将数据进行适当的存储。<code>app_key</code>参数对于<code>der_encode()</code>是不可见的，只由自定义函数来调用。</p><p>如果未给出自定义写入函数（作为 0 传递），则 DER 编码器基本上将执行相同的操作（即对数据进行编码），但不会调用任何回调（数据无处可去）。在确定结构编码的大小之前可能很有用.</p><h3 id=44-xer编码>4.4 XER编码</h3><p>XER全称是XML Encoding Rules，即XML编码规则。XML是一种基本的信息交换格式，是一种可拓展的标记语言。编码器有两种类型：stdio-base和回调。使用回调的方式，编码器的处理与DER类似，我们在4.3章节有介绍过。以下示例使用<code>write_stream()</code>的定义：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>/*
</span></span><span style=display:flex><span>* This procedure generates an XML document
</span></span><span style=display:flex><span>* by invoking the XER encoder.
</span></span><span style=display:flex><span>* NOTE: Do not copy this code verbatim!
</span></span><span style=display:flex><span>*
</span></span><span style=display:flex><span> If the stdio output is necessary,
</span></span><span style=display:flex><span>*
</span></span><span style=display:flex><span> use the xer_fprint() procedure instead.
</span></span><span style=display:flex><span>*
</span></span><span style=display:flex><span> See section 4.7 on page 62.
</span></span><span style=display:flex><span>*/
</span></span><span style=display:flex><span>int print_as_XML(FILE *ostream, Rectangle_t *rect) 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    asn_enc_rval_t er; /* Encoder return value */
</span></span><span style=display:flex><span>    er = xer_encode(&amp;asn_DEF_Rectangle, rect,
</span></span><span style=display:flex><span>    XER_F_BASIC, /* BASIC-XER or CANONICAL-XER */
</span></span><span style=display:flex><span>    write_stream, ostream);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return (er.encoded ==-1) ? ି1 : 0;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=45-xer解码>4.5 XER解码</h3><p>使用XER编码的数据，随后就可以使用<code>xer_decode()</code>来解码：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Rectangle_t <span style=color:#666>*</span> <span style=color:#00a000>XML_to_Rectangle</span>(<span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>buffer, size_t buf_size) 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    asn_dec_rval_t rval;
</span></span><span style=display:flex><span>    Rectangle_t <span style=color:#666>*</span>rect <span style=color:#666>=</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    rval <span style=color:#666>=</span> xer_decode(<span style=color:#666>0</span>, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, (<span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>**</span>)<span style=color:#666>&amp;</span>rect,buffer, buf_size);
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span>(rval.code <span style=color:#666>==</span> RC_OK) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>return</span> rect;
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>/* Decoding succeeded */</span>
</span></span><span style=display:flex><span>    } <span style=color:#a2f;font-weight:700>else</span> 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>/* Free partially decoded rect */</span>
</span></span><span style=display:flex><span>        ASN_STRUCT_FREE(asn_DEF_Rectangle, rect);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>解码器采用BASIC-XER和CANONICAL-XER编码.</p><h3 id=46-验证目标结构体>4.6 验证目标结构体</h3><p>有时候结构体需要验证数据的有效性。例如，ASN.1中定义的必填字段是否被填上；另一方面，成功解码的消息数据有可能数据是有问题的。</p><p><code>asn_check_constraints()</code>函数检查类型中是否存在各种隐式和显示约束条件。建议在每次解码之后和编码之前使用该接口进行校验。</p><h3 id=47-打印目标结构体>4.7 打印目标结构体</h3><p>在调试时，打印目标结构体，使用<code>asn_fprint()</code>函数。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>asn_fprint(stdout, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, rect);
</span></span></code></pre></div><p>一个使用的替代方案是使用XML格式。默认的 BASIC-XER 编码器对输出执行合理的格式化。既有用又可读。使用 <code>xer_fprint()</code> 函数：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>xer_fprint(stdout, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, rect);
</span></span></code></pre></div><h3 id=48-释放目标结构体>4.8 释放目标结构体</h3><p>释放结构体要求结构体的所有子成员也被释放，<code>ASN_STRUCT_FREE()</code>宏来完成这个功能。</p><p>但是，这并不总是可行的，在下边的例子中，程序定义了一个包含ASN.1结构的结构体：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>struct my_figure { /* The custom structure */
</span></span><span style=display:flex><span>int flags;	/* &lt;some custom member&gt; */
</span></span><span style=display:flex><span>/* The type is generated by the ASN.1 compiler */
</span></span><span style=display:flex><span>Rectangle_t rect;	/* other members of the structure */
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>如果还是用上述<code>ASN_STRUCT_FREE()</code>宏来进行释放，则会情况rect成员。这种情况下，使用另外一个接口<code>ASN_STRUCT_RESET()</code> 。两种情况的调用情况如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/* 1. Rectangle_t is defined within my_figure */</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>struct</span> my_figure {
</span></span><span style=display:flex><span>    Rectangle_t rect;
</span></span><span style=display:flex><span>} <span style=color:#666>*</span>mf <span style=color:#666>=</span> ...;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* Freeing the Rectangle_t
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* without freeing the mfି &gt;rect area.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>*/</span>
</span></span><span style=display:flex><span>ASN_STRUCT_RESET(asn_DEF_Rectangle, <span style=color:#666>&amp;</span>mf <span>ି</span> <span style=color:#666>&gt;</span>rect);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* 2. Rectangle_t is a stand-alone pointer */</span>
</span></span><span style=display:flex><span>Rectangle_t <span style=color:#666>*</span>rect <span style=color:#666>=</span> ...;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* Freeing the Rectangle_t
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* and freeing the rect pointer.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>*/</span>
</span></span><span style=display:flex><span>ASN_STRUCT_FREE(asn_DEF_Rectangle, rect);
</span></span></code></pre></div></div><footer class=post-footer><div class=post-tags><a href=/tags/asn1c%e7%bc%96%e8%af%91%e5%99%a8 rel=tag title=ASN1C编译器>#ASN1C编译器#</a>
<a href=/tags/asn.1 rel=tag title=ASN.1>#ASN.1#</a></div><div class=post-nav><div class=article-copyright><div class=article-copyright-img><img src=/img/qq_qrcode.png width=129px height=129px><div style=text-align:center>微信扫一扫关注</div></div><div class=article-copyright-info><p><span>声明：</span>ASN1C使用手册</p><p><span>链接：</span>https://mdxz2048.github.io/post/asn1c%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</p><p><span>作者：</span>MD小智</p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/3.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作实属不易，如有帮助，那就打赏博主些许茶钱吧 ^_^</div><button id=rewardButton disable=enable onclick='var qr=document.getElementById("QR");qr.style.display==="none"?qr.style.display="block":qr.style.display="none"'>
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/img/wechat-pay.png alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=/img/ali-pay.png alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=https://mdxz2048.github.io/post/study_valgrind_memcheck/ rel=next title=内存调试工具Valgrind之Memcheck><i class="fa fa-chevron-left"></i> 内存调试工具Valgrind之Memcheck</a></div><div class="post-nav-prev post-nav-item"><a href=https://mdxz2048.github.io/post/study_linux_tcp_in_linux_04/ rel=prev title=自上而下理解内核网络(四)---sock与传输层UDP>自上而下理解内核网络(四)---sock与传输层UDP
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target=post-toc-wrap>文章目录</li><li class=sidebar-nav-overview data-target=site-overview>站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/img/avatar.png alt=MD小智><p class=site-author-name itemprop=name>MD小智</p><p class="site-description motion-element" itemprop=description>我们会高估自己所拥有的一切！</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>24</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>6</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>31</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/mdxz2048 target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>
GitHub</a></span></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>
标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%90%86%E8%A7%A3%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C>自上而下理解内核网络</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5>文件同步</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/12306bypass>12306bypass</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/asn.1>Asn.1</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/asn1c%E7%BC%96%E8%AF%91%E5%99%A8>Asn1c编译器</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/ean13>Ean13</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/gdb%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91>Gdb交叉编译</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/hexo>Hexo</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/markdown>Markdown</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/marktext>Marktext</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class=post-toc><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#开源asn1编译器介绍>开源ASN.1编译器介绍</a></li><li><a href=#安装>安装</a><ul><li><a href=#环境依赖httpsgithubcomvlmasn1cblobmasterrequirementsmd><a href=https://github.com/vlm/asn1c/blob/master/REQUIREMENTS.md>环境依赖</a></a></li><li><a href=#从源码编译httpsgithubcomvlmasn1cblobmasterinstallmdcompiling-from-sources><a href=https://github.com/vlm/asn1c/blob/master/INSTALL.md#compiling-from-sources>从源码编译</a></a></li></ul></li><li><a href=#快速开始示例>快速开始示例</a><ul><li><a href=#11-一个rectangle转换和调试>1.1 一个“Rectangle”转换和调试</a></li><li><a href=#12-一个rectangle编码器>1.2 一个“Rectangle”编码器</a></li><li><a href=#13-一个rectangle解码器>1.3 一个“Rectangle”解码器</a></li><li><a href=#14--给rectangle增加约束数据验证>1.4 给“Rectangle”增加约束(数据验证)</a></li></ul></li><li><a href=#asn1编译器>ASN.1编译器</a><ul><li><a href=#21-asn1c编译工具>2.1 ASN1C编译工具</a></li><li><a href=#22-编译器输出>2.2 编译器输出</a></li><li><a href=#23-命令行配置>2.3 命令行配置</a></li></ul></li><li><a href=#api参考>API参考</a><ul><li><a href=#31-宏定义-asn_struct_free-macro>3.1 宏定义 ASN_STRUCT_FREE() macro</a></li><li><a href=#32-宏定义-asn_struct_reset>3.2 宏定义 ASN_STRUCT_RESET()</a></li><li><a href=#33-asn_check_constraints>3.3 asn_check_constraints()</a></li><li><a href=#34-asn_decode>3.4 asn_decode()</a></li><li><a href=#35-ask_encode>3.5 ask_encode()</a></li><li><a href=#36-asn_encode_to_buffer>3.6 asn_encode_to_buffer()</a></li><li><a href=#37-asn_encode_to_new_buffer>3.7 asn_encode_to_new_buffer()</a></li><li><a href=#38-asn_fprint>3.8 asn_fprint()</a></li><li><a href=#39-asn_random_fill>3.9 asn_random_fill()</a></li></ul></li><li><a href=#api使用示例>API使用示例</a><ul><li><a href=#41-通用编解码>4.1 通用编解码</a></li><li><a href=#42-ber解码>4.2 BER解码</a></li><li><a href=#43-der编码>4.3 DER编码</a></li><li><a href=#44-xer编码>4.4 XER编码</a></li><li><a href=#45-xer解码>4.5 XER解码</a></li><li><a href=#46-验证目标结构体>4.6 验证目标结构体</a></li><li><a href=#47-打印目标结构体>4.7 打印目标结构体</a></li><li><a href=#48-释放目标结构体>4.8 释放目标结构体</a></li></ul></li></ul></nav></div></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2010 - 2022</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=copyright-author>MD小智</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.96.0</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span class=site-uv><i class="fa fa-user"></i>
<span class=busuanzi-value id=busuanzi_value_site_uv></span></span>
<span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i>
<span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div><div class=license-info><span class=storage-info>Storage by
<a href=http://github.com/ style=font-weight:700 target=_blank>GitHub</a></span>
<span class=separator-line>/</span>
<span class=license-num><a href=http://blog.mddxz.top/ target=_blank>MD小智</a></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i>
<span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/2.1.4/jquery.min.js></script>
<script type=text/javascript src=https://mdxz2048.github.io/js/search.js></script>
<script type=text/javascript src=https://mdxz2048.github.io/js/affix.js></script>
<script type=text/javascript src=https://mdxz2048.github.io/js/scrollspy.js></script>
<script type=text/javascript>function detectIE(){var e=window.navigator.userAgent,t=e.indexOf("MSIE "),n=e.indexOf("Trident/"),s=e.indexOf("Edge/");return t>0||n>0||s>0?-1:1}function getCntViewHeight(){var t=$("#content").height(),e=$(window).height(),n=t>e?t-e:$(document).height()-e;return n}function getScrollbarWidth(){var e=$("<div />").addClass("scrollbar-measure").prependTo("body"),t=e[0],n=t.offsetWidth-t.clientWidth;return e.remove(),n}function registerBackTop(){var t=50,e=$(".back-to-top");$(window).on("scroll",function(){e.toggleClass("back-to-top-on",window.pageYOffset>t);var s=$(window).scrollTop(),o=getCntViewHeight(),i=s/o,n=Math.round(i*100),a=n>100?100:n;$("#scrollpercent>span").html(a)}),e.on("click",function(){$("html,body").animate({scrollTop:0,screenLeft:0},800)})}function initScrollSpy(){var e=".post-toc",s=$(e),t=".active-current";s.on("activate.bs.scrollspy",function(){var t=$(e+" .active").last();n(),t.addClass("active-current")}).on("clear.bs.scrollspy",n),$("body").scrollspy({target:e});function n(){$(e+" "+t).removeClass(t.substring(1))}}function initAffix(){var e=$(".header-inner").height(),t=parseInt($(".main").css("padding-bottom"),10),n=e+10;$(".sidebar-inner").affix({offset:{top:n,bottom:t}}),$(document).on("affixed.bs.affix",function(){updateTOCHeight(document.body.clientHeight-100)})}function initTOCDimension(){$(window).on("resize",function(){e&&clearTimeout(e),e=setTimeout(function(){var e=document.body.clientHeight-100;updateTOCHeight(e)},0)}),updateTOCHeight(document.body.clientHeight-100);var e,t=getScrollbarWidth();$(".post-toc").css("width","calc(100% + "+t+"px)")}function updateTOCHeight(e){e=e||"auto",$(".post-toc").css("max-height",e)}$(function(){var t=$(".header-inner").height()+10,n,s,e,o;$("#sidebar").css({'margin-top':t}).show(),n=parseInt($("#sidebar").css("margin-top")),s=parseInt($(".sidebar-inner").css("height")),e=n+s,o=$(".content-wrap").height(),o<e&&$(".content-wrap").css("min-height",e),$(".site-nav-toggle").on("click",function(){var e=$(".site-nav"),o=$(".toggle"),t="site-nav-on",i="toggle-close",n=e.hasClass(t),a=n?"slideUp":"slideDown",s=n?"removeClass":"addClass";e.stop()[a]("normal",function(){e[s](t),o[s](i)})}),registerBackTop(),initScrollSpy(),initAffix(),initTOCDimension(),$(".sidebar-nav-toc").click(function(){$(this).addClass("sidebar-nav-active"),$(this).next().removeClass("sidebar-nav-active"),$("."+$(this).next().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)}),$(".sidebar-nav-overview").click(function(){$(this).addClass("sidebar-nav-active"),$(this).prev().removeClass("sidebar-nav-active"),$("."+$(this).prev().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)})})</script><script src=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.js></script>
<script type=text/javascript>$(function(){$(".post-body").viewer()})</script><script>(function(){var e=document.createElement("script"),t,n=window.location.protocol.split(":")[0];n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script></body></html>
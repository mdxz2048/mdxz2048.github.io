<!doctype html><html lang=zh-cn dir=content/zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>ASN1C使用手册 - MD小智</title><meta name=keywords content="博客,程序员,架构师,思考,读书,笔记,技术,分享"><meta name=author content="MD小智"><meta property="og:title" content="ASN1C使用手册"><meta property="og:site_name" content="MD小智"><meta property="og:image" content="https://mdxz2048.github.io/img/author.jpg"><meta name=title content="ASN1C使用手册 - MD小智"><meta name=description content="欢迎来到MD小智的个人站点，这里主要分享软件、工具教程、技术学习和思考"><link rel="shortcut icon" href=https://mdxz2048.github.io/img/favicon.ico><link rel=apple-touch-icon href=https://mdxz2048.github.io/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=https://mdxz2048.github.io/img/apple-touch-icon.png><link href=//cdn.bootcdn.net/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.css rel=stylesheet><link href=https://mdxz2048.github.io/css/main.css rel=stylesheet type=text/css><link href=https://mdxz2048.github.io/css/syntax.css rel=stylesheet type=text/css></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span>
<span class=site-title>MD小智</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>学习-思考-分享</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class=menu-item><a href=/categories rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>分类</a></li><li class=menu-item><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=/about.html rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于我</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span>
<span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://mdxz2048.github.io/post/asn1c%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/ itemprop=url>ASN1C使用手册</a></h1><div class=post-meta><span class=post-time><i class="fa fa-calendar-o fa-fw"></i>
<span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2022-06-09">2022-06-09</time></span>
<span class=post-category>&nbsp; | &nbsp;
<i class="fa fa-folder-o fa-fw"></i>
<span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a class=post-category-a href=/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B itemprop=url rel=index><span itemprop=name>工具教程</span></a>
&nbsp;</span></span>
<span>|
<i class="fa fa-file-word-o fa-fw"></i>
<span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>6905 字</span></span>
<span>|
<i class="fa fa-eye fa-fw"></i>
<span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>14分钟</span></span>
<span id=/post/asn1c%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/ class=leancloud_visitors data-flag-title=ASN1C使用手册>|
<i class="fa fa-binoculars fa-fw"></i>
<span class=post-meta-item-text>阅读次数：</span>
<span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><h2 id=使用开源asn1编译器介绍>使用开源ASN.1编译器介绍</h2><p><em>ANS1C</em>的全称是<em>ASN.1 Compiler</em>，主要用来根据ASN.1文件来生成对应的兼容C++的C代码。支持<em>BER/OER/PER/XER</em>多种格式的编解码。</p><p>ASN1C是一个编译器，以ASN.1语法和ASN.1文件生成语法树，然后编译出目标语言，我们这里主要用C语言，以后要学习编译器，相信研究一下asn1c也是个不错的选择，这里我们先了解它的使用。</p><ul><li>作者：Lev Walkin <a href=mailto:vlm@lionet.info>vlm@lionet.info</a></li><li>ASN.1版本：0.9.29</li><li>开源地址：<a href=https://github.com/vlm/asn1c>asn1c</a></li></ul><h2 id=安装>安装</h2><p>以下演示在<em>Ubuntu20.04</em>虚拟机上，通过源码安装asn1c编译器，其他平台过程类似。</p><h3 id=环境依赖httpsgithubcomvlmasn1cblobmasterrequirementsmd><a href=https://github.com/vlm/asn1c/blob/master/REQUIREMENTS.md>环境依赖</a></h3><ul><li>automake大于1.15</li><li>libtool</li><li>bison等于2.x，实测3.5.1版本也可以使用</li><li>flex</li></ul><h3 id=从源码编译httpsgithubcomvlmasn1cblobmasterinstallmdcompiling-from-sources><a href=https://github.com/vlm/asn1c/blob/master/INSTALL.md#compiling-from-sources>从源码编译</a></h3><ol><li><p>执行如下指令，下载源码到本地，然后进入<em>asn1c</em>文件夹；</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>git clone git@github.com:vlm/asn1c.git
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> asn1c
</span></span></code></pre></div></li><li><p>使用默认配置设置工程：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#a2f>test</span> -f configure <span style=color:#666>||</span> autoreconf -iv
</span></span><span style=display:flex><span>./configure
</span></span><span style=display:flex><span>make
</span></span></code></pre></div><p>配置成功后效果如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>╭─ caeri@ubuntu  ~/lzp/GIT/asn1c                                                                                                                                         
</span></span><span style=display:flex><span>╰─ <span style=color:#a2f>test</span> -f configure <span style=color:#666>||</span> autoreconf -iv
</span></span><span style=display:flex><span>utoreconf: Entering directory <span style=color:#b44>`</span>.<span style=color:#b44>&#39;
</span></span></span><span style=display:flex><span><span style=color:#b44>.......
</span></span></span><span style=display:flex><span><span style=color:#b44>onfigure.ac:5: installing &#39;</span>config/install-sh<span style=color:#b44>&#39;
</span></span></span><span style=display:flex><span><span style=color:#b44>configure.ac:5: installing &#39;</span>config/missing<span style=color:#b44>&#39;
</span></span></span><span style=display:flex><span><span style=color:#b44>parallel-tests: installing &#39;</span>config/test-driver<span style=color:#b44>&#39;
</span></span></span><span style=display:flex><span><span style=color:#b44>asn1-tools/enber/Makefile.am: installing &#39;</span>config/depcomp<span style=color:#b44>&#39;
</span></span></span><span style=display:flex><span><span style=color:#b44>autoreconf: running: gnu-configize
</span></span></span><span style=display:flex><span><span style=color:#b44>autoreconf: Leaving directory `.&#39;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>╭─ caeri@ubuntu  ~/lzp/GIT/asn1c                                                                                                                                              
</span></span><span style=display:flex><span>╰─ ./configure
</span></span><span style=display:flex><span>checking <span style=color:#a2f;font-weight:700>for</span> a BSD-compatible install... /usr/bin/install -c
</span></span><span style=display:flex><span>......
</span></span><span style=display:flex><span>config.status: creating config.h
</span></span><span style=display:flex><span>config.status: executing depfiles commands
</span></span><span style=display:flex><span>config.status: executing libtool commands
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>╭─ caeri@ubuntu  ~/lzp/GIT/asn1c                                                                                                                                           
</span></span><span style=display:flex><span>╰─ make 
</span></span><span style=display:flex><span>make  all-recursive
</span></span><span style=display:flex><span>make<span style=color:#666>[</span>1<span style=color:#666>]</span>: Entering directory <span style=color:#b44>&#39;/home/caeri/lzp/GIT/asn1c&#39;</span>
</span></span><span style=display:flex><span>Making all in libasn1common
</span></span><span style=display:flex><span>......
</span></span><span style=display:flex><span>make<span style=color:#666>[</span>2<span style=color:#666>]</span>: Entering directory <span style=color:#b44>&#39;/home/caeri/lzp/GIT/asn1c&#39;</span>
</span></span><span style=display:flex><span>make<span style=color:#666>[</span>2<span style=color:#666>]</span>: Leaving directory <span style=color:#b44>&#39;/home/caeri/lzp/GIT/asn1c&#39;</span>
</span></span><span style=display:flex><span>make<span style=color:#666>[</span>1<span style=color:#666>]</span>: Leaving directory <span style=color:#b44>&#39;/home/caeri/lzp/GIT/asn1c&#39;</span>
</span></span></code></pre></div></li><li><p>编译成功后，执行如下指令，进行安装</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>make install
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>╭─ caeri@ubuntu  ~/lzp/GIT/asn1c   master  INSERT                                                                                                                                                
</span></span><span style=display:flex><span>╰─ make install
</span></span><span style=display:flex><span>Making install in libasn1common
</span></span><span style=display:flex><span>......
</span></span><span style=display:flex><span>/usr/bin/mkdir -p <span style=color:#b44>&#39;/usr/local/share/doc/asn1c&#39;</span>
</span></span><span style=display:flex><span>/usr/bin/install -c -m <span style=color:#666>644</span> README.md INSTALL.md REQUIREMENTS.md FAQ ChangeLog BUGS <span style=color:#b44>&#39;/usr/local/share/doc/asn1c&#39;</span>
</span></span><span style=display:flex><span>make<span style=color:#666>[</span>2<span style=color:#666>]</span>: Leaving directory <span style=color:#b44>&#39;/home/caeri/lzp/GIT/asn1c&#39;</span>
</span></span><span style=display:flex><span>make<span style=color:#666>[</span>1<span style=color:#666>]</span>: Leaving directory <span style=color:#b44>&#39;/home/caeri/lzp/GIT/asn1c&#39;</span>
</span></span></code></pre></div></li><li><p>执行<code>man asn1c</code>检查是否安装成功，如果有相关手册打印出来即为安装成功。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>asn1c<span style=color:#666>(</span>1<span style=color:#666>)</span>                                                                                    Version 0.9.29                                                                                   asn1c<span style=color:#666>(</span>1<span style=color:#666>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>NAME
</span></span><span style=display:flex><span>     asn1c -- the ASN.1 Compiler
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SYNOPSIS
</span></span><span style=display:flex><span>     asn1c <span style=color:#666>[</span>-E <span style=color:#666>[</span>-F<span style=color:#666>]</span> | -P | -R<span style=color:#666>]</span>
</span></span><span style=display:flex><span>     <span style=color:#666>[</span>-Sdir<span style=color:#666>]</span> <span style=color:#666>[</span>-X<span style=color:#666>]</span>
</span></span><span style=display:flex><span>     <span style=color:#666>[</span>-Wdebug-...<span style=color:#666>]</span> <span style=color:#666>[</span>-foption<span style=color:#666>]</span> <span style=color:#666>[</span>-gen-option<span style=color:#666>]</span> <span style=color:#666>[</span>-pdu<span style=color:#666>={</span>all|auto|Type<span style=color:#666>}]</span>
</span></span><span style=display:flex><span>     <span style=color:#666>[</span>-print-option<span style=color:#666>]</span>
</span></span><span style=display:flex><span>     input-filenames...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DESCRIPTION
</span></span><span style=display:flex><span>     asn1c compiles ASN.1 specifications into a <span style=color:#a2f>set</span> of target language <span style=color:#666>(</span>C/C++<span style=color:#666>)</span> encoders and decoders <span style=color:#a2f;font-weight:700>for</span> BER, DER, PER, XER, OER and other encoding rules.
</span></span></code></pre></div></li></ol><h2 id=快速开始示例>快速开始示例</h2><h3 id=11-一个rectangle转换和调试>1.1 一个“Rectangle”转换和调试</h3><p>最常见的需求是为一个已经存在的ASN.1数据文件，创建一个分析工具。让我们来为一个存在的Rectangle的二进制文件构建一个BER、OER、PER、XER(XML)的转换器。如下：</p><ol><li><p>在<code>ans1c</code>文件夹下，新建一个<em>rectangle.asn</em> 文件，写入如下内容：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ASN.1 data-lang=ASN.1><span style=display:flex><span>RectangleModule DEFINITIONS ::= BEGIN
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Rectangle ::= SEQUENCE {
</span></span><span style=display:flex><span>height INTEGER,
</span></span><span style=display:flex><span>width INTEGER
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>END
</span></span></code></pre></div></li><li><p>执行如下指令，使用asn1c将其编译成.c和.h文件</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>asn1c -no-gen-example rectangle.asn
</span></span></code></pre></div></li><li><p>执行如下指令，生成一个转换器：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>make -f converter-example.mk
</span></span></code></pre></div></li><li><p>完成后，使用二进制文件进行转换：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>./converter-example -h
</span></span></code></pre></div><p>效果如下</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>╭─ caeri@ubuntu  ~/lzp/GIT/asn1c   master ?  INSERT           SIGINT<span style=color:#666>(</span>2<span style=color:#666>)</span> ↵
</span></span><span style=display:flex><span>╰─ ./converter-example -h   
</span></span><span style=display:flex><span>Usage: ./converter-example <span style=color:#666>[</span>options<span style=color:#666>]</span> &lt;datafile&gt; ...
</span></span><span style=display:flex><span>Where options are:
</span></span><span style=display:flex><span>-iber        Input is in BER <span style=color:#666>(</span>Basic Encoding Rules<span style=color:#666>)</span> or DER
</span></span><span style=display:flex><span>-ioer        Input is in OER <span style=color:#666>(</span>Octet Encoding Rules<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-iper        Input is in Unaligned PER <span style=color:#666>(</span>Packed Encoding Rules<span style=color:#666>)</span> <span style=color:#666>(</span>DEFAULT<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-ixer        Input is in XER <span style=color:#666>(</span>XML Encoding Rules<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-oder        Output as DER <span style=color:#666>(</span>Distinguished Encoding Rules<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-ooer        Output as Canonical OER <span style=color:#666>(</span>Octet Encoding Rules<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-oper        Output as Unaligned PER <span style=color:#666>(</span>Packed Encoding Rules<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-oxer        Output as XER <span style=color:#666>(</span>XML Encoding Rules<span style=color:#666>)</span> <span style=color:#666>(</span>DEFAULT<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-otext       Output as plain semi-structured text
</span></span><span style=display:flex><span>-onull       Verify <span style=color:#666>(</span>decode<span style=color:#666>)</span> input, but <span style=color:#a2f;font-weight:700>do</span> not output
</span></span><span style=display:flex><span>-per-nopad   Assume PER PDUs are not padded <span style=color:#666>(</span>-iper<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-p &lt;PDU&gt;     Specify PDU <span style=color:#a2f>type</span> to decode
</span></span><span style=display:flex><span>-p list      List available PDUs
</span></span><span style=display:flex><span>-1           Decode only the first PDU in file
</span></span><span style=display:flex><span>-b &lt;size&gt;    Set the i/o buffer size <span style=color:#666>(</span>default is 8192<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-c           Check ASN.1 constraints after decoding
</span></span><span style=display:flex><span>-d           Enable debugging <span style=color:#666>(</span>-dd is even better<span style=color:#666>)</span>
</span></span><span style=display:flex><span>-n &lt;num&gt;     Process files &lt;num&gt; <span style=color:#a2f>times</span>
</span></span><span style=display:flex><span>-s &lt;size&gt;    Set the stack usage limit <span style=color:#666>(</span>default is 30000<span style=color:#666>)</span>
</span></span></code></pre></div></li></ol><h3 id=12-一个rectangle编码器>1.2 一个“Rectangle”编码器</h3><p>这个示例将帮助你新增一个“Rectangle”的BER、XER编码器。</p><ol><li><p>为了方便查看文件，我们在<em>asn1c</em>下新建<em>asn_files</em>和<em>out</em>两个文件夹，分别用来存放asn源文件和输出文件；</p></li><li><p>在<code>asn_files</code>下增加一个文件<em>rectangle.asn</em> ，内容如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ASN.1 data-lang=ASN.1><span style=display:flex><span>RectangleModule DEFINITIONS ::= BEGIN
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Rectangle ::= SEQUENCE {
</span></span><span style=display:flex><span>height INTEGER,
</span></span><span style=display:flex><span>width INTEGER
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>END
</span></span></code></pre></div></li><li><p>执行如下指令，使用asn1c将其编译成.c和.h文件</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>asn1c -no-gen-example -D out asn_files/rectangle.asn
</span></span></code></pre></div></li><li><p>到这里，就可以在<em>out</em>文件夹下得到多个文件，其中包含了<em>Rectangle.c</em> 和<em>Rectangle.h</em>。</p></li><li><p>创建一个包含<em>main.c</em>的文件，在main()函数中创建结构体<code>Rectangle_t</code>，然后使用BER、XER编码规则进行编码。main.c内容如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* @Author       : lv zhipeng
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* @Date         : 2022-06-09 16:10:41
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* @LastEditors  : lv zhipeng
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* @LastEditTime : 2022-06-09 16:11:55
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* @FilePath     : /asn1c/out/main.c
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>* @Description  :
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>*
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>*/</span>
</span></span><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;Rectangle.h&gt; /* Rectangle ASN.1 type */</span><span style=color:#080>
</span></span></span><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;stdio.h&gt;</span><span style=color:#080>
</span></span></span><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;sys/types.h&gt;</span><span style=color:#080>
</span></span></span><span style=display:flex><span><span style=color:#080></span><span style=color:#080;font-style:italic>/* Write the encoded output into some FILE stream. */</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>static</span> <span style=color:#0b0;font-weight:700>int</span>
</span></span><span style=display:flex><span><span style=color:#00a000>write_out</span>(<span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>buffer, size_t size, <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>app_key) {
</span></span><span style=display:flex><span>  FILE <span style=color:#666>*</span>out_fp <span style=color:#666>=</span> app_key;
</span></span><span style=display:flex><span>  size_t wrote <span style=color:#666>=</span> fwrite(buffer, <span style=color:#666>1</span>, size, out_fp);
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>return</span> (wrote <span style=color:#666>==</span> size) <span style=color:#666>?</span> <span style=color:#666>0</span> <span style=color:#666>:</span> <span style=color:#666>-</span><span style=color:#666>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>int</span>
</span></span><span style=display:flex><span><span style=color:#00a000>main</span>(<span style=color:#0b0;font-weight:700>int</span> ac, <span style=color:#0b0;font-weight:700>char</span> <span style=color:#666>**</span>av) {
</span></span><span style=display:flex><span>  Rectangle_t <span style=color:#666>*</span>rectangle; <span style=color:#080;font-style:italic>/* Type to encode */</span>
</span></span><span style=display:flex><span>  asn_enc_rval_t ec;      <span style=color:#080;font-style:italic>/* Encoder return value */</span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Allocate the Rectangle_t */</span>
</span></span><span style=display:flex><span>  rectangle <span style=color:#666>=</span> calloc(<span style=color:#666>1</span>, <span style=color:#a2f;font-weight:700>sizeof</span>(Rectangle_t)); <span style=color:#080;font-style:italic>/* not malloc! */</span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span>(<span style=color:#666>!</span>rectangle) {
</span></span><span style=display:flex><span>      perror(<span style=color:#b44>&#34;calloc() failed&#34;</span>);
</span></span><span style=display:flex><span>      exit(<span style=color:#666>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Initialize the Rectangle members */</span>
</span></span><span style=display:flex><span>  rectangle<span style=color:#666>-&gt;</span>height <span style=color:#666>=</span> <span style=color:#666>42</span>; <span style=color:#080;font-style:italic>/* any random value */</span>
</span></span><span style=display:flex><span>  rectangle<span style=color:#666>-&gt;</span>width <span style=color:#666>=</span> <span style=color:#666>23</span>;  <span style=color:#080;font-style:italic>/* any random value */</span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* BER encode the data if filename is given */</span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span>(ac <span style=color:#666>&lt;</span> <span style=color:#666>2</span>) {
</span></span><span style=display:flex><span>fprintf(stderr, <span style=color:#b44>&#34;Specify filename for BER output</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>);
</span></span><span style=display:flex><span>  } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>char</span> <span style=color:#666>*</span>filename <span style=color:#666>=</span> av[<span style=color:#666>1</span>];
</span></span><span style=display:flex><span>      FILE <span style=color:#666>*</span>fp <span style=color:#666>=</span> fopen(filename, <span style=color:#b44>&#34;wb&#34;</span>); <span style=color:#080;font-style:italic>/* for BER output */</span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span>(<span style=color:#666>!</span>fp) {
</span></span><span style=display:flex><span>          perror(filename);
</span></span><span style=display:flex><span>          exit(<span style=color:#666>1</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#080;font-style:italic>/* Encode the Rectangle type as BER (DER) */</span>
</span></span><span style=display:flex><span>      ec <span style=color:#666>=</span> der_encode(<span style=color:#666>&amp;</span>asn_DEF_Rectangle, rectangle, write_out, fp);
</span></span><span style=display:flex><span>      fclose(fp);
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>if</span>(ec.encoded <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#666>1</span>) {
</span></span><span style=display:flex><span>          fprintf(stderr, <span style=color:#b44>&#34;Could not encode Rectangle(at % s)</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>,
</span></span><span style=display:flex><span>                  ec.failed_type <span style=color:#666>?</span> ec.failed_type<span style=color:#666>-&gt;</span><span style=color:#a0a000>name</span> : <span style=color:#b44>&#34;unknown&#34;</span>);
</span></span><span style=display:flex><span>          exit(<span style=color:#666>1</span>);
</span></span><span style=display:flex><span>      } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>          fprintf(stderr, <span style=color:#b44>&#34;Created % s with BER encoded Rectangle</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>,
</span></span><span style=display:flex><span>                  filename);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Also print the constructed Rectangle XER encoded (XML) */</span>
</span></span><span style=display:flex><span>  xer_fprint(stdout, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, rectangle);
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>; <span style=color:#080;font-style:italic>/* Encoding finished successfully */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>这里有一个asn1c的bug，需要从<em>asn1c</em>源码目录手动复制这几个文件到out目录再编译，否则需要禁用相关OER的编解码，具体解决方案可以看<a href=https://github.com/vlm/asn1c/issues/311>这里</a></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>cd out
</span></span><span style=display:flex><span>cp ../skeletons/BIT_STRING* ./
</span></span><span style=display:flex><span>cp ../skeletons/OCTET_STRING*  ./
</span></span></code></pre></div></li><li><p>编译所有文件，生成可执行文件rencode。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cc -I. -o rencode *.c
</span></span></code></pre></div></li><li><p>这个rencode程序，就是支持BER、XER编码的Rectangle编码器，运行程序可以看到我们在<code>main()</code>函数中填充的数据XER格式的输出：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>╭─ caeri@ubuntu  ~/lzp/GIT/asn1c/out   master ?  INSERT                                                                                                                                            ✔
</span></span><span style=display:flex><span>╰─ ./rencode   
</span></span><span style=display:flex><span>Specify filename <span style=color:#a2f;font-weight:700>for</span> BER output
</span></span><span style=display:flex><span>&lt;Rectangle&gt;
</span></span><span style=display:flex><span>  &lt;height&gt;42&lt;/height&gt;
</span></span><span style=display:flex><span>  &lt;width&gt;23&lt;/width&gt;
</span></span><span style=display:flex><span>&lt;/Rectangle&gt;
</span></span></code></pre></div></li></ol><h3 id=13-一个rectangle解码器>1.3 一个“Rectangle”解码器</h3><p>这个示例将帮助你新增一个“Rectangle”的BER、XER解码器。</p><ol><li><p>新建一个名为rectangle.asn 的文件。内容如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ASN.1 data-lang=ASN.1><span style=display:flex><span>RectangleModule DEFINITIONS ::= BEGIN
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Rectangle ::= SEQUENCE {
</span></span><span style=display:flex><span>height INTEGER,
</span></span><span style=display:flex><span>width INTEGER
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>END
</span></span></code></pre></div></li><li><p>执行如下指令，使用asn1c将其编译成.c和.h文件</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>asn1c -no-gen-example -D out asn_files/rectangle.asn
</span></span></code></pre></div></li><li><p>到这里，就可以在当前文件夹下得到多个文件，其中包含了Rectangle.c 和Rectangle.h。</p></li><li><p>创建一个main.c文件，包含main()函数，该函数接收一个二进制输入文件，它将输入文件按照BER编码规则进行解码为Rectangle 格式，然后会打印输出XML格式的内容。内容如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;Rectangle.h&gt; /* Rectangle ASN.1 type */</span><span style=color:#080>
</span></span></span><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;stdio.h&gt;</span><span style=color:#080>
</span></span></span><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;sys/types.h&gt;</span><span style=color:#080>
</span></span></span><span style=display:flex><span><span style=color:#080></span><span style=color:#0b0;font-weight:700>int</span>
</span></span><span style=display:flex><span><span style=color:#00a000>main</span>(<span style=color:#0b0;font-weight:700>int</span> ac, <span style=color:#0b0;font-weight:700>char</span> <span style=color:#666>**</span>av) {
</span></span><span style=display:flex><span>  <span style=color:#0b0;font-weight:700>char</span> buf[<span style=color:#666>1024</span>];             <span style=color:#080;font-style:italic>/* Temporary buffer */</span>
</span></span><span style=display:flex><span>  asn_dec_rval_t rval;        <span style=color:#080;font-style:italic>/* Decoder return value */</span>
</span></span><span style=display:flex><span>  Rectangle_t <span style=color:#666>*</span>rectangle <span style=color:#666>=</span> <span style=color:#666>0</span>; <span style=color:#080;font-style:italic>/* Type to decode. Note this 01! */</span>
</span></span><span style=display:flex><span>  FILE <span style=color:#666>*</span>fp;                   <span style=color:#080;font-style:italic>/* Input file handler */</span>
</span></span><span style=display:flex><span>  size_t size;                <span style=color:#080;font-style:italic>/* Number of bytes read */</span>
</span></span><span style=display:flex><span>  <span style=color:#0b0;font-weight:700>char</span> <span style=color:#666>*</span>filename;             <span style=color:#080;font-style:italic>/* Input file name */</span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Require a single filename argument */</span>
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span>(ac <span style=color:#666>!=</span> <span style=color:#666>2</span>) {
</span></span><span style=display:flex><span>      fprintf(stderr, <span style=color:#b44>&#34;Usage: % s&lt;file.ber&gt;</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>, av[<span style=color:#666>0</span>]);
</span></span><span style=display:flex><span>      exit(<span style=color:#666>1</span>);
</span></span><span style=display:flex><span>  } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>      filename <span style=color:#666>=</span> av[<span style=color:#666>1</span>];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Open input file as readିonly binary */</span>
</span></span><span style=display:flex><span>  fp <span style=color:#666>=</span> fopen(filename, <span style=color:#b44>&#34;rb&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span>(<span style=color:#666>!</span>fp) {
</span></span><span style=display:flex><span>      perror(filename);
</span></span><span style=display:flex><span>      exit(<span style=color:#666>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Read up to the buffer size */</span>
</span></span><span style=display:flex><span>  size <span style=color:#666>=</span> fread(buf, <span style=color:#666>1</span>, <span style=color:#a2f;font-weight:700>sizeof</span>(buf), fp);
</span></span><span style=display:flex><span>  fclose(fp);
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span>(<span style=color:#666>!</span>size) {
</span></span><span style=display:flex><span>      fprintf(stderr, <span style=color:#b44>&#34;% s: Empty or broken</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>, filename);
</span></span><span style=display:flex><span>      exit(<span style=color:#666>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Decode the input buffer as Rectangle type */</span>
</span></span><span style=display:flex><span>  rval <span style=color:#666>=</span> ber_decode(<span style=color:#666>0</span>, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, (<span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>**</span>)<span style=color:#666>&amp;</span>rectangle, buf, size);
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>if</span>(rval.code <span style=color:#666>!=</span> RC_OK) {
</span></span><span style=display:flex><span>      fprintf(stderr, <span style=color:#b44>&#34;% s: Broken Rectangle encoding at byte% ld</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44> &#34;</span>, filename,(<span style=color:#0b0;font-weight:700>long</span>)rval.consumed);
</span></span><span style=display:flex><span>      exit(<span style=color:#666>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>/* Print the decoded Rectangle type as XML */</span>
</span></span><span style=display:flex><span>  xer_fprint(stdout, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, rectangle);
</span></span><span style=display:flex><span>  <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>0</span>; <span style=color:#080;font-style:italic>/* Decoding finished successfully */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>编译所有文件，生成可执行文件rencode（<em>注意参考1.2复制缺少的文件</em>）。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cc -I. -o rdecode *.c
</span></span></code></pre></div></li><li><p>这个<code>rdncode</code>程序，就是支持<code>BER</code>、<code>XER</code>编码的<em>Rectangle</em>解码器。</p></li></ol><h3 id=14--给rectangle增加约束数据验证>1.4 给“Rectangle”增加约束(数据验证)</h3><p>此示例显示如何向 ASN.1 规范添加基本约束以及如何调用应用程序中的约束验证代码。</p><ol><li><p>创建名为rectangle.asn的文件。内容如下:</p><p>这里我们对asn的使用手册中rectangle.asn进行了修改，将<code>width INTEGER (0..MAX)</code>修改为<code>width INTEGER (0..200)</code>，因为在使用MAX时，没有指定具体的最大值，所以在后边的<code>asn_check_constraints()</code>时发生错误。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ASN.1 data-lang=ASN.1><span style=display:flex><span>RectangleModuleWithConstraints DEFINITIONS ::= BEGIN
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Rectangle ::= SEQUENCE {
</span></span><span style=display:flex><span>height INTEGER (0..100), -- Value range constraint
</span></span><span style=display:flex><span>width INTEGER (0..200) -- Makes width non-negative
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>END
</span></span></code></pre></div></li><li><p>参考1.3中节，编译文件生成.c和.h。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>asn1c -no-gen-example -D out asn_files/rectangle.asn
</span></span></code></pre></div></li><li><p>新建main.c，将<em>1.2 一个“Rectangle”编码器</em>中的<code>main.c</code>复制过来，然后将如下代码加入到处理程序末尾，部分如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/* Also print the constructed Rectangle XER encoded (XML) */</span>
</span></span><span style=display:flex><span>xer_fprint(stdout, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, rectangle);
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>int</span> ret;<span style=color:#080;font-style:italic>/* Return value */</span>
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>char</span> errbuf[<span style=color:#666>128</span>];   <span style=color:#080;font-style:italic>/* Buffer for error message */</span>
</span></span><span style=display:flex><span>size_t errlen <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>sizeof</span>(errbuf); <span style=color:#080;font-style:italic>/* Size of the buffer */</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* ... here goes the Rectangle decoding code ... */</span>
</span></span><span style=display:flex><span>ret <span style=color:#666>=</span> asn_check_constraints(<span style=color:#666>&amp;</span>asn_DEF_Rectangle, rectangle, errbuf, <span style=color:#666>&amp;</span>errlen);
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* assert(errlen &lt; sizeof(errbuf)); // you may rely on that */</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>if</span>(ret) {
</span></span><span style=display:flex><span>fprintf(stderr, <span style=color:#b44>&#34;Constraint validation failed : % s</span><span style=color:#b62;font-weight:700>\n</span><span style=color:#b44>&#34;</span>, errbuf);
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* exit(...); // Replace with appropriate action */</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* ... here goes the Rectangle encoding code ... */</span>
</span></span></code></pre></div></li><li><p>像上一节那样编译所有文件，这里主要要复制</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#a2f>cd</span> out
</span></span><span style=display:flex><span>cp ../skeletons/BIT_STRING* ./
</span></span><span style=display:flex><span>cp ../skeletons/OCTET_STRING*  ./
</span></span><span style=display:flex><span>cc -I. -o rencode *.c
</span></span></code></pre></div></li><li><p>这里我们进行两次实验，分别让填充数据合法和超限，观察程序的检测结果：</p><ul><li><p>第一次，数据合法</p><ul><li><p>填充合法数据</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/* Initialize the Rectangle members */</span>
</span></span><span style=display:flex><span>rectangle<span style=color:#666>-&gt;</span>height <span style=color:#666>=</span> <span style=color:#666>15</span>; <span style=color:#080;font-style:italic>/* any random value */</span>
</span></span><span style=display:flex><span>rectangle<span style=color:#666>-&gt;</span>width <span style=color:#666>=</span> <span style=color:#666>30</span>;   <span style=color:#080;font-style:italic>/* any random value */</span>
</span></span></code></pre></div></li><li><p>执行结果</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>╭─ caeri@ubuntu  ~/lzp/GIT/asn1c/out   master ?  INSERT                                                                                                                                  SIGINT<span style=color:#666>(</span>2<span style=color:#666>)</span> ↵
</span></span><span style=display:flex><span>╰─ ./rencode 
</span></span><span style=display:flex><span>Specify filename <span style=color:#a2f;font-weight:700>for</span> BER output
</span></span><span style=display:flex><span>&lt;Rectangle&gt;
</span></span><span style=display:flex><span>    &lt;height&gt;15&lt;/height&gt;
</span></span><span style=display:flex><span>    &lt;width&gt;30&lt;/width&gt;
</span></span><span style=display:flex><span>&lt;/Rectangle&gt;
</span></span></code></pre></div></li></ul></li><li><p>第二次，数据超限</p><ul><li><p>填充超限数据</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-style:italic>/* Initialize the Rectangle members */</span>
</span></span><span style=display:flex><span>rectangle<span style=color:#666>-&gt;</span>height <span style=color:#666>=</span> <span style=color:#666>150</span>; <span style=color:#080;font-style:italic>/* any random value */</span>
</span></span><span style=display:flex><span>rectangle<span style=color:#666>-&gt;</span>width <span style=color:#666>=</span> <span style=color:#666>300</span>;   <span style=color:#080;font-style:italic>/* any random value */</span>
</span></span></code></pre></div></li><li><p>执行结果</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>╭─ caeri@ubuntu  ~/lzp/GIT/asn1c/out   master ?  INSERT                                                                                                                                            ✔
</span></span><span style=display:flex><span>╰─ ./rencode            
</span></span><span style=display:flex><span>Specify filename <span style=color:#a2f;font-weight:700>for</span> BER output
</span></span><span style=display:flex><span>&lt;Rectangle&gt;
</span></span><span style=display:flex><span>    &lt;height&gt;150&lt;/height&gt;
</span></span><span style=display:flex><span>    &lt;width&gt;300&lt;/width&gt;
</span></span><span style=display:flex><span>&lt;/Rectangle&gt;
</span></span><span style=display:flex><span>Constraint validation failed : INTEGER: constraint failed <span style=color:#666>(</span>Rectangle.c:30<span style=color:#666>)</span>
</span></span></code></pre></div></li></ul></li></ul></li><li><p>至此，数据验证演示完毕。</p></li></ol><h2 id=asn1编译器>ASN.1编译器</h2><h3 id=21-asn1c编译工具>2.1 ASN1C编译工具</h3><p>ASN.1编译器是将ASN.1表示法中的规范转换为其他一些语言，例如C语言。</p><p>编译器读取(输入)规范，发出(输出)一系列目标语言的结构(struct, union, enum )来实现相应的ASN.1类型。编译器还会创建支持这些结构体序列化/反序列化的代码，代码支持BER、DER、OER、PER、XER的编码规则。</p><p>这里以ASN.1为例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ASN.1 data-lang=ASN.1><span style=display:flex><span>RectangleModule DEFINITIONS ::= BEGIN
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Rectangle ::= SEQUENCE {
</span></span><span style=display:flex><span>height INTEGER, -- Height of the rectangle
</span></span><span style=display:flex><span>width INTEGER --Width of the rectangle
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>END
</span></span></code></pre></div><p>编译器读取上述的ASN.1定义，并生成一下的C结构体：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#a2f;font-weight:700>typedef</span> <span style=color:#a2f;font-weight:700>struct</span> Rectangle_s {
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>long</span> height;
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>long</span> width;
</span></span><span style=display:flex><span>} Rectangle_t;
</span></span></code></pre></div><p>asn1c 编译器还创建了用于将此结构转换为独立于平台的解码器代码,解码代码支持将解码内容返回到本地机器。这些编码器和解码器也成为串行器、和反串行器。</p><p>将ASN.1模块编译成C编码器可以像调用asn1c一样简单。</p><p>用于编译 ASN.1 模块：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SH data-lang=SH><span style=display:flex><span>asn1c &lt;modules.asn&gt;
</span></span></code></pre></div><p>如果多个ASN.1模块包含互相以来的关系，编译的时候需要包含多个asn文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>asn1c &lt;module1.asn&gt; &lt;module2.asn&gt; ...
</span></span></code></pre></div><p>编译器的参数-E和-EF用来检测解析和语义错误。这些选项将指示编译器按照编译器所理解的进行转储已解析的（-F
会尝试修复）ASN.1 规范，这个参数可以用来检查编译器是否正确支持当前的语法构造。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>asn1c -EF &lt;module-to-test.asn&gt;
</span></span></code></pre></div><p>-P 选项用于将编译后的输出打印到屏幕上，而不是创建一堆当前目录中磁盘上的 .c 和 .h 文件。 另一个选项 -R，询问编译器只生成需要生成的文件，并阻止生成大量链接支持文件。</p><p>打印编译输出而不是创建多个源文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>asn1c -P &lt;module-to-compile-and-print.asn&gt;
</span></span></code></pre></div><h3 id=22-编译器输出>2.2 编译器输出</h3><p>asn1c编译器会输出一些文件，包括：</p><ul><li>.asn文件中定义的每种ASN类型对应的.c和.h文件。这些文件名的命名类似于ASN.1格式，(例如第一章提到的RectangleModule ASN.1 模块的 Rectangle.c 和 Rectangle.h)。</li><li>一些其他辅助程序的.c和.h文件，例如通用的编码器、解码器和其他有用的demo。</li><li>一个Makefile.am.libasncodecs文件，它显式的列出了所有生成的文件。这个makefile可以用来编译编解码库。</li><li>一个converter-example.c 文件，它包含了main()函数，支持编码和数据格式转换。它可以将给定的PDU文件在BER、XER、OER和PER之间进行转换。有时候我们的应用代码就是在这个文件基础上进行修改。</li><li>一个converter-example.mk 文件，该makefile文件通过编译<em>Makefile.am.libasncodecs</em> 和<em>converterexample.c</em> 文件，为你的ASN数据格式生成一个转换和调试程序。</li></ul><p>只需要几条指令就可以编译所有内容：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>asn1c -pdu<span style=color:#666>=</span>Rectangle *.asn
</span></span><span style=display:flex><span>make -f converte-example.mk <span style=color:#080;font-style:italic># If you use ‘make‘</span>
</span></span></code></pre></div><p>这里有一个小的技巧，因为我们在第一章中，输入的asn文件在asn_files文件夹下，输出在out下，因此我这里编译的时候需要将Makefile.am.libasncodec复制到out下，然后修改<em>converter-example.mk</em>如下部分：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#080;font-style:italic>#修改前
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span>include</span> <span>out/Makefile.am.libasncodec</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>ASN_PROGRAM_SRCS</span> <span style=color:#666>?=</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>	out/converter-example.c
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>#修改后
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span>include</span> <span>Makefile.am.libasncodec</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>ASN_PROGRAM_SRCS</span> <span style=color:#666>?=</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>	converter-example.c
</span></span></code></pre></div><h3 id=23-命令行配置>2.3 命令行配置</h3><p>下边表格总结了ASN1C的命令行选项。</p><table><thead><tr><th>阶段选择选项</th><th>描述</th></tr></thead><tbody><tr><td>-E</td><td>在执行解析阶段后停止，并打印重建的 ASN.1规范代码到标准输出。</td></tr><tr><td>-F</td><td>和-E选项一起使用，指示编译器在 ASN.1 语法树修复阶段后停止并将重构的 ASN.1 规范转储到标准输出。</td></tr><tr><td>-P</td><td>将编译后的输出转储到标准输出，而不是在磁盘上创建目标语言文件。</td></tr><tr><td>-R</td><td>限制编译器只生成 ASN.1 表，省略通常的支持代码。</td></tr><tr><td>-S</td><td>指定文件夹下的ASN.1文件。</td></tr><tr><td>-X</td><td>为指定的ASN.1模块生成XML DTD。</td></tr></tbody></table><table><thead><tr><th>警告选项</th><th>描述</th></tr></thead><tbody><tr><td>-Werror</td><td>将警告视为错误； 如果产生任何警告则中止</td></tr><tr><td>-Wdebug-parser</td><td>在 ASN.1 解析阶段启用解析器调试</td></tr><tr><td>-Wdebug-lexer</td><td>在 ASN.1 解析阶段启用词法分析器调试。</td></tr><tr><td>-Wdebug-fixer</td><td>在修复过程中启用 ASN.1 语法树修复器调试器。</td></tr><tr><td>-Wdebug-compiler</td><td>在实际编译时启用调试</td></tr></tbody></table><table><thead><tr><th>语言配置</th><th>描述</th></tr></thead><tbody><tr><td>-fbless-SIZE</td><td>*允许INTEGER, ENUMERATED和其他类型的约束，通常为了防止数据数值范围超出导致错误禁止该选项，即数值超出范围不会报错。*这违反了ASN.1标准，可能导致生成的代码没有用。<strong>待验证</strong></td></tr><tr><td>-fcompound-names</td><td>对 C 结构使用复杂的名称。如果模块在多个上下文中重用相同的标识符，则使用复杂的名称可以防止名称冲突</td></tr><tr><td>-findirect-choice</td><td>为 CHOICE 类型生成代码时，编译 CHOICE成员作为间接指针而不是内联声明。考虑将此选项与 -fno-includedeps 一起使用以防止循环引用。</td></tr><tr><td>-fincludes-quoted</td><td>在“double”而不是 引号中生成 #include 行。</td></tr><tr><td>-fknown-extern-type=</td><td>假装指定的类型是已知的。 编译器会假设给定类型的目标语言源文件已手动提供。</td></tr><tr><td>-fline-refs</td><td>在生成的代码注释中包含 ASN.1 模块的行号。</td></tr><tr><td>-fno-constraints</td><td>不产生ASN.1的类型约束代码片段，这样可执行文件小一点 。</td></tr><tr><td>-fno-include-deps</td><td>不为非关键项生成#include包含。</td></tr><tr><td>-fwide-types</td><td>使用泛类型定义(INTEGER_t, REAL_t )，而不是机器自身的类型定义(long, double )。</td></tr><tr><td>-no-gen-OER</td><td>不生成OER支持代码</td></tr><tr><td>-no-gen-PER</td><td>不生成PER支持代码</td></tr><tr><td>-no-gen-example</td><td>不生产ASN.1格式转换示例。</td></tr><tr><td>-pdu={all \</td><td>auto \</td></tr></tbody></table><table><thead><tr><th>输出选项</th><th>描述</th></tr></thead><tbody><tr><td>-print-class-matrix</td><td>当配置了-EF选项，这个选项指示编译器打印收集到的ASN对象矩阵。</td></tr><tr><td>-print-constraints</td><td>当配置了-EF选项，此选项指示编译器打印其对子类型约束的内部理解。</td></tr><tr><td>-print-lines</td><td>在 -E 输出中生成“&ndash; #line”注释</td></tr></tbody></table><h2 id=api参考>API参考</h2><p>本章中描述的函数供开发人员使用。这些功能在下一个主要版本之前不太可能改变或被删除。</p><p>此处未列出的 API 调用不是公开的，不应由应用程序调用。</p><h3 id=31-宏定义-asn_struct_free-macro>3.1 宏定义 ASN_STRUCT_FREE() macro</h3><h4 id=概要>概要</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080>#define ASN_STRUCT_FREE(type_descriptor, struct_ptr)
</span></span></span></code></pre></div><h4 id=描述>描述</h4><p>递归释放由type_descriptor描述的结构所占用的内存。并由struct_ptr指针引用。</p><p>当struct_ptr为NULL时，不执行任何操作。</p><h4 id=返回值>返回值</h4><p>无</p><h4 id=示例>示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Rectangle_t <span style=color:#666>*</span>rect <span style=color:#666>=</span> ...;
</span></span><span style=display:flex><span>ASN_STRUCT_FREE(asn_DEF_Rectangle, rect);
</span></span></code></pre></div><h3 id=32-宏定义-asn_struct_reset>3.2 宏定义 ASN_STRUCT_RESET()</h3><h4 id=概要-1>概要</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080>#define ASN_STRUCT_RESET(type_descriptor, struct_ptr)
</span></span></span></code></pre></div><h4 id=描述-1>描述</h4><p>递归的释放struct_ptr指向的内存。</p><p>但是不释放struct_ptr本身指向的内存，而是用0来填充struct_ptr指向的内存。</p><p>当 struct_ptr 为 NULL 时什么也不做。</p><h4 id=返回值-1>返回值</h4><p>无</p><h4 id=示例-1>示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a2f;font-weight:700>struct</span> my_figure { <span style=color:#080;font-style:italic>/* The custom structure */</span>
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>int</span> flags; <span style=color:#080;font-style:italic>/* &lt;some custom member&gt; */</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* The type is generated by the ASN.1 compiler */</span>
</span></span><span style=display:flex><span>Rectangle_t rect;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* other members of the structure */</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>struct</span> my_figure <span style=color:#666>*</span>fig <span style=color:#666>=</span> ...;
</span></span><span style=display:flex><span>ASN_STRUCT_RESET(asn_DEF_Rectangle, <span style=color:#666>&amp;</span>fig<span style=color:#666>-&gt;</span>rect);
</span></span></code></pre></div><h3 id=33-asn_check_constraints>3.3 asn_check_constraints()</h3><h4 id=概要-2>概要</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#0b0;font-weight:700>int</span> <span style=color:#00a000>asn_check_constraints</span>(
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> asn_TYPE_descriptor_t <span style=color:#666>*</span>type_descriptor,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>struct_ptr, <span style=color:#080;font-style:italic>/* Target language’s structure */</span>
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>char</span> <span style=color:#666>*</span>errbuf, <span style=color:#080;font-style:italic>/* Returned error description */</span>
</span></span><span style=display:flex><span>size_t <span style=color:#666>*</span>errlen <span style=color:#080;font-style:italic>/* Length of the error description */</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h4 id=描述-2>描述</h4><p>根据 ASN.1 规则验证给定结构。 如果 errbuf 和 errlen 被赋值，则在调用此函数之前，它们应指向适当的缓冲区空间及其长度。或者，它们可以作为 NULL 传递。 如果约束验证失败，则 errlen将包含 errbuf 中用于编码错误消息的实际字节数。 如果正确，则返回0.</p><h4 id=返回值-2>返回值</h4><p>满足ASN.1限制则返回 0</p><p>如果违反了一个或多个 ASN.1 约束，则为 -1</p><h4 id=示例-2>示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Rectangle_t <span style=color:#666>*</span>rect <span style=color:#666>=</span> ...;
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>char</span> errbuf[<span style=color:#666>128</span>]; <span style=color:#080;font-style:italic>/* Buffer for error message */</span>
</span></span><span style=display:flex><span>size_t errlen <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>sizeof</span>(errbuf); <span style=color:#080;font-style:italic>/* Size of the buffer */</span>
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>int</span> ret <span style=color:#666>=</span> asn_check_constraints(<span style=color:#666>&amp;</span>asn_DEF_Rectangle, rectangle, errbuf, <span style=color:#666>&amp;</span>errlen);
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>/* assert(errlen &lt; sizeof(errbuf)); // Guaranteed: you may rely on that */</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>if</span>(ret) {
</span></span><span style=display:flex><span>    fprintf(stderr, <span>”</span>Constraint validation <span style=color:#a0a000>failed</span>: <span style=color:#666>%</span>s<span>\</span>n<span>”</span>, errbuf);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=34-ask_decode>3.4 ask_decode()</h3><h4 id=概要-3>概要</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>asn_dec_rval_t <span style=color:#00a000>asn_decode</span>(
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> asn_codec_ctx_t <span style=color:#666>*</span>opt_codec_ctx,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>enum</span> asn_transfer_syntax syntax,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> asn_TYPE_descriptor_t <span style=color:#666>*</span>type_descriptor,
</span></span><span style=display:flex><span><span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>**</span>struct_ptr_ptr,<span style=color:#080;font-style:italic>/* Pointer to a target structure’s ptr */</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>buffer, <span style=color:#080;font-style:italic>/* Data to be decoded */</span>
</span></span><span style=display:flex><span>size_t size <span style=color:#080;font-style:italic>/* Size of that buffer */</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h4 id=描述-3>描述</h4><p>函数解析buffer缓冲区，其大小为size。编码规则在参数syntax中指定，要解码的类型为由 type_descriptor 指定。</p><p>struct_ptr_ptr 必须指向包含指向正在解码的结构(即buffer中的相同结构)的指针的内存位置。 最初通常设置 *struct_ptr_ptr 指针 到0。在这种情况下，asn_decode() 将为结构动态分配内存在解析过程中根据需要添加其成员。 如果 *struct_ptr_ptr 已经指向一些内存，asn_decode() 将根据需要分配后续成员解析 。</p><h4 id=返回值-3>返回值</h4><p>在不成功终止时，*struct_ptr_ptr 可能包含部分解码数据。 此数据可能对调试有用（例如通过使用 asn_fprint()）。务必通过调用 ASN_STRUCT_FREE() 或
ASN_STRUCT_RESET()释放内存。</p><p>成功的话会返回一个复杂的结构体:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a2f;font-weight:700>typedef</span> <span style=color:#a2f;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>enum</span> {
</span></span><span style=display:flex><span>        RC_OK, <span style=color:#080;font-style:italic>/* Decoded successfully */</span>
</span></span><span style=display:flex><span>        RC_WMORE, <span style=color:#080;font-style:italic>/* More data expected, call again */</span>
</span></span><span style=display:flex><span>        RC_FAIL <span style=color:#080;font-style:italic>/* Failure to decode data */</span>
</span></span><span style=display:flex><span>        } code; <span style=color:#080;font-style:italic>/* Result code */</span>
</span></span><span style=display:flex><span>    size_t consumed; <span style=color:#080;font-style:italic>/* Number of bytes consumed */</span>
</span></span><span style=display:flex><span>} asn_dec_rval_t;    
</span></span></code></pre></div><h4 id=重启特性restartability>重启特性(Restartability)</h4><p>有一些传输语法解析器(ATS_BER))支持重启。</p><p>这意味着如果缓冲区的数据少于预期，asn_decode() 将处理可用的任何内容，并要求使用 RC_WMORE 返回 .code 提供更多数据。</p><p>请注意，在 RC_WMORE 情况下，解码器处理的数据可能比缓冲区中可用的数据少，这意味着您必须能够安排下一个缓冲区以包含前一个缓冲区未处理的部分。</p><p>RC_WMORE 代码可能仍由不支持可重启性的解析器返回。在这种情况下，部分解码的结构将被丢弃，下一次调用应使用扩展缓冲区从一开始就进行解析。</p><h4 id=示例-3>示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Rectangle_t <span style=color:#666>*</span>rect <span style=color:#666>=</span> <span style=color:#666>0</span>; <span style=color:#080;font-style:italic>/* Note this 01! */</span>
</span></span><span style=display:flex><span>asn_dec_rval_t rval;
</span></span><span style=display:flex><span>rval <span style=color:#666>=</span> asn_decode(<span style=color:#666>0</span>, ATS_BER, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, (<span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>**</span>)<span style=color:#666>&amp;</span>rect, buffer, buf_size);
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>switch</span>(rval.code) {
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>case</span> <span style=color:#a0a000>RC_OK</span>:
</span></span><span style=display:flex><span>    asn_fprint(stdout, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, rect);
</span></span><span style=display:flex><span>    ASN_STRUCT_FREE(<span style=color:#666>&amp;</span>asn_DEF_Rectangle, rect);
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>case</span> <span style=color:#a0a000>RC_WMORE</span>:
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>case</span> <span style=color:#a0a000>RC_FAIL</span>:
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>default</span><span style=color:#666>:</span>
</span></span><span style=display:flex><span>    ASN_STRUCT_FREE(<span style=color:#666>&amp;</span>asn_DEF_Rectangle, rect);
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>break</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=参考>参考</h4><p><strong>asn_fprint()</strong></p><h3 id=35-ask_encode>3.5 ask_encode()</h3><h4 id=概要-4>概要</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080>#include</span> <span style=color:#080>&lt;asn_application.h&gt;</span><span style=color:#080>
</span></span></span><span style=display:flex><span><span style=color:#080></span>asn_enc_rval_t <span style=color:#00a000>asn_encode</span>(
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> asn_codec_ctx_t <span style=color:#666>*</span>opt_codec_ctx,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>enum</span> asn_transfer_syntax syntax,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> asn_TYPE_descriptor_t <span style=color:#666>*</span>type_to_encode,
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>structure_to_encode,
</span></span><span style=display:flex><span>asn_app_consume_bytes_f <span style=color:#666>*</span>callback, <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>callback_key);
</span></span></code></pre></div><h4 id=描述-4>描述</h4><p>asn_encode() 函数使用所选的 ASN.1 传输语法序列化给定的 structure_to_encode。</p><p>在序列化期间，用户指定的回调被调用零次或多次，其中包含要添加字节数据到输出流（如果有）和 callback_key 的数据字节。</p><p>回调的格式声明如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a2f;font-weight:700>typedef</span> <span style=color:#00a000>int</span>(asn_app_consume_bytes_f)(<span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>buffer, size_t size, <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>callback_key);
</span></span></code></pre></div><h4 id=返回值-4>返回值</h4><p>返回一个复合的结构体：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a2f;font-weight:700>typedef</span> <span style=color:#a2f;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    ssize_t encoded;
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>const</span> asn_TYPE_descriptor_t <span style=color:#666>*</span>failed_type;
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>structure_ptr;
</span></span><span style=display:flex><span>} asn_enc_rval_t;
</span></span></code></pre></div><p>如果编码不成功，.encoded 成员设置为 -1，其他成复合结构指向编码未能进一步进行的地方。</p><p>如果编码成功，.encoded成员指定序列化输出的大小。</p><p>无论选择的 ASN.1 传输语法如何，都以字节为单位返回序列化输出大小。</p><p>出错时（当 .encoded 设置为 -1 时），errno 设置为以下值之一：</p><ul><li>EINVAL 函数参数不正确，例如NULL。</li><li>ENOENT 编码传输语法未定义。</li><li>EBADF 结构体无效或内容限制失败。</li><li>EIO 在回调函数编码时返回了负值。</li></ul><h4 id=示例-4>示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a2f;font-weight:700>static</span> <span style=color:#0b0;font-weight:700>int</span>
</span></span><span style=display:flex><span><span style=color:#00a000>save_to_file</span>(<span style=color:#a2f;font-weight:700>const</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>data, size_t size, <span style=color:#0b0;font-weight:700>void</span> <span style=color:#666>*</span>key) {
</span></span><span style=display:flex><span>FILE <span style=color:#666>*</span>fp <span style=color:#666>=</span> key;
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>return</span> (fwrite(data, <span style=color:#666>1</span>, size, fp) <span style=color:#666>==</span> size) <span style=color:#666>?</span> <span style=color:#666>0</span> <span style=color:#666>:</span> <span>ି</span><span style=color:#666>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>Rectangle_t <span style=color:#666>*</span>rect <span style=color:#666>=</span> ...;
</span></span><span style=display:flex><span>FILE <span style=color:#666>*</span>fp <span style=color:#666>=</span> ...;
</span></span><span style=display:flex><span>asn_enc_rval_t er;
</span></span><span style=display:flex><span>er <span style=color:#666>=</span> asn_encode(<span style=color:#666>0</span>, ATS_DER, <span style=color:#666>&amp;</span>asn_DEF_Rectangle, rect, save_to_file, fp);
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>if</span>(er.encoded <span style=color:#666>==</span> <span>ି</span><span style=color:#666>1</span>) {
</span></span><span style=display:flex><span>fprintf(stderr, <span>”</span>Failed to encode <span style=color:#666>%</span>s<span>\</span>n<span>”</span>, asn_DEF_Rectangle.name);
</span></span><span style=display:flex><span>} <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>fprintf(stderr, <span>”</span><span style=color:#666>%</span>s encoded in <span style=color:#666>%</span>zd bytes<span>\</span>n<span>”</span>, asn_DEF_Rectangle.name, er.encoded);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=36-asn_encode_to_buffer>3.6 asn_encode_to_buffer()</h3><h4 id=概要-5>概要</h4><h4 id=描述-5>描述</h4><h4 id=返回值-5>返回值</h4><h4 id=示例-5>示例</h4><h2 id=api使用示例>API使用示例</h2><h3 id=41-通用编解码>4.1 通用编解码</h3><h3 id=42-ber解码>4.2 BER解码</h3><h3 id=43-der编码>4.3 DER编码</h3><h3 id=44-xer编码>4.4 XER编码</h3><h3 id=45-xer解码>4.5 XER解码</h3><h3 id=46-验证目标结构体>4.6 验证目标结构体</h3><h3 id=47-打印目标结构体>4.7 打印目标结构体</h3><h3 id=48-释放目标结构体>4.8 释放目标结构体</h3><h2 id=抽象语法表示asn1>抽象语法表示：ASN.1</h2><h3 id=51-asn1基础数据类型>5.1 ASN.1基础(数据)类型</h3><h4 id=511-boolean>5.1.1 BOOLEAN</h4><h4 id=512-integer>5.1.2 INTEGER</h4><h4 id=513-enumerated>5.1.3 ENUMERATED</h4><h4 id=514-octet-string>5.1.4 OCTET STRING</h4><h4 id=515-object-identifier>5.1.5 OBJECT IDENTIFIER</h4><h4 id=516-relative-oid>5.1.6 RELATIVE OID</h4><h3 id=52-asn1基础字符串类型>5.2 ASN.1基础字符串类型</h3><h4 id=521-iasstring类型>5.2.1 IASString类型</h4><h4 id=522-utf8string字符串类型>5.2.2 UTF8String字符串类型</h4><h4 id=523-numbericstring类型>5.2.3 NumbericString类型</h4><h4 id=524-printablestring类型>5.2.4 PrintableString类型</h4><h4 id=525-visiblestring类型>5.2.5 VisibleString类型</h4><h3 id=53-asn1结构体类型>5.3 ASN.1结构体类型</h3><h4 id=531-sequence类型>5.3.1 SEQUENCE类型</h4><h4 id=532-set类型>5.3.2 SET类型</h4><h4 id=533-choice类型>5.3.3 CHOICE类型</h4><h4 id=534-sequence-of类型>5.3.4 SEQUENCE OF类型</h4><h4 id=535-set-of-类型>5.3.5 SET OF 类型</h4></div><footer class=post-footer><div class=post-tags><a href=/tags/asn1c%e7%bc%96%e8%af%91%e5%99%a8 rel=tag title=ASN1C编译器>#ASN1C编译器#</a>
<a href=/tags/asn.1 rel=tag title=ASN.1>#ASN.1#</a></div><div class=post-nav><div class=article-copyright><div class=article-copyright-img><img src=/img/qq_qrcode.png width=129px height=129px><div style=text-align:center>微信扫一扫关注</div></div><div class=article-copyright-info><p><span>声明：</span>ASN1C使用手册</p><p><span>链接：</span>https://mdxz2048.github.io/post/asn1c%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</p><p><span>作者：</span>MD小智</p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/3.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作实属不易，如有帮助，那就打赏博主些许茶钱吧 ^_^</div><button id=rewardButton disable=enable onclick='var qr=document.getElementById("QR");qr.style.display==="none"?qr.style.display="block":qr.style.display="none"'>
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/img/wechat-pay.png alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=/img/ali-pay.png alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"></div><div class="post-nav-prev post-nav-item"><a href=https://mdxz2048.github.io/post/study_linux_tcp_in_linux_04/ rel=prev title=自上而下理解内核网络(四)---sock与传输层UDP>自上而下理解内核网络(四)---sock与传输层UDP
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target=post-toc-wrap>文章目录</li><li class=sidebar-nav-overview data-target=site-overview>站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/img/avatar.png alt=MD小智><p class=site-author-name itemprop=name>MD小智</p><p class="site-description motion-element" itemprop=description>我们会高估自己所拥有的一切！</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>20</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>4</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>24</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/mdxz2048 target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>
GitHub</a></span></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>
标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%90%86%E8%A7%A3%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C>自上而下理解内核网络</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5>文件同步</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/12306bypass>12306bypass</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/asn.1>Asn.1</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/asn1c%E7%BC%96%E8%AF%91%E5%99%A8>Asn1c编译器</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/hexo>Hexo</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/markdown>Markdown</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/marktext>Marktext</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/nextcloud>Nextcloud</a></li><li class=tagcloud-of-blogroll-item><a href=/tags/pdf%E8%BD%AC%E6%8D%A2>Pdf转换</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class=post-toc><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#使用开源asn1编译器介绍>使用开源ASN.1编译器介绍</a></li><li><a href=#安装>安装</a><ul><li><a href=#环境依赖httpsgithubcomvlmasn1cblobmasterrequirementsmd><a href=https://github.com/vlm/asn1c/blob/master/REQUIREMENTS.md>环境依赖</a></a></li><li><a href=#从源码编译httpsgithubcomvlmasn1cblobmasterinstallmdcompiling-from-sources><a href=https://github.com/vlm/asn1c/blob/master/INSTALL.md#compiling-from-sources>从源码编译</a></a></li></ul></li><li><a href=#快速开始示例>快速开始示例</a><ul><li><a href=#11-一个rectangle转换和调试>1.1 一个“Rectangle”转换和调试</a></li><li><a href=#12-一个rectangle编码器>1.2 一个“Rectangle”编码器</a></li><li><a href=#13-一个rectangle解码器>1.3 一个“Rectangle”解码器</a></li><li><a href=#14--给rectangle增加约束数据验证>1.4 给“Rectangle”增加约束(数据验证)</a></li></ul></li><li><a href=#asn1编译器>ASN.1编译器</a><ul><li><a href=#21-asn1c编译工具>2.1 ASN1C编译工具</a></li><li><a href=#22-编译器输出>2.2 编译器输出</a></li><li><a href=#23-命令行配置>2.3 命令行配置</a></li></ul></li><li><a href=#api参考>API参考</a><ul><li><a href=#31-宏定义-asn_struct_free-macro>3.1 宏定义 ASN_STRUCT_FREE() macro</a></li><li><a href=#32-宏定义-asn_struct_reset>3.2 宏定义 ASN_STRUCT_RESET()</a></li><li><a href=#33-asn_check_constraints>3.3 asn_check_constraints()</a></li><li><a href=#34-ask_decode>3.4 ask_decode()</a></li><li><a href=#35-ask_encode>3.5 ask_encode()</a></li><li><a href=#36-asn_encode_to_buffer>3.6 asn_encode_to_buffer()</a></li></ul></li><li><a href=#api使用示例>API使用示例</a><ul><li><a href=#41-通用编解码>4.1 通用编解码</a></li><li><a href=#42-ber解码>4.2 BER解码</a></li><li><a href=#43-der编码>4.3 DER编码</a></li><li><a href=#44-xer编码>4.4 XER编码</a></li><li><a href=#45-xer解码>4.5 XER解码</a></li><li><a href=#46-验证目标结构体>4.6 验证目标结构体</a></li><li><a href=#47-打印目标结构体>4.7 打印目标结构体</a></li><li><a href=#48-释放目标结构体>4.8 释放目标结构体</a></li></ul></li><li><a href=#抽象语法表示asn1>抽象语法表示：ASN.1</a><ul><li><a href=#51-asn1基础数据类型>5.1 ASN.1基础(数据)类型</a></li><li><a href=#52-asn1基础字符串类型>5.2 ASN.1基础字符串类型</a></li><li><a href=#53-asn1结构体类型>5.3 ASN.1结构体类型</a></li></ul></li></ul></nav></div></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2010 - 2022</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=copyright-author>MD小智</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.96.0</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span class=site-uv><i class="fa fa-user"></i>
<span class=busuanzi-value id=busuanzi_value_site_uv></span></span>
<span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i>
<span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div><div class=license-info><span class=storage-info>Storage by
<a href=http://github.com/ style=font-weight:700 target=_blank>GitHub</a></span>
<span class=separator-line>/</span>
<span class=license-num><a href=http://blog.mddxz.top/ target=_blank>MD小智</a></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i>
<span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/2.1.4/jquery.min.js></script>
<script type=text/javascript src=https://mdxz2048.github.io/js/search.js></script>
<script type=text/javascript src=https://mdxz2048.github.io/js/affix.js></script>
<script type=text/javascript src=https://mdxz2048.github.io/js/scrollspy.js></script>
<script type=text/javascript>function detectIE(){var e=window.navigator.userAgent,t=e.indexOf("MSIE "),n=e.indexOf("Trident/"),s=e.indexOf("Edge/");return t>0||n>0||s>0?-1:1}function getCntViewHeight(){var t=$("#content").height(),e=$(window).height(),n=t>e?t-e:$(document).height()-e;return n}function getScrollbarWidth(){var e=$("<div />").addClass("scrollbar-measure").prependTo("body"),t=e[0],n=t.offsetWidth-t.clientWidth;return e.remove(),n}function registerBackTop(){var t=50,e=$(".back-to-top");$(window).on("scroll",function(){e.toggleClass("back-to-top-on",window.pageYOffset>t);var s=$(window).scrollTop(),o=getCntViewHeight(),i=s/o,n=Math.round(i*100),a=n>100?100:n;$("#scrollpercent>span").html(a)}),e.on("click",function(){$("html,body").animate({scrollTop:0,screenLeft:0},800)})}function initScrollSpy(){var e=".post-toc",s=$(e),t=".active-current";s.on("activate.bs.scrollspy",function(){var t=$(e+" .active").last();n(),t.addClass("active-current")}).on("clear.bs.scrollspy",n),$("body").scrollspy({target:e});function n(){$(e+" "+t).removeClass(t.substring(1))}}function initAffix(){var e=$(".header-inner").height(),t=parseInt($(".main").css("padding-bottom"),10),n=e+10;$(".sidebar-inner").affix({offset:{top:n,bottom:t}}),$(document).on("affixed.bs.affix",function(){updateTOCHeight(document.body.clientHeight-100)})}function initTOCDimension(){$(window).on("resize",function(){e&&clearTimeout(e),e=setTimeout(function(){var e=document.body.clientHeight-100;updateTOCHeight(e)},0)}),updateTOCHeight(document.body.clientHeight-100);var e,t=getScrollbarWidth();$(".post-toc").css("width","calc(100% + "+t+"px)")}function updateTOCHeight(e){e=e||"auto",$(".post-toc").css("max-height",e)}$(function(){var t=$(".header-inner").height()+10,n,s,e,o;$("#sidebar").css({'margin-top':t}).show(),n=parseInt($("#sidebar").css("margin-top")),s=parseInt($(".sidebar-inner").css("height")),e=n+s,o=$(".content-wrap").height(),o<e&&$(".content-wrap").css("min-height",e),$(".site-nav-toggle").on("click",function(){var e=$(".site-nav"),o=$(".toggle"),t="site-nav-on",i="toggle-close",n=e.hasClass(t),a=n?"slideUp":"slideDown",s=n?"removeClass":"addClass";e.stop()[a]("normal",function(){e[s](t),o[s](i)})}),registerBackTop(),initScrollSpy(),initAffix(),initTOCDimension(),$(".sidebar-nav-toc").click(function(){$(this).addClass("sidebar-nav-active"),$(this).next().removeClass("sidebar-nav-active"),$("."+$(this).next().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)}),$(".sidebar-nav-overview").click(function(){$(this).addClass("sidebar-nav-active"),$(this).prev().removeClass("sidebar-nav-active"),$("."+$(this).prev().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)})})</script><script src=//cdn.bootcdn.net/ajax/libs/imageviewer/0.1.0/viewer.min.js></script>
<script type=text/javascript>$(function(){$(".post-body").viewer()})</script><script>(function(){var e=document.createElement("script"),t,n=window.location.protocol.split(":")[0];n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script></body></html>